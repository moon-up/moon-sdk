// This file is auto-generated by @hey-api/openapi-ts

/**
 * Represents the structure of the response from the Aave Pool API.
 */
export type AavePoolAPIResponse_any_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: unknown;
};

/**
 * Represents a transaction in the Aave V3 Pool.
 */
export type AavePoolTransaction = {
	/**
	 * The data associated with the transaction.
	 */
	data: string;
	/**
	 * The value of the transaction.
	 */
	value: string;
	/**
	 * The address of the recipient.
	 */
	to: string;
	/**
	 * The address of the sender.
	 */
	from: string;
	/**
	 * The gas price for the transaction (optional).
	 */
	gasPrice?: string;
	/**
	 * The gas limit for the transaction (optional).
	 */
	gasLimit?: string;
	/**
	 * The maximum priority fee per gas for the transaction (optional).
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The maximum fee per gas for the transaction (optional).
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce: number;
	/**
	 * The type of the transaction (optional).
	 */
	type?: number;
	/**
	 * The chain ID of the transaction.
	 */
	chainId: string;
};

/**
 * Asset type returned when calling {@link TransactNamespace.simulateAssetChanges }.
 * Allows you to determine if the assets approved or / and transferred are
 * native, tokens or NFTs.
 */
export enum SimulateAssetType {
	NATIVE = "NATIVE",
	ERC20 = "ERC20",
	ERC721 = "ERC721",
	ERC1155 = "ERC1155",
	SPECIAL_NFT = "SPECIAL_NFT",
}

/**
 * Change type returned when calling {@link TransactNamespace.simulateAssetChanges }.
 */
export enum SimulateChangeType {
	APPROVE = "APPROVE",
	TRANSFER = "TRANSFER",
}

/**
 * Represents an asset change from a call to
 * {@link TransactNamespace.simulateAssetChanges }.
 */
export type SimulateAssetChangesChange = {
	/**
	 * The type of asset from the transaction.
	 */
	assetType: SimulateAssetType;
	/**
	 * The type of change from the transaction.
	 */
	changeType: SimulateChangeType;
	/**
	 * The from address.
	 */
	from: string;
	/**
	 * The to address.
	 */
	to: string;
	/**
	 * The raw amount as an integer string. Only available on TRANSFER changes for
	 * NATIVE and ERC20 assets, or ERC721/ERC1155 disapprove changes (field set to
	 * '0').
	 */
	rawAmount?: string;
	/**
	 * The amount as an integer string. This value is calculated by applying the
	 * `decimals` field to the `rawAmount` field. Only available on TRANSFER
	 * changes for NATIVE and ERC20 assets, or ERC721/ERC1155 disapprove changes
	 * (field set to '0').
	 */
	amount?: string;
	/**
	 * The name of the asset transferred, if available.
	 */
	name?: string;
	/**
	 * The symbol of the asset transferred if available.
	 */
	symbol?: string;
	/**
	 * The number of decimals used by the ERC20 token. Set to 0 for APPROVE
	 * changes. Field is undefined if it's not defined in the contract and not
	 * available from other sources.
	 */
	decimals?: number;
	/**
	 * The contract address of the asset. Only applicable to ERC20, ERC721,
	 * ERC1155, NFT and SPECIAL_NFT transactions.
	 */
	contractAddress?: string;
	/**
	 * URL for the logo of the asset, if available. Only applicable to ERC20 transactions.
	 */
	logo?: string;
	/**
	 * The token id of the asset transferred. Only applicable to ERC721,
	 * ERC1155 and SPECIAL_NFT NFTs.
	 */
	tokenId?: string;
};

/**
 * The error field returned in a {@link SimulateAssetChangesResponse} if the
 * simulation failed.
 */
export type SimulateAssetChangesError = {
	/**
	 * The error message.
	 */
	message: string;
};

/**
 * Response object for the {@link TransactNamespace.simulateAssetChanges } method.
 */
export type SimulateAssetChangesResponse = {
	/**
	 * An array of asset changes that resulted from the transaction.
	 */
	changes: Array<SimulateAssetChangesChange>;
	/**
	 * The amount of gas used by the transaction represented as a hex string. The
	 * field is undefined if an error occurred.
	 */
	gasUsed?: string;
	/**
	 * Optional error field that is present if an error occurred.
	 */
	error?: SimulateAssetChangesError;
};

/**
 * Represents a transaction object.
 */
export type Tx = {
	/**
	 * The type of the transaction.
	 */
	type?: number;
	/**
	 * The chain ID of the blockchain network.
	 */
	chain_id?: number;
	/**
	 * The data payload of the transaction.
	 */
	data?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gas_price?: string;
	/**
	 * The gas tip cap for the transaction, used in EIP-1559 transactions.
	 */
	gas_tip_cap?: string | null;
	/**
	 * The gas fee cap for the transaction, used in EIP-1559 transactions.
	 */
	gas_fee_cap?: string | null;
	/**
	 * The value to be transferred in the transaction.
	 */
	value?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce?: number;
	/**
	 * The address of the sender.
	 */
	from?: string;
	/**
	 * The address of the recipient.
	 */
	to?: string | null;
	/**
	 * The gas used for blob transactions.
	 */
	blob_gas?: string | null;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blob_gas_fee_cap?: string | null;
	/**
	 * The hashes of the blobs included in the transaction.
	 */
	blob_hashes?: Array<string> | null;
	/**
	 * The recovery id of the transaction.
	 */
	v?: string;
	/**
	 * The signature r value of the transaction.
	 */
	r?: string;
	/**
	 * The signature s value of the transaction.
	 */
	s?: string;
};

/**
 * Represents a request to perform a transaction.
 */
export type TransactionRequest = {
	/**
	 * A unique identifier for the transaction.
	 */
	nonce?: string;
	/**
	 * The data to be sent with the transaction.
	 */
	data?: string;
	/**
	 * The amount of value to be transferred.
	 */
	value?: string;
	/**
	 * The address to which the transaction is directed.
	 */
	to?: string;
	/**
	 * The address from which the transaction is sent.
	 */
	from?: string;
	/**
	 * The maximum fee per gas unit that the sender is willing to pay.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas unit that the sender is willing to pay.
	 */
	maxPriorityFeePerGas?: string;
};

/**
 * Represents the data associated with a transaction.
 */
export type TransactionData = {
	/**
	 * The URL to view the transaction on MoonScan.
	 */
	moon_scan_url?: string;
	/**
	 * The hash of the transaction.
	 */
	transaction_hash: string;
	/**
	 * The signed transaction data.
	 */
	signed_transaction: string;
	/**
	 * The signed message associated with the transaction.
	 */
	signed_message?: string;
	/**
	 * The raw transaction data.
	 */
	raw_transaction?: string;
	/**
	 * The signature of the transaction.
	 */
	signature?: string;
	/**
	 * The transaction details.
	 */
	transaction?: Tx;
	/**
	 * The list of user operations associated with the transaction.
	 */
	userOps?: Array<TransactionRequest>;
	/**
	 * The user operation transaction data.
	 */
	userop_transaction?: string;
};

/**
 * Represents the response from broadcasting a raw transaction.
 */
export type BroadCastRawTransactionResponse = {
	/**
	 * Indicates whether the transaction was successful.
	 */
	success: boolean;
	/**
	 * The message associated with the transaction.
	 */
	message: string;
	/**
	 * The transaction hash.
	 */
	data: string;
};

/**
 * Represents a transaction with various optional properties.
 */
export type Transaction = {
	/**
	 * The simulation response of asset changes.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * The hash of the transaction.
	 */
	transaction_hash?: string;
	/**
	 * The signed transaction data.
	 */
	signed_transaction?: string;
	/**
	 * The raw transaction data.
	 */
	raw_transaction?: string;
	/**
	 * Additional data related to the transaction.
	 * Replace with the actual type if known.
	 */
	data?: string | null;
	/**
	 * An array of transaction data.
	 */
	transactions?: Array<TransactionData>;
	/**
	 * The URL to the transaction on MoonScan.
	 */
	moon_scan_url?: string;
	/**
	 * The signature of the transaction.
	 */
	signature?: string;
	/**
	 * The transaction details.
	 */
	transaction?: Tx;
	/**
	 * An array of user operation requests.
	 */
	userOps?: Array<TransactionRequest>;
	/**
	 * The user operation transaction data.
	 */
	userop_transaction?: string;
	/**
	 * The user operation data.
	 */
	user_op?: string;
	/**
	 * Indicates whether the transaction was successful.
	 */
	success?: boolean;
	/**
	 * A message related to the transaction.
	 */
	message?: string;
	/**
	 * The response after broadcasting the raw transaction.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
};

/**
 * Represents the result of executing a function on the Aave pool.
 */
export type AavePoolExecuteFunctionResult = {
	/**
	 * Optional response from simulating asset changes.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * Optional response indicating whether the transaction was broadcasted.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * Optional message providing additional information about the execution.
	 */
	message?: string;
	/**
	 * Indicates whether the function execution was successful.
	 */
	success?: boolean;
	/**
	 * Optional user operation identifier.
	 */
	user_op?: string;
	/**
	 * Optional data related to the transaction.
	 */
	data?: Transaction;
	/**
	 * The parameters passed to the function.
	 */
	params: Array<unknown>;
	/**
	 * The name of the function that was executed.
	 */
	function: string;
	/**
	 * The transaction associated with the function execution.
	 */
	transaction: AavePoolTransaction;
};

/**
 * Represents the structure of the response from the Aave Pool API.
 */
export type AavePoolAPIResponse_AavePoolExecuteFunctionResult_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: AavePoolExecuteFunctionResult;
};

/**
 * Represents a tuple containing access information.
 */
export type AccessTuple = {
	/**
	 * The address associated with the access tuple.
	 */
	address: string;
	/**
	 * An array of storage keys related to the address.
	 */
	storageKeys: Array<string>;
};

/**
 * Represents an amount of a specific token.
 */
export type TokenAmount = {
	/**
	 * The address of the token.
	 */
	tokenAddress: string;
	/**
	 * The amount of the token.
	 */
	amount: string;
};

/**
 * Represents the proportion of a specific token.
 */
export type TokenProportion = {
	/**
	 * The address of the token.
	 */
	tokenAddress: string;
	/**
	 * The proportion of the token, typically represented as a percentage or a fraction.
	 */
	proportion: number;
};

/**
 * Interface representing the input body for Aave pool transactions.
 * Extends the InputBody interface.
 */
export type AavePoolInputBody = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * The data payload for the transaction.
	 */
	data?: string;
	/**
	 * The value of the transaction.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce?: string;
	/**
	 * Indicates if the transaction should be simulated.
	 */
	simulate?: boolean;
	/**
	 * The gas limit for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Indicates if the transaction is a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Indicates if the transaction is from an externally owned account.
	 */
	EOA?: boolean;
	/**
	 * The contract address involved in the transaction.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Indicates if the transaction should be broadcasted.
	 */
	broadcast?: boolean;
	/**
	 * Indicates if the nonce should always be incremented.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount involved in the transaction.
	 */
	amount?: string;
	/**
	 * The interest rate mode for the transaction.
	 */
	interestRateMode?: number;
	/**
	 * The referral code for the transaction.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Indicates if the asset should be used as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Indicates if the AToken should be received.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
};

export type PoolAddressProviderAPIResponse_string_ = {
	success: boolean;
	message: string;
	data?: string;
};

export type PoolAddressProviderTransaction = {
	data: string;
	value: string;
	to: string;
	from: string;
	gasPrice?: string;
	gasLimit?: string;
	maxPriorityFeePerGas?: string;
	maxFeePerGas?: string;
	nonce: number;
	type?: number;
	chainId: string;
};

export type PoolAddressProviderExecuteFunctionResult = {
	simulation?: SimulateAssetChangesResponse;
	broadcasted?: BroadCastRawTransactionResponse;
	message?: string;
	success?: boolean;
	user_op?: string;
	data?: Transaction;
	params: Array<unknown>;
	function: string;
	transaction: PoolAddressProviderTransaction;
};

export type PoolAddressProviderAPIResponse_PoolAddressProviderExecuteFunctionResult_ =
	{
		success: boolean;
		message: string;
		data?: PoolAddressProviderExecuteFunctionResult;
	};

/**
 * Interface representing the input body for the Pool Address Provider.
 * Extends the InputBody interface.
 */
export type PoolAddressProviderInputBody = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * The data to be sent.
	 */
	data?: string;
	/**
	 * The value to be sent.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce?: string;
	/**
	 * Whether to simulate the transaction.
	 */
	simulate?: boolean;
	/**
	 * The gas for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Whether to perform a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Whether the transaction is from an externally owned account.
	 */
	EOA?: boolean;
	/**
	 * The contract address.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Whether to broadcast the transaction.
	 */
	broadcast?: boolean;
	/**
	 * Whether to always increment the nonce.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount involved in the transaction.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
	newAddress?: string;
	newMarketId?: string;
	newImplementationAddress?: string;
};

/**
 * Represents the API response structure for the Pool Address Provider Registry.
 */
export type PoolAddressProviderRegistryAPIResponse_string_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: string;
};

/**
 * Represents the API response structure for the Pool Address Provider Registry.
 */
export type PoolAddressProviderRegistryAPIResponse_any_Array_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: Array<unknown>;
};

/**
 * Represents the structure of the API response for AAVE v3 rewards.
 */
export type AAVEv3RewardsAPIResponse_string_Array_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: Array<string>;
};

/**
 * Represents the structure of the API response for AAVE v3 rewards.
 */
export type AAVEv3RewardsAPIResponse_string_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: string;
};

/**
 * Represents a transaction for AAVE v3 rewards.
 */
export type AAVEv3RewardsTransaction = {
	/**
	 * The data payload of the transaction.
	 */
	data: string;
	/**
	 * The value to be transferred in the transaction, in wei.
	 */
	value: string;
	/**
	 * The recipient address of the transaction.
	 */
	to: string;
	/**
	 * The sender address of the transaction.
	 */
	from: string;
	/**
	 * The gas price for the transaction, in wei.
	 * Optional.
	 */
	gasPrice?: string;
	/**
	 * The gas limit for the transaction.
	 * Optional.
	 */
	gasLimit?: string;
	/**
	 * The maximum priority fee per gas for the transaction, in wei.
	 * Optional.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The maximum fee per gas for the transaction, in wei.
	 * Optional.
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce: number;
	/**
	 * The type of the transaction.
	 * Optional.
	 */
	type?: number;
	/**
	 * The chain ID of the network where the transaction is sent.
	 */
	chainId: string;
};

/**
 * Represents the result of executing a function in the AAVE v3 rewards wrapper.
 */
export type AAVEv3RewardsExecuteFunctionResult = {
	/**
	 * Optional response from simulating asset changes.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * Optional response from broadcasting the raw transaction.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * Optional message providing additional information about the execution result.
	 */
	message?: string;
	/**
	 * Optional flag indicating whether the function execution was successful.
	 */
	success?: boolean;
	/**
	 * Optional user operation identifier.
	 */
	user_op?: string;
	/**
	 * Optional transaction data.
	 */
	data?: Transaction;
	/**
	 * The parameters passed to the executed function.
	 */
	params: Array<unknown>;
	/**
	 * The name of the executed function.
	 */
	function: string;
	/**
	 * The transaction details of the executed function.
	 */
	transaction: AAVEv3RewardsTransaction;
};

/**
 * Represents the structure of the API response for AAVE v3 rewards.
 */
export type AAVEv3RewardsAPIResponse_AAVEv3RewardsExecuteFunctionResult_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: AAVEv3RewardsExecuteFunctionResult;
};

/**
 * Interface representing the input body for AAVE v3 rewards.
 */
export type AAVEv3RewardsInputBody = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * The data to be sent with the transaction.
	 */
	data?: string;
	/**
	 * The value of the transaction.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The transaction nonce.
	 */
	nonce?: string;
	/**
	 * Whether to simulate the transaction.
	 */
	simulate?: boolean;
	/**
	 * The gas limit for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Flag to indicate if the transaction is a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Flag to indicate if the transaction is from an externally owned account.
	 */
	EOA?: boolean;
	/**
	 * The address of the contract.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Flag to indicate if the transaction should be broadcasted.
	 */
	broadcast?: boolean;
	/**
	 * Flag to indicate if the nonce should always be incremented.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount of tokens.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The list of asset addresses.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user address.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
	/**
	 * The reward address.
	 */
	reward?: string;
};

export type BigNumber = unknown;

/**
 * Interface representing the reward information for a token.
 */
export type RewardInfo = {
	/**
	 * The symbol of the reward token.
	 */
	rewardTokenSymbol: string;
	/**
	 * The address of the reward token.
	 */
	rewardTokenAddress: string;
	/**
	 * The address of the reward oracle.
	 */
	rewardOracleAddress: string;
	/**
	 * The emission rate of the reward token per second.
	 */
	emissionPerSecond: BigNumber;
	/**
	 * The timestamp of the last update to the incentives.
	 */
	incentivesLastUpdateTimestamp: BigNumber;
	/**
	 * The index of the token incentives.
	 */
	tokenIncentivesIndex: BigNumber;
	/**
	 * The timestamp when the emission ends.
	 */
	emissionEndTimestamp: BigNumber;
	/**
	 * The price feed of the reward token.
	 */
	rewardPriceFeed: BigNumber;
	/**
	 * The number of decimals of the reward token.
	 */
	rewardTokenDecimals: number;
	/**
	 * The precision of the reward token.
	 */
	precision: number;
	/**
	 * The number of decimals of the price feed.
	 */
	priceFeedDecimals: number;
};

/**
 * Interface representing the incentive data for a token.
 */
export type IncentiveData = {
	/**
	 * The address of the token.
	 */
	tokenAddress: string;
	/**
	 * The address of the incentive controller.
	 */
	incentiveControllerAddress: string;
	/**
	 * An array of reward information objects.
	 */
	rewardsTokenInformation: Array<RewardInfo>;
};

/**
 * Interface representing the aggregated reserve incentive data.
 */
export type AggregatedReserveIncentiveData = {
	/**
	 * The address of the underlying asset.
	 */
	underlyingAsset: string;
	/**
	 * The incentive data for the aToken.
	 */
	aIncentiveData: IncentiveData;
	/**
	 * The incentive data for the variable debt token.
	 */
	vIncentiveData: IncentiveData;
	/**
	 * The incentive data for the stable debt token.
	 */
	sIncentiveData: IncentiveData;
};

/**
 * Interface representing the reward information for a user.
 */
export type UserRewardInfo = {
	/**
	 * The symbol of the reward token.
	 */
	rewardTokenSymbol: string;
	/**
	 * The address of the reward oracle.
	 */
	rewardOracleAddress: string;
	/**
	 * The address of the reward token.
	 */
	rewardTokenAddress: string;
	/**
	 * The amount of unclaimed rewards for the user.
	 */
	userUnclaimedRewards: BigNumber;
	/**
	 * The user's index for token incentives.
	 */
	tokenIncentivesUserIndex: BigNumber;
	/**
	 * The price feed of the reward.
	 */
	rewardPriceFeed: BigNumber;
	/**
	 * The number of decimals for the price feed.
	 */
	priceFeedDecimals: number;
	/**
	 * The number of decimals for the reward token.
	 */
	rewardTokenDecimals: number;
};

/**
 * Represents the incentive data for a user.
 */
export type UserIncentiveData = {
	/**
	 * The address of the token.
	 */
	tokenAddress: string;
	/**
	 * The address of the incentive controller.
	 */
	incentiveControllerAddress: string;
	/**
	 * An array of user rewards information.
	 */
	userRewardsInformation: Array<UserRewardInfo>;
};

/**
 * Interface representing the incentive data for a user's reserve.
 */
export type UserReserveIncentiveData = {
	/**
	 * The underlying asset associated with the reserve.
	 */
	underlyingAsset: string;
	/**
	 * Incentive data for the user's aToken.
	 */
	aTokenIncentivesUserData: UserIncentiveData;
	/**
	 * Incentive data for the user's vToken.
	 */
	vTokenIncentivesUserData: UserIncentiveData;
	/**
	 * Incentive data for the user's sToken.
	 */
	sTokenIncentivesUserData: UserIncentiveData;
};

/**
 * Interface representing the full reserves incentive data.
 */
export type FullReservesIncentiveData = {
	/**
	 * The aggregated reserve incentive data.
	 */
	reservesIncentiveData: Array<AggregatedReserveIncentiveData>;
	/**
	 * The user reserve incentive data.
	 */
	userReserveIncentiveData: Array<UserReserveIncentiveData>;
};

/**
 * Represents the structure of the API response from the AAVE v3 UI Incentive Data Provider.
 */
export type AAVEv3UiIncentiveDataProviderAPIResponse_FullReservesIncentiveData_ =
	{
		/**
		 * Indicates whether the API request was successful.
		 */
		success: boolean;
		/**
		 * A message providing additional information about the API response.
		 */
		message: string;
		/**
		 * The data returned by the API, if any.
		 */
		data?: FullReservesIncentiveData;
	};

/**
 * Represents the structure of the API response from the AAVE v3 UI Incentive Data Provider.
 */
export type AAVEv3UiIncentiveDataProviderAPIResponse_AggregatedReserveIncentiveData_Array_ =
	{
		/**
		 * Indicates whether the API request was successful.
		 */
		success: boolean;
		/**
		 * A message providing additional information about the API response.
		 */
		message: string;
		/**
		 * The data returned by the API, if any.
		 */
		data?: Array<AggregatedReserveIncentiveData>;
	};

/**
 * Represents the structure of the API response from the AAVE v3 UI Incentive Data Provider.
 */
export type AAVEv3UiIncentiveDataProviderAPIResponse_UserReserveIncentiveData_Array_ =
	{
		/**
		 * Indicates whether the API request was successful.
		 */
		success: boolean;
		/**
		 * A message providing additional information about the API response.
		 */
		message: string;
		/**
		 * The data returned by the API, if any.
		 */
		data?: Array<UserReserveIncentiveData>;
	};

/**
 * Interface representing the API response from AAVE v3 UI Pool Data Provider.
 */
export type AAVEv3UiPoolDataProviderAPIResponse_string_ = {
	/**
	 * Indicates whether the API call was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API call.
	 */
	message: string;
	/**
	 * The data returned by the API call, if any.
	 */
	data?: string;
};

/**
 * Interface representing the aggregated reserve data for a specific asset.
 */
export type AggregatedReserveData = {
	/**
	 * The address of the underlying asset.
	 */
	underlyingAsset: string;
	/**
	 * The name of the asset.
	 */
	name: string;
	/**
	 * The symbol of the asset.
	 */
	symbol: string;
	/**
	 * The number of decimals of the asset.
	 */
	decimals: BigNumber;
	/**
	 * The loan-to-value ratio used as collateral.
	 */
	baseLTVasCollateral: BigNumber;
	/**
	 * The threshold at which the asset will be liquidated.
	 */
	reserveLiquidationThreshold: BigNumber;
	/**
	 * The bonus applied upon liquidation.
	 */
	reserveLiquidationBonus: BigNumber;
	/**
	 * The reserve factor of the asset.
	 */
	reserveFactor: BigNumber;
	/**
	 * Indicates if the asset can be used as collateral.
	 */
	usageAsCollateralEnabled: boolean;
	/**
	 * Indicates if borrowing is enabled for the asset.
	 */
	borrowingEnabled: boolean;
	/**
	 * Indicates if stable borrow rate is enabled for the asset.
	 */
	stableBorrowRateEnabled: boolean;
	/**
	 * Indicates if the asset is active.
	 */
	isActive: boolean;
	/**
	 * Indicates if the asset is frozen.
	 */
	isFrozen: boolean;
	/**
	 * The liquidity index of the asset.
	 */
	liquidityIndex: BigNumber;
	/**
	 * The variable borrow index of the asset.
	 */
	variableBorrowIndex: BigNumber;
	/**
	 * The liquidity rate of the asset.
	 */
	liquidityRate: BigNumber;
	/**
	 * The variable borrow rate of the asset.
	 */
	variableBorrowRate: BigNumber;
	/**
	 * The stable borrow rate of the asset.
	 */
	stableBorrowRate: BigNumber;
	/**
	 * The timestamp of the last update.
	 */
	lastUpdateTimestamp: number;
	/**
	 * The address of the aToken associated with the asset.
	 */
	aTokenAddress: string;
	/**
	 * The address of the stable debt token associated with the asset.
	 */
	stableDebtTokenAddress: string;
	/**
	 * The address of the variable debt token associated with the asset.
	 */
	variableDebtTokenAddress: string;
	/**
	 * The address of the interest rate strategy contract.
	 */
	interestRateStrategyAddress: string;
	/**
	 * The available liquidity of the asset.
	 */
	availableLiquidity: BigNumber;
	/**
	 * The total principal stable debt of the asset.
	 */
	totalPrincipalStableDebt: BigNumber;
	/**
	 * The average stable rate of the asset.
	 */
	averageStableRate: BigNumber;
	/**
	 * The timestamp of the last update of the stable debt.
	 */
	stableDebtLastUpdateTimestamp: BigNumber;
	/**
	 * The total scaled variable debt of the asset.
	 */
	totalScaledVariableDebt: BigNumber;
	/**
	 * The price of the asset in the market reference currency.
	 */
	priceInMarketReferenceCurrency: BigNumber;
	/**
	 * The first slope of the variable rate.
	 */
	variableRateSlope1: BigNumber;
	/**
	 * The second slope of the variable rate.
	 */
	variableRateSlope2: BigNumber;
	/**
	 * The first slope of the stable rate.
	 */
	stableRateSlope1: BigNumber;
	/**
	 * The second slope of the stable rate.
	 */
	stableRateSlope2: BigNumber;
};

/**
 * Interface representing the base currency information.
 */
export type BaseCurrencyInfo = {
	/**
	 * The unit of the market reference currency.
	 */
	marketReferenceCurrencyUnit: BigNumber;
	/**
	 * The price of the market reference currency in USD.
	 */
	marketReferenceCurrencyPriceInUsd: BigNumber;
	/**
	 * The price of the network base token in USD.
	 */
	networkBaseTokenPriceInUsd: BigNumber;
	/**
	 * The number of decimals of the network base token price.
	 */
	networkBaseTokenPriceDecimals: number;
};

/**
 * Interface representing the reserves data.
 */
export type ReservesData = {
	/**
	 * The aggregated reserve data.
	 */
	aggregatedReserveData: Array<AggregatedReserveData>;
	/**
	 * The base currency information.
	 */
	baseCurrencyInfo: BaseCurrencyInfo;
};

/**
 * Interface representing the API response from AAVE v3 UI Pool Data Provider.
 */
export type AAVEv3UiPoolDataProviderAPIResponse_ReservesData_ = {
	/**
	 * Indicates whether the API call was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API call.
	 */
	message: string;
	/**
	 * The data returned by the API call, if any.
	 */
	data?: ReservesData;
};

/**
 * Interface representing the API response from AAVE v3 UI Pool Data Provider.
 */
export type AAVEv3UiPoolDataProviderAPIResponse_string_Array_ = {
	/**
	 * Indicates whether the API call was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API call.
	 */
	message: string;
	/**
	 * The data returned by the API call, if any.
	 */
	data?: Array<string>;
};

/**
 * Interface representing the data of a user's reserve in the Aave V3 protocol.
 */
export type UserReserveData = {
	/**
	 * The address of the underlying asset.
	 */
	underlyingAsset: string;
	/**
	 * The scaled balance of the aToken.
	 */
	scaledATokenBalance: BigNumber;
	/**
	 * Indicates if the asset is being used as collateral by the user.
	 */
	usageAsCollateralEnabledOnUser: boolean;
	/**
	 * The stable borrow rate of the user.
	 */
	stableBorrowRate: BigNumber;
	/**
	 * The scaled variable debt of the user.
	 */
	scaledVariableDebt: BigNumber;
	/**
	 * The principal stable debt of the user.
	 */
	principalStableDebt: BigNumber;
	/**
	 * The timestamp of the last update to the stable borrow rate.
	 */
	stableBorrowLastUpdateTimestamp: BigNumber;
};

/**
 * Interface representing the API response from AAVE v3 UI Pool Data Provider.
 */
export type AAVEv3UiPoolDataProviderAPIResponse_UserReserveData_Array_ = {
	/**
	 * Indicates whether the API call was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API call.
	 */
	message: string;
	/**
	 * The data returned by the API call, if any.
	 */
	data?: Array<UserReserveData>;
};

/**
 * Represents the response from the AAVE v3 Wallet Balance Provider API.
 */
export type AAVEv3WalletBalanceProviderAPIResponse_string_ = {
	/**
	 * Indicates whether the API call was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API call.
	 */
	message: string;
	/**
	 * The data returned by the API call, if any.
	 */
	data?: string;
};

/**
 * Represents the response from the AAVE v3 Wallet Balance Provider API.
 */
export type AAVEv3WalletBalanceProviderAPIResponse_string_Array_ = {
	/**
	 * Indicates whether the API call was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API call.
	 */
	message: string;
	/**
	 * The data returned by the API call, if any.
	 */
	data?: Array<string>;
};

/**
 * Represents the response from the AAVE v3 Wallet Balance Provider API.
 */
export type AAVEv3WalletBalanceProviderAPIResponse__tokens_string_Array__balances_string_Array____ =
	{
		/**
		 * Indicates whether the API call was successful.
		 */
		success: boolean;
		/**
		 * A message providing additional information about the API call.
		 */
		message: string;
		/**
		 * The data returned by the API call, if any.
		 */
		data?: {
			balances: Array<string>;
			tokens: Array<string>;
		};
	};

/**
 * Represents the data associated with an account.
 */
export type AccountData = {
	/**
	 * An optional array of keys associated with the account.
	 */
	keys?: Array<string>;
	/**
	 * An optional address of the account.
	 */
	address?: string;
	/**
	 * An optional private key of the account.
	 */
	private_key?: string;
	/**
	 * An optional public key of the account.
	 */
	public_key?: string;
};

/**
 * Represents the response structure for an account.
 */
export type AccountResponse = {
	/**
	 * Optional array of keys associated with the account.
	 */
	keys?: Array<string>;
	/**
	 * Optional address of the account.
	 */
	address?: string;
	/**
	 * Optional private key of the account.
	 */
	private_key?: string;
	/**
	 * Optional public key of the account.
	 */
	public_key?: string;
	/**
	 * Data associated with the account.
	 */
	data: AccountData;
};

/**
 * Represents the body of an input request.
 */
export type InputBody = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * The data to be sent.
	 */
	data?: string;
	/**
	 * The value to be sent.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce?: string;
	/**
	 * Whether to simulate the transaction.
	 */
	simulate?: boolean;
	/**
	 * The gas for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Whether to perform a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Whether the transaction is from an externally owned account.
	 */
	EOA?: boolean;
	/**
	 * The contract address.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Whether to broadcast the transaction.
	 */
	broadcast?: boolean;
	/**
	 * Whether to always increment the nonce.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount involved in the transaction.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
};

/**
 * Interface representing the response from the Account API.
 * Extends the BaseAPIResponse to include additional data specific to account responses.
 */
export type AccountAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The account response data.
	 */
	data?: AccountResponse;
};

/**
 * Interface representing the input required to create an account.
 */
export type CreateAccountInput = {
	/**
	 * An optional private key for the account.
	 */
	private_key?: string;
};

export type NonceResponse = {
	/**
	 * The nonce of the account.
	 */
	nonce: number;
};

/**
 * Represents the response from the API that includes a nonce.
 * Extends the BaseAPIResponse to include additional data specific to nonce responses.
 */
export type NonceAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The data associated with the nonce response.
	 */
	data?: NonceResponse;
};

export type BalanceResponse = {
	/**
	 * The balance of the account.
	 */
	balance: string;
};

/**
 * Represents the response from the Balance API.
 * Extends the BaseAPIResponse to include additional data specific to balance information.
 */
export type BalanceAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The data associated with the balance response.
	 */
	data?: BalanceResponse;
};

/**
 * Interface representing the response from the Transaction API.
 * Extends the BaseAPIResponse interface.
 */
export type TransactionAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The hash of the transaction.
	 */
	transaction_hash?: unknown;
	/**
	 * The signed transaction data.
	 */
	signedTx?: unknown;
	/**
	 * The transaction data.
	 */
	data?: Transaction;
	/**
	 * The response from broadcasting the raw transaction.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * Additional transaction information.
	 */
	transaction?: unknown;
	/**
	 * The function name associated with the transaction.
	 */
	function?: string;
	/**
	 * The parameters associated with the transaction function.
	 */
	params?: Array<unknown>;
};

/**
 * Interface representing the response from the Sign Message API.
 * Extends the BaseAPIResponse interface.
 */
export type SignMessageAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The transaction data.
	 */
	data?: TransactionData;
};

/**
 * Represents a message to be signed.
 */
export type SignMessage = {
	/**
	 * The ID of the blockchain network.
	 */
	chain_id?: string;
	/**
	 * The name associated with the message.
	 */
	name?: string;
	/**
	 * The data to be signed.
	 */
	data: string;
	/**
	 * The encoding format of the data.
	 */
	encoding?: string;
	/**
	 * Indicates if the message includes a header.
	 */
	header?: boolean;
	/**
	 * Indicates if the message includes a signature type.
	 */
	signtype?: boolean;
};

/**
 * Interface representing the response from the Export Account API.
 * Extends the BaseAPIResponse interface.
 */
export type ExportAccountAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The data object containing account details.
	 */
	data?: {
		public_key: string;
		private_key: string;
		address: string;
	};
};

/**
 * Interface representing the structure for signing typed data.
 */
export type SignTypedData = {
	/**
	 * The optional chain ID associated with the data.
	 */
	chain_id?: string;
	/**
	 * The data to be signed.
	 */
	data: string;
};

/**
 * Interface representing the input required for deploying a contract.
 */
export type DeployInput = {
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The ABI (Application Binary Interface) of the contract.
	 */
	abi: string;
	/**
	 * The bytecode of the contract.
	 */
	bytecode: string;
	/**
	 * Optional constructor arguments for the contract.
	 */
	constructor_args?: string;
};

export type BroadCastRawTransactionAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The data associated with the broadcast raw transaction response.
	 */
	data?: BroadCastRawTransactionResponse;
};

/**
 * Represents the input required to broadcast a transaction.
 */
export type BroadcastInput = {
	/**
	 * The chain ID of the blockchain network.
	 */
	chainId: string;
	/**
	 * The signed transaction to be broadcasted.
	 */
	rawTransaction: string;
};

/**
 * Interface representing the output of an ABI encoding operation.
 * Extends the BaseAPIResponse interface.
 */
export type AbiEncodeOutput = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * Optional data object containing the encoded string.
	 */
	data?: {
		/**
		 * The encoded string resulting from the ABI encoding operation.
		 */
		encoded: string;
	};
};

/**
 * Interface representing the input required for ABI encoding.
 */
export type AbiEncodeInput = {
	/**
	 * The ABI (Application Binary Interface) definition.
	 */
	abi: unknown;
	/**
	 * The name of the function to be called.
	 */
	functionName: string;
	/**
	 * The parameters to be passed to the function.
	 */
	params: Array<unknown>;
};

/**
 * Represents the input data required for Bitcoin transactions.
 */
export type BitcoinInput = {
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * The private key of the account.
	 */
	private_key?: string;
};

/**
 * Represents the output of a Bitcoin transaction.
 */
export type BitcoinTransactionOutput = {
	/**
	 * The signed transaction.
	 */
	signedTx?: string;
	/**
	 * The transaction hash.
	 */
	transaction_hash?: string;
};

/**
 * Represents the output of an SRC20 inscription.
 */
export type SRC20InscriptionOutput = {
	/**
	 * the json string of the inscription transaction
	 */
	transactions: string;
};

/**
 * Represents an output of a BRC20 transaction.
 */
export type BRC20TransactionOutput = {
	/**
	 * The signed transaction.
	 */
	transaction: string;
};

/**
 * Represents an unsigned Partially Signed Bitcoin Transaction (PSBT) output.
 */
export type UnsignedPSBTOutput = {
	/**
	 * The unsigned PSBT.
	 */
	psbt_hex: string;
};

export type BitcoinAPIResponse = {
	data?:
		| BitcoinTransactionOutput
		| SRC20InscriptionOutput
		| BRC20TransactionOutput
		| UnsignedPSBTOutput;
	success: boolean;
	message: string;
};

/**
 * Represents an input for a Bitcoin transaction.
 */
export type BitcoinTransactionInput = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * The amount to be sent.
	 */
	value?: number;
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * Indicates whether to compress the public key.
	 */
	compress?: boolean;
};

export type SRC20InscriptionInput = {
	/**
	 * The network on which the transaction is taking place.
	 */
	network: string;
	/**
	 * The operation type of the transaction.
	 */
	prev_outputs: string;
	/**
	 * The ticker symbol of the token involved in the transaction.
	 */
	inscription_data: string;
	/**
	 * The amount of tokens involved in the transaction.
	 */
	commit_fee_rate: number;
	/**
	 * The transaction ID of the input being used.
	 */
	reveal_out_value: number;
	/**
	 * The output index of the input being used.
	 */
	address: string;
};

/**
 * Represents an input for a BRC20 transaction.
 */
export type BRC20TransactionInput = {
	/**
	 * The network on which the transaction is taking place.
	 */
	network: string;
	/**
	 * The operation type of the transaction.
	 */
	op: string;
	/**
	 * The ticker symbol of the token involved in the transaction.
	 */
	tick: string;
	/**
	 * The amount of tokens involved in the transaction.
	 */
	amt: string;
	/**
	 * The transaction ID of the input being used.
	 */
	input_txid: string;
	/**
	 * The output index of the input being used.
	 */
	input_vout: number;
	/**
	 * The amount of the input being used.
	 */
	input_amount: string;
	/**
	 * The address to which the output is being sent.
	 */
	output_address: string;
	/**
	 * The address to which any change is being sent.
	 */
	change_address: string;
};

/**
 * Represents an unsigned Partially Signed Bitcoin Transaction (PSBT) input.
 */
export type UnsignedPSBTInput = {
	/**
	 * The network for the transaction, either 'mainnet' or 'testnet'.
	 */
	network: string;
	/**
	 * The inputs for the transaction as a JSON string of an array of TxInput objects.
	 */
	inputs: string;
	/**
	 * The outputs for the transaction as a JSON string of an array of TxOutput objects.
	 */
	outputs: string;
};

export type BitcoinCashAPIResponse_AccountResponse_ = {
	success: boolean;
	message: string;
	data?: AccountResponse;
};

/**
 * Represents the input data required for Bitcoin Cash transactions.
 */
export type BitcoinCashInput = {
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * The private key of the account.
	 */
	private_key?: string;
};

/**
 * Represents the output of a Bitcoin Cash transaction.
 */
export type BitcoinCashTransactionOutput = {
	/**
	 * The signed transaction.
	 */
	signedTx?: string;
	/**
	 * The transaction hash.
	 */
	transaction_hash?: string;
};

export type BitcoinCashAPIResponse_BitcoinCashTransactionOutput_ = {
	success: boolean;
	message: string;
	data?: BitcoinCashTransactionOutput;
};

/**
 * Represents an input for a Bitcoin Cash transaction.
 */
export type BitcoinCashTransactionInput = {
	/**
	 * The recipient address of the transaction.
	 */
	to?: string;
	/**
	 * The amount to be sent.
	 */
	value?: number;
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * Indicates whether to compress the public key.
	 */
	compress?: boolean;
};

export type BitcoinCashAPIResponse__signed_tx_string__ = {
	success: boolean;
	message: string;
	data?: {
		signed_tx: string;
	};
};

export type BitcoinCashAPIResponse__psbt_hex_string__ = {
	success: boolean;
	message: string;
	data?: {
		psbt_hex: string;
	};
};

export type BitcoinCashAPIResponse__signed_psbt_hex_string__ = {
	success: boolean;
	message: string;
	data?: {
		signed_psbt_hex: string;
	};
};

/**
 * Represents the response from the Chart Analysis API.
 */
export type ChartAnalysisAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The analysis data returned by the API.
	 */
	data?: string;
};

/**
 * Represents the definition of a component.
 */
export type ComponentDefinition = {
	/**
	 * The unique identifier of the component.
	 */
	id: string;
	/**
	 * The name of the component.
	 */
	name: string;
	/**
	 * A brief description of the component.
	 */
	description: string;
	/**
	 * The XML tag associated with the component.
	 */
	xmlTag: string;
	/**
	 * The version of the component.
	 */
	version: string;
	/**
	 * The code of the component.
	 */
	code: string;
	/**
	 * The date and time when the component was created.
	 * Optional.
	 */
	created_at?: string;
	/**
	 * The date and time when the component was last updated.
	 * Optional.
	 */
	updated_at?: string;
	/**
	 * Indicates whether the component is active.
	 * Optional.
	 */
	is_active?: boolean;
};

/**
 * Represents the structure of an API response for a component.
 */
export type ComponentAPIResponse_ComponentDefinition_Array_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: Array<ComponentDefinition>;
};

/**
 * Represents the structure of an API response for a component.
 */
export type ComponentAPIResponse_ComponentDefinition_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: ComponentDefinition;
};

/**
 * From T, pick a set of properties whose keys are in the union K
 */
export type Pick_ComponentDefinition_Exclude_keyofComponentDefinition_id__ = {
	/**
	 * The name of the component.
	 */
	name: string;
	/**
	 * A brief description of the component.
	 */
	description: string;
	/**
	 * The XML tag associated with the component.
	 */
	xmlTag: string;
	/**
	 * The version of the component.
	 */
	version: string;
	/**
	 * The code of the component.
	 */
	code: string;
	/**
	 * The date and time when the component was created.
	 * Optional.
	 */
	created_at?: string;
	/**
	 * The date and time when the component was last updated.
	 * Optional.
	 */
	updated_at?: string;
	/**
	 * Indicates whether the component is active.
	 * Optional.
	 */
	is_active?: boolean;
};

/**
 * Construct a type with the properties of T except for those in type K.
 */
export type Omit_ComponentDefinition_id_ =
	Pick_ComponentDefinition_Exclude_keyofComponentDefinition_id__;

/**
 * Make all properties in T optional
 */
export type Partial_ComponentDefinition_ = {
	/**
	 * The unique identifier of the component.
	 */
	id?: string;
	/**
	 * The name of the component.
	 */
	name?: string;
	/**
	 * A brief description of the component.
	 */
	description?: string;
	/**
	 * The XML tag associated with the component.
	 */
	xmlTag?: string;
	/**
	 * The version of the component.
	 */
	version?: string;
	/**
	 * The code of the component.
	 */
	code?: string;
	/**
	 * The date and time when the component was created.
	 * Optional.
	 */
	created_at?: string;
	/**
	 * The date and time when the component was last updated.
	 * Optional.
	 */
	updated_at?: string;
	/**
	 * Indicates whether the component is active.
	 * Optional.
	 */
	is_active?: boolean;
};

/**
 * Represents a component match that extends the ComponentDefinition interface.
 */
export type ComponentMatch = {
	/**
	 * The unique identifier of the component.
	 */
	id: string;
	/**
	 * The name of the component.
	 */
	name: string;
	/**
	 * A brief description of the component.
	 */
	description: string;
	/**
	 * The XML tag associated with the component.
	 */
	xmlTag: string;
	/**
	 * The version of the component.
	 */
	version: string;
	/**
	 * The code of the component.
	 */
	code: string;
	/**
	 * The date and time when the component was created.
	 * Optional.
	 */
	created_at?: string;
	/**
	 * The date and time when the component was last updated.
	 * Optional.
	 */
	updated_at?: string;
	/**
	 * Indicates whether the component is active.
	 * Optional.
	 */
	is_active?: boolean;
	/**
	 * The similarity score of the component match.
	 */
	similarity: number;
};

/**
 * Represents the structure of an API response for a component.
 */
export type ComponentAPIResponse_ComponentMatch_Array_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: Array<ComponentMatch>;
};

/**
 * Represents the structure of an API response for a component.
 */
export type ComponentAPIResponse_void_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: unknown;
};

/**
 * Represents the structure of an API response for a component.
 */
export type ComponentAPIResponse_Partial_ComponentDefinition__Array_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: Array<Partial_ComponentDefinition_>;
};

/**
 * Represents a Cosmos account with an address and a public key.
 */
export type CosmosAccount = {
	/**
	 * Account name.
	 */
	address: string;
	/**
	 * Public key of the account.
	 */
	pubkey: string;
};

/**
 * Represents the response structure for a list of Cosmos accounts.
 */
export type CosmosAccountListResponse = {
	/**
	 * The list of Cosmos accounts.
	 */
	data: {
		keys: Array<CosmosAccount>;
	};
};

/**
 * Represents the response from the Cosmos Account List API.
 */
export type CosmosAccountListAPIResponse = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: CosmosAccountListResponse;
};

/**
 * Represents the response structure for a Cosmos account.
 */
export type CosmosAccountResponse = {
	/**
	 * The Cosmos account address.
	 */
	data: {
		address: string;
	};
};

/**
 * Represents the response from the Cosmos Account API.
 */
export type CosmosAccountAPIResponse = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: CosmosAccountResponse;
};

/**
 * Represents the base structure of a response from the Cosmos API.
 */
export type BaseCosmosAPIResponse = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
};

/**
 * Represents the response of a Cosmos transaction.
 */
export type CosmosTransactionResponse = {
	/**
	 * The signed transaction.
	 */
	signedTx: string;
	/**
	 * The transaction hash.
	 */
	txHash: string;
};

/**
 * Represents the response from the Cosmos Transaction API.
 */
export type CosmosTransactionAPIResponse = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: CosmosTransactionResponse;
};

/**
 * Represents the input required for a Cosmos blockchain transfer.
 */
export type CosmosTransferInput = {
	/**
	 * The address from which the transfer is initiated.
	 */
	fromAddress: string;
	/**
	 * The address to which the transfer is sent.
	 */
	toAddress: string;
	/**
	 * The amount of tokens to be transferred.
	 */
	amount: string;
	/**
	 * The denomination of the tokens to be transferred.
	 */
	denom: string;
	/**
	 * The ID of the blockchain chain.
	 */
	chainId: string;
	/**
	 * The sequence number of the account initiating the transfer.
	 */
	sequence: number;
	/**
	 * The account number of the account initiating the transfer.
	 */
	accountNumber: number;
	/**
	 * The denomination of the fee to be paid for the transfer.
	 */
	feeDenom: string;
	/**
	 * The amount of the fee to be paid for the transfer.
	 */
	feeAmount: string;
	/**
	 * The gas limit for the transfer transaction.
	 */
	gasLimit: number;
	/**
	 * An optional memo to include with the transfer.
	 */
	memo: string;
	/**
	 * The timeout height for the transfer transaction.
	 */
	timeoutHeight: number;
};

/**
 * Represents the response containing a signed message from the Cosmos blockchain.
 */
export type CosmosSignedMessageResponse = {
	/**
	 * The signed message.
	 */
	signedMessage: string;
};

/**
 * Represents the response from the Cosmos Signed Message API.
 */
export type CosmosSignedMessageAPIResponse = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: CosmosSignedMessageResponse;
};

/**
 * Represents the input required for signing a message in the Cosmos ecosystem.
 */
export type CosmosSignMessageInput = {
	/**
	 * The address of the account signing the message.
	 */
	message: string;
};

/**
 * Interface representing the input required for an IBC (Inter-Blockchain Communication) transfer in the Cosmos network.
 * Extends the `CosmosTransferInput` interface to include additional properties specific to IBC transfers.
 */
export type CosmosIBCTransferInput = {
	/**
	 * The address from which the transfer is initiated.
	 */
	fromAddress: string;
	/**
	 * The address to which the transfer is sent.
	 */
	toAddress: string;
	/**
	 * The amount of tokens to be transferred.
	 */
	amount: string;
	/**
	 * The denomination of the tokens to be transferred.
	 */
	denom: string;
	/**
	 * The ID of the blockchain chain.
	 */
	chainId: string;
	/**
	 * The sequence number of the account initiating the transfer.
	 */
	sequence: number;
	/**
	 * The account number of the account initiating the transfer.
	 */
	accountNumber: number;
	/**
	 * The denomination of the fee to be paid for the transfer.
	 */
	feeDenom: string;
	/**
	 * The amount of the fee to be paid for the transfer.
	 */
	feeAmount: string;
	/**
	 * The gas limit for the transfer transaction.
	 */
	gasLimit: number;
	/**
	 * An optional memo to include with the transfer.
	 */
	memo: string;
	/**
	 * The timeout height for the transfer transaction.
	 */
	timeoutHeight: number;
	/**
	 * The source port for the IBC transfer.
	 */
	sourcePort: string;
	/**
	 * The source channel for the IBC transfer.
	 */
	sourceChannel: string;
	/**
	 * The timeout timestamp for the IBC transfer, specified in nanoseconds.
	 */
	timeoutTimestamp: number;
};

/**
 * Interface representing the response from the Wallet Balance API.
 */
export type WalletBalanceAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The wallet balance data.
	 */
	data?: Array<unknown>;
};

export type EvmAddressJSON = string;

export type BigNumberJSON = string;

export type EvmInternalTransactionJSON = {
	transaction_hash: string;
	block_number: string;
	block_hash: string;
	type: string;
	from: string;
	to: string;
	value: string;
	gas: string;
	gas_used: string;
	input: string;
	output: string;
};

export enum EvmETransactionCategoryJSON {
	SEND = "send",
	RECEIVE = "receive",
	TOKEN_SEND = "token send",
	TOKEN_RECEIVE = "token receive",
	NFT_SEND = "nft send",
	NFT_RECEIVE = "nft receive",
	TOKEN_SWAP = "token swap",
	DEPOSIT = "deposit",
	WITHDRAW = "withdraw",
	NFT_PURCHASE = "nft purchase",
	NFT_SALE = "nft sale",
	AIRDROP = "airdrop",
	MINT = "mint",
	BURN = "burn",
	BORROW = "borrow",
	CONTRACT_INTERACTION = "contract interaction",
}

export type EvmContractTokenDetailsJSON = {
	address: EvmAddressJSON;
	address_label?: string;
	token_name: string;
	token_logo: string;
	token_symbol: string;
};

export type EvmContractSpenderDetailsJSON = {
	address: EvmAddressJSON;
	address_label?: string;
	name?: string;
	symbol?: string;
	logo?: string;
};

export type EvmCommonContractDataJSON = {
	value: string;
	value_formatted?: string;
	token: EvmContractTokenDetailsJSON;
	spender: EvmContractSpenderDetailsJSON;
};

export type EvmResolveContractInteractionResponseJSON = {
	approvals?: Array<EvmCommonContractDataJSON>;
	revokes?: Array<EvmCommonContractDataJSON>;
	approvalsAll?: Array<EvmCommonContractDataJSON>;
	revokesAll?: Array<EvmCommonContractDataJSON>;
};

export type EvmNormalizedMetadataAttributeValueJSON = {
	[key: string]: unknown;
};

export type EvmNormalizedMetadataAttributeJSON = {
	trait_type?: string;
	value?: EvmNormalizedMetadataAttributeValueJSON;
	display_type?: string;
	max_value?: number;
	trait_count?: number;
	order?: number;
};

export type EvmNormalizedMetadataJSON = {
	name?: string;
	description?: string;
	image?: string;
	external_link?: string;
	animation_url?: string;
	attributes?: Array<EvmNormalizedMetadataAttributeJSON>;
};

export type EvmWalletHistoryNftTransferJSON = {
	token_address: EvmAddressJSON;
	token_id: string;
	from_address_entity?: string;
	from_address_entity_logo?: string;
	from_address: EvmAddressJSON;
	from_address_label?: string;
	to_address_entity?: string;
	to_address_entity_logo?: string;
	to_address?: EvmAddressJSON;
	to_address_label?: string;
	value: string;
	amount: string;
	contract_type: string;
	transaction_type: string;
	log_index: number;
	operator?: string;
	possible_spam: boolean;
	verified_collection?: boolean;
	direction: string;
	collection_logo?: string;
	collection_banner_image?: string;
	normalized_metadata?: EvmNormalizedMetadataJSON;
};

export type EvmWalletHistoryErc20TransferJSON = {
	token_name: string;
	token_symbol: string;
	token_logo: string;
	token_decimals: string;
	address: EvmAddressJSON;
	block_timestamp?: string;
	to_address_entity?: string;
	to_address_entity_logo?: string;
	to_address?: EvmAddressJSON;
	to_address_label?: string;
	from_address_entity?: string;
	from_address_entity_logo?: string;
	from_address: EvmAddressJSON;
	from_address_label?: string;
	value: string;
	value_formatted: string;
	log_index: number;
	possible_spam: boolean;
	verified_contract: boolean;
};

export type EvmNativeTransferJSON = {
	from_address_entity?: string;
	from_address_entity_logo?: string;
	from_address: EvmAddressJSON;
	from_address_label?: string;
	to_address_entity?: string;
	to_address_entity_logo?: string;
	to_address?: EvmAddressJSON;
	to_address_label?: string;
	value: string;
	value_formatted: string;
	direction?: string;
	internal_transaction: boolean;
	token_symbol: string;
	token_logo: string;
};

export type EvmDecodedEventParamsItemJSON = {
	name?: string;
	value?: string;
	type?: string;
};

export type EvmDecodedEventJSON = {
	signature?: string;
	label?: string;
	type?: string;
	params?: Array<EvmDecodedEventParamsItemJSON>;
};

export type EvmLogVerboseJSON = {
	log_index: string;
	transaction_hash: string;
	transaction_index: string;
	address: EvmAddressJSON;
	data: string;
	topic0: string;
	topic1?: string;
	topic2?: string;
	topic3?: string;
	block_timestamp: string;
	block_number: BigNumberJSON;
	block_hash: string;
	decoded_event: EvmDecodedEventJSON;
};

export type EvmWalletHistoryTransactionJSON = {
	hash: string;
	nonce: string;
	transaction_index: string;
	from_address_entity?: string;
	from_address_entity_logo?: string;
	from_address: EvmAddressJSON;
	from_address_label?: string;
	to_address_entity?: string;
	to_address_entity_logo?: string;
	to_address?: EvmAddressJSON;
	to_address_label?: string;
	value: string;
	gas?: string;
	gas_price: string;
	input?: string;
	receipt_cumulative_gas_used: string;
	receipt_gas_used: string;
	receipt_contract_address?: string;
	receipt_status: string;
	transaction_fee?: string;
	block_timestamp: string;
	block_number: BigNumberJSON;
	block_hash: string;
	internal_transactions?: Array<EvmInternalTransactionJSON>;
	category: EvmETransactionCategoryJSON;
	contract_interactions?: EvmResolveContractInteractionResponseJSON;
	possible_spam?: boolean;
	method_label?: string;
	summary: string;
	nft_transfers: Array<EvmWalletHistoryNftTransferJSON>;
	erc20_transfers: Array<EvmWalletHistoryErc20TransferJSON>;
	native_transfers: Array<EvmNativeTransferJSON>;
	logs?: Array<EvmLogVerboseJSON>;
};

/**
 * Interface representing the response from the Wallet History API.
 */
export type WalletHistoryAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The wallet history data.
	 */
	data?: Array<EvmWalletHistoryTransactionJSON>;
};

export type SuccessResponse$9 = Array<{
	verified_contract?: boolean;
	possible_spam: boolean;
	created_at: string;
	validated?: number;
	block_number?: string;
	thumbnail?: string | null;
	logo_hash?: string | null;
	logo?: string | null;
	decimals: string;
	symbol: string;
	name: string;
	address_label?: string | null;
	address: string;
}>;

export type GetTokenMetadataJSONResponse = SuccessResponse$9;

/**
 * Represents the response from the Token Metadata API.
 */
export type TokenMetadataAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The token metadata information.
	 */
	data?: SuccessResponse$9;
};

/**
 * Interface representing the response from the NFTs API.
 */
export type NFTsAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The NFT data.
	 */
	data?: Array<unknown>;
};

/**
 * Interface representing the response from the Portfolio API.
 * Extends the BaseAPIResponse interface.
 */
export type PortfolioAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The data object containing portfolio details.
	 */
	data?: {
		/**
		 * The URL to poll for updates.
		 */
		pollUrl?: string;
		/**
		 * The job ID associated with the request.
		 */
		jobId?: string;
		/**
		 * The status of the response.
		 */
		status?: string;
		/**
		 * The reason for the response status.
		 */
		reason?: string;
		/**
		 * The total number of NFTs.
		 */
		totalNFTs?: number;
		/**
		 * The total number of tokens.
		 */
		totalTokens?: number;
		/**
		 * The number of items per page.
		 */
		pageSize?: number;
		/**
		 * The current page number.
		 */
		page?: number;
		/**
		 * An array of NFT balances.
		 */
		nft_balances?: Array<unknown>;
		/**
		 * An array of token balances.
		 */
		token_balances?: Array<unknown>;
		/**
		 * The address associated with the portfolio.
		 */
		address?: string;
	};
};

/**
 * Represents the input required for DogeCoin transactions.
 */
export type DogeCoinInput = {
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * The private key of the account.
	 */
	private_key?: string;
};

/**
 * Represents the output of a DogeCoin transaction.
 */
export type DogeCoinTransactionOutput = {
	/**
	 * The signed transaction.
	 */
	signedTx?: string;
	/**
	 * The transaction hash.
	 */
	transaction_hash?: string;
};

/**
 * Interface representing the response from the DogeCoin API.
 * Extends the BaseAPIResponse interface.
 */
export type DogeCoinAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The data associated with the DogeCoin transaction output.
	 */
	data?: DogeCoinTransactionOutput;
};

/**
 * Represents an input for a DogeCoin transaction.
 */
export type DogeCoinTransactionInput = {
	/**
	 * The recipient address of the transaction.
	 */
	to?: string;
	/**
	 * The amount to be sent.
	 */
	value?: number;
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * Indicates whether to compress the public key.
	 */
	compress?: boolean;
};

/**
 * Represents the response from an ENS (Ethereum Name Service) resolve operation.
 */
export type EnsResolveResponse = {
	/**
	 * The address associated with the domain.
	 */
	address: string;
};

/**
 * Interface representing the response from the ENS resolve API.
 * Extends the BaseAPIResponse interface.
 */
export type EnsResolveAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The ENS resolve response data.
	 */
	data?: EnsResolveResponse;
};

/**
 * Represents the input required to resolve an ENS (Ethereum Name Service) domain.
 */
export type EnsResolveInput = {
	/**
	 * The domain to be resolved.
	 */
	domain: string;
	/**
	 * The chain ID of the blockchain network.
	 */
	chain_id: string;
};

/**
 * Represents the response from an ENS reverse resolution.
 */
export type ENSReverseResolveResponse = {
	/**
	 * The domain name resolved from the ENS reverse lookup.
	 */
	domain: string;
};

export type ENSReverseResolveAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The ENS reverse resolve response data.
	 */
	data?: ENSReverseResolveResponse;
};

/**
 * Interface representing the input required for ENS reverse resolution.
 */
export type ENSReverseResolveInput = {
	/**
	 * The blockchain address to be reverse resolved.
	 */
	address: string;
	/**
	 * The identifier of the blockchain network.
	 */
	chain_id: string;
};

/**
 * Represents the input data required for EOS operations.
 */
export type EosInput = {
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * The private key of the account.
	 */
	private_key?: string;
};

/**
 * Represents the output of an EOS transaction.
 */
export type EosTransactionOutput = {
	/**
	 * The signed transaction.
	 */
	signedTx?: string;
	/**
	 * The transaction hash.
	 */
	transaction_hash?: string;
};

export type EosAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The data associated with the Eos response.
	 */
	data?: EosTransactionOutput;
};

/**
 * Represents an input for an EOS transaction.
 */
export type EosTransactionInput = {
	/**
	 * The recipient address of the transaction.
	 */
	to?: string;
	/**
	 * The amount to be sent.
	 */
	value?: number;
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * Indicates whether to compress the public key.
	 */
	compress?: boolean;
};

/**
 * Interface representing a request for ERC-1155 token operations.
 */
export type Erc1155Request = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * The data to be sent.
	 */
	data?: string;
	/**
	 * The value to be sent.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce?: string;
	/**
	 * Whether to simulate the transaction.
	 */
	simulate?: boolean;
	/**
	 * The gas for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Whether to perform a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Whether the transaction is from an externally owned account.
	 */
	EOA?: boolean;
	/**
	 * The contract address.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * Optional. A comma-separated list of token IDs.
	 */
	token_ids?: string;
	/**
	 * Optional. Indicates whether the tokens are approved.
	 */
	approved?: boolean;
	/**
	 * Whether to broadcast the transaction.
	 */
	broadcast?: boolean;
	/**
	 * Whether to always increment the nonce.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount involved in the transaction.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
};

/**
 * Interface representing the structure of an API response for ERC20 operations.
 */
export type ERC20APIResponse_number_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * Optional data payload returned by the API.
	 */
	data?: number;
};

/**
 * Interface representing the structure of an API response for ERC20 operations.
 */
export type ERC20APIResponse_string_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * Optional data payload returned by the API.
	 */
	data?: string;
};

/**
 * Represents an ERC-20 token transaction.
 */
export type ERC20Transaction = {
	/**
	 * The data payload of the transaction.
	 */
	data: string;
	/**
	 * The value to be transferred in the transaction, in wei.
	 */
	value: string;
	/**
	 * The recipient address of the transaction.
	 */
	to: string;
	/**
	 * The sender address of the transaction.
	 */
	from: string;
	/**
	 * The gas price for the transaction, in wei.
	 * Optional.
	 */
	gasPrice?: string;
	/**
	 * The gas limit for the transaction.
	 * Optional.
	 */
	gasLimit?: string;
	/**
	 * The maximum priority fee per gas for EIP-1559 transactions, in wei.
	 * Optional.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The maximum fee per gas for EIP-1559 transactions, in wei.
	 * Optional.
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce: number;
	/**
	 * The type of the transaction.
	 * Optional.
	 */
	type?: number;
	/**
	 * The chain ID of the network where the transaction is sent.
	 */
	chainId: string;
};

/**
 * Represents the result of executing an ERC20 function.
 */
export type ERC20ExecuteFunctionResult = {
	/**
	 * Optional response from simulating asset changes.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * Optional response indicating whether the transaction was broadcasted.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * Optional message providing additional information about the execution.
	 */
	message?: string;
	/**
	 * Indicates whether the execution was successful.
	 */
	success?: boolean;
	/**
	 * Optional user operation identifier.
	 */
	user_op?: string;
	/**
	 * Optional transaction data.
	 */
	data?: Transaction;
	/**
	 * The parameters passed to the function.
	 */
	params: Array<unknown>;
	/**
	 * The name of the executed function
	 */
	function: string;
	/**
	 * The transaction details.
	 */
	transaction: ERC20Transaction;
};

/**
 * Interface representing the structure of an API response for ERC20 operations.
 */
export type ERC20APIResponse_ERC20ExecuteFunctionResult_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * Optional data payload returned by the API.
	 */
	data?: ERC20ExecuteFunctionResult;
};

/**
 * Interface representing the input body for an ERC20 transaction.
 */
export type ERC20InputBody = {
	/**
	 * The recipient address of the ERC20 token transfer.
	 */
	to?: string;
	/**
	 * Additional data to include in the transaction.
	 */
	data?: string;
	/**
	 * The value of the transaction in wei.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce to use for the transaction.
	 */
	nonce?: string;
	/**
	 * Flag to indicate if the transaction should be simulated.
	 */
	simulate?: boolean;
	/**
	 * The gas limit for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Flag to indicate if the transaction should be a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Flag to indicate if the transaction is from an externally owned account.
	 */
	EOA?: boolean;
	/**
	 * The address of the ERC20 contract.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Flag to indicate if the transaction should be broadcasted.
	 */
	broadcast?: boolean;
	/**
	 * Flag to indicate if the nonce should always be incremented.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount of ERC20 tokens to transfer.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
};

/**
 * Interface representing the structure of the API response for ERC4626.
 */
export type ERC4626APIResponse = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * Provides a message related to the API response.
	 */
	message: string;
	/**
	 * Optional data returned by the API.
	 */
	data?: unknown;
};

/**
 * Interface representing the structure of the response from the ERC721 API.
 */
export type ERC721APIResponse = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * Optional data returned by the API.
	 */
	data?: unknown;
};

/**
 * Represents the financial and general information of a company.
 */
export type CompanyFacts = {
	/**
	 * The stock ticker symbol of the company.
	 */
	ticker: string;
	/**
	 * The name of the company.
	 */
	name: string;
	/**
	 * The Central Index Key (CIK) assigned by the SEC.
	 */
	cik: string;
	/**
	 * The market capitalization of the company.
	 */
	market_cap: number;
	/**
	 * The weighted average number of shares outstanding.
	 */
	weighted_average_shares: number;
	/**
	 * The number of employees working for the company.
	 */
	number_of_employees: number;
	/**
	 * The Standard Industrial Classification (SIC) code of the company.
	 */
	sic_code: string;
	/**
	 * The description of the SIC code.
	 */
	sic_description: string;
	/**
	 * The website URL of the company.
	 */
	website_url: string;
	/**
	 * The date when the company was listed.
	 */
	listing_date: string;
	/**
	 * Indicates whether the company is currently active.
	 */
	is_active: boolean;
};

/**
 * Represents the response of the `getCompanyFacts` endpoint.
 */
export type CompanyFactsAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The company facts data.
	 */
	data?: CompanyFacts;
};

/**
 * Represents an income statement for a financial entity.
 */
export type IncomeStatement = {
	/**
	 * The ticker symbol of the company.
	 */
	ticker: string;
	/**
	 * The calendar date of the income statement.
	 */
	calendar_date: string;
	/**
	 * The reporting period of the income statement.
	 */
	report_period: string;
	/**
	 * The period type of the income statement, which can be "quarterly", "ttm" (trailing twelve months), or "annual".
	 */
	period: "quarterly" | "ttm" | "annual";
	/**
	 * The currency in which the financials are reported.
	 */
	currency: string;
	/**
	 * The total revenue generated by the company.
	 */
	revenue: number;
	/**
	 * The cost associated with generating the revenue.
	 */
	cost_of_revenue: number;
	/**
	 * The gross profit, calculated as revenue minus cost of revenue.
	 */
	gross_profit: number;
	/**
	 * The total operating expenses of the company.
	 */
	operating_expense: number;
	/**
	 * The expenses related to selling, general, and administrative activities.
	 */
	selling_general_and_administrative_expenses: number;
	/**
	 * The expenses related to research and development activities.
	 */
	research_and_development: number;
	/**
	 * The operating income, calculated as gross profit minus operating expenses.
	 */
	operating_income: number;
	/**
	 * The interest expense incurred by the company.
	 */
	interest_expense: number;
	/**
	 * Earnings before interest and taxes.
	 */
	ebit: number;
	/**
	 * The income tax expense incurred by the company.
	 */
	income_tax_expense: number;
	/**
	 * The net income from discontinued operations.
	 */
	net_income_discontinued_operations: number;
	/**
	 * The net income attributable to non-controlling interests.
	 */
	net_income_non_controlling_interests: number;
	/**
	 * The net income of the company.
	 */
	net_income: number;
	/**
	 * The net income attributable to common stockholders.
	 */
	net_income_common_stock: number;
	/**
	 * The impact of preferred dividends on net income.
	 */
	preferred_dividends_impact: number;
	/**
	 * The consolidated income of the company.
	 */
	consolidated_income: number;
	/**
	 * The earnings per share of the company.
	 */
	earnings_per_share: number;
	/**
	 * The diluted earnings per share of the company.
	 */
	earnings_per_share_diluted: number;
	/**
	 * The dividends paid per common share.
	 */
	dividends_per_common_share: number;
	/**
	 * The weighted average number of shares outstanding.
	 */
	weighted_average_shares: number;
	/**
	 * The weighted average number of diluted shares outstanding.
	 */
	weighted_average_shares_diluted: number;
};

/**
 * The period type of the income statement, which can be "quarterly", "ttm" (trailing twelve months), or "annual".
 */
export enum period {
	QUARTERLY = "quarterly",
	TTM = "ttm",
	ANNUAL = "annual",
}

/**
 * Represents the response of the `getIncomeStatements` endpoint.
 */
export type IncomeStatementsAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The income statement data.
	 */
	data?: Array<IncomeStatement>;
};

/**
 * Represents a balance sheet for a financial entity.
 */
export type BalanceSheet = {
	/**
	 * The stock ticker symbol of the company.
	 */
	ticker: string;
	/**
	 * The date of the balance sheet in the calendar.
	 */
	calendar_date: string;
	/**
	 * The reporting period of the balance sheet.
	 */
	report_period: string;
	/**
	 * The period type of the balance sheet, which can be "quarterly", "ttm" (trailing twelve months), or "annual".
	 */
	period: "quarterly" | "ttm" | "annual";
	/**
	 * The currency in which the balance sheet values are denominated.
	 */
	currency: string;
	/**
	 * The total assets of the company.
	 */
	total_assets: number;
	/**
	 * The current assets of the company.
	 */
	current_assets: number;
	/**
	 * The cash and cash equivalents of the company.
	 */
	cash_and_equivalents: number;
	/**
	 * The inventory of the company.
	 */
	inventory: number;
	/**
	 * The current investments of the company.
	 */
	current_investments: number;
	/**
	 * The trade and non-trade receivables of the company.
	 */
	trade_and_non_trade_receivables: number;
	/**
	 * The non-current assets of the company.
	 */
	non_current_assets: number;
	/**
	 * The property, plant, and equipment of the company.
	 */
	property_plant_and_equipment: number;
	/**
	 * The goodwill and intangible assets of the company.
	 */
	goodwill_and_intangible_assets: number;
	/**
	 * The total investments of the company.
	 */
	investments: number;
	/**
	 * The non-current investments of the company.
	 */
	non_current_investments: number;
	/**
	 * The number of outstanding shares of the company.
	 */
	outstanding_shares: number;
	/**
	 * The tax assets of the company.
	 */
	tax_assets: number;
	/**
	 * The total liabilities of the company.
	 */
	total_liabilities: number;
	/**
	 * The current liabilities of the company.
	 */
	current_liabilities: number;
	/**
	 * The current debt of the company.
	 */
	current_debt: number;
	/**
	 * The trade and non-trade payables of the company.
	 */
	trade_and_non_trade_payables: number;
	/**
	 * The deferred revenue of the company.
	 */
	deferred_revenue: number;
	/**
	 * The deposit liabilities of the company.
	 */
	deposit_liabilities: number;
	/**
	 * The non-current liabilities of the company.
	 */
	non_current_liabilities: number;
	/**
	 * The non-current debt of the company.
	 */
	non_current_debt: number;
	/**
	 * The tax liabilities of the company.
	 */
	tax_liabilities: number;
	/**
	 * The shareholders' equity of the company.
	 */
	shareholders_equity: number;
	/**
	 * The retained earnings of the company.
	 */
	retained_earnings: number;
	/**
	 * The accumulated other comprehensive income of the company.
	 */
	accumulated_other_comprehensive_income: number;
	/**
	 * The total debt of the company.
	 */
	total_debt: number;
};

/**
 * Represents the response of the `getBalanceSheets` endpoint.
 */
export type BalanceSheetsAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The balance sheet data.
	 */
	data?: Array<BalanceSheet>;
};

/**
 * Represents a cash flow statement for a specific financial period.
 */
export type CashFlowStatement = {
	/**
	 * The ticker symbol of the company.
	 */
	ticker: string;
	/**
	 * The calendar date of the cash flow statement.
	 */
	calendar_date: string;
	/**
	 * The reporting period of the cash flow statement.
	 */
	report_period: string;
	/**
	 * The period type of the cash flow statement.
	 * Can be "quarterly", "ttm" (trailing twelve months), or "annual".
	 */
	period: "quarterly" | "ttm" | "annual";
	/**
	 * The currency in which the cash flow amounts are denominated.
	 */
	currency: string;
	/**
	 * Net cash flow from operating activities.
	 */
	net_cash_flow_from_operations: number;
	/**
	 * Depreciation and amortization expenses.
	 */
	depreciation_and_amortization: number;
	/**
	 * Share-based compensation expenses.
	 */
	share_based_compensation: number;
	/**
	 * Net cash flow from investing activities.
	 */
	net_cash_flow_from_investing: number;
	/**
	 * Capital expenditures.
	 */
	capital_expenditure: number;
	/**
	 * Cash flow from business acquisitions and disposals.
	 */
	business_acquisitions_and_disposals: number;
	/**
	 * Cash flow from investment acquisitions and disposals.
	 */
	investment_acquisitions_and_disposals: number;
	/**
	 * Net cash flow from financing activities.
	 */
	net_cash_flow_from_financing: number;
	/**
	 * Cash flow from issuance or repayment of debt securities.
	 */
	issuance_or_repayment_of_debt_securities: number;
	/**
	 * Cash flow from issuance or purchase of equity shares.
	 */
	issuance_or_purchase_of_equity_shares: number;
	/**
	 * Cash flow from dividends and other cash distributions.
	 */
	dividends_and_other_cash_distributions: number;
	/**
	 * Change in cash and cash equivalents.
	 */
	change_in_cash_and_equivalents: number;
	/**
	 * Effect of exchange rate changes on cash and cash equivalents.
	 */
	effect_of_exchange_rate_changes: number;
};

/**
 * Represents the response of the `getCashFlowStatements` endpoint.
 */
export type CashFlowStatementsAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The cash flow statement data.
	 */
	data?: Array<CashFlowStatement>;
};

/**
 * Represents an item of segmented revenue data.
 */
export type SegmentedRevenueItem = {
	/**
	 * The axis of the revenue data.
	 */
	axis: string;
	/**
	 * The key associated with the revenue data.
	 */
	key: string;
	/**
	 * The value of the revenue data.
	 */
	value: number;
	/**
	 * The segment of the revenue data.
	 */
	segment: string;
	/**
	 * The start period of the revenue data (optional).
	 */
	start_period?: string;
	/**
	 * The end period of the revenue data (optional).
	 */
	end_period?: string;
};

/**
 * Represents the segmented revenue data for a specific company.
 */
export type SegmentedRevenue = {
	/**
	 * The stock ticker symbol of the company.
	 */
	ticker: string;
	/**
	 * The reporting period for the revenue data.
	 */
	report_period: string;
	/**
	 * The type of reporting period, either annual or quarterly.
	 */
	period: "annual" | "quarterly";
	/**
	 * An array of segmented revenue items.
	 */
	items: Array<SegmentedRevenueItem>;
};

/**
 * The type of reporting period, either annual or quarterly.
 */
export enum period2 {
	ANNUAL = "annual",
	QUARTERLY = "quarterly",
}

/**
 * Represents the response of the `getSegmentedRevenues` endpoint.
 */
export type SegmentedRevenuesAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The segmented revenue data
	 */
	data?: Array<SegmentedRevenue>;
};

/**
 * Represents a collection of financial statements.
 */
export type AllFinancials = {
	/**
	 * An array of income statements.
	 */
	income_statements: Array<IncomeStatement>;
	/**
	 * An array of balance sheets.
	 */
	balance_sheets: Array<BalanceSheet>;
	/**
	 * An array of cash flow statements.
	 */
	cash_flow_statements: Array<CashFlowStatement>;
};

/**
 * Represents the response of the `getAllFinancials` endpoint.
 */
export type AllFinancialsAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The all financials data.
	 */
	data?: AllFinancials;
};

/**
 * Represents the response of the `getAvailableTickers` endpoint.
 */
export type AvailableTickersAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The available tickers.
	 */
	data?: Array<string>;
};

/**
 * Represents an insider transaction for a financial dataset.
 */
export type InsiderTransaction = {
	/**
	 * The ticker symbol of the company.
	 */
	ticker: string;
	/**
	 * The issuer of the security.
	 */
	issuer: string;
	/**
	 * The name of the insider.
	 */
	name: string;
	/**
	 * The title of the insider.
	 */
	title: string;
	/**
	 * Indicates if the insider is a board director.
	 */
	is_board_director: boolean;
	/**
	 * The date of the transaction.
	 */
	transaction_date: string;
	/**
	 * The number of shares involved in the transaction.
	 */
	transaction_shares: number;
	/**
	 * The price per share at which the transaction occurred.
	 */
	transaction_price_per_share: number;
	/**
	 * The total value of the transaction.
	 */
	transaction_value: number;
	/**
	 * The number of shares owned before the transaction.
	 */
	shares_owned_before_transaction: number;
	/**
	 * The number of shares owned after the transaction.
	 */
	shares_owned_after_transaction: number;
	/**
	 * The title of the security involved in the transaction.
	 */
	security_title: string;
	/**
	 * The date the transaction was filed.
	 */
	filing_date: string;
};

/**
 * Represents the response of the `getInsiderTransactions` endpoint.
 */
export type InsiderTransactionsAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The insider transaction data.
	 */
	data?: Array<InsiderTransaction>;
};

/**
 * Represents an item in an options chain.
 */
export type OptionsChainItem = {
	/**
	 * The ticker symbol of the underlying asset.
	 */
	ticker: string;
	/**
	 * The type of option, either "Call" or "Put".
	 */
	type: "Call" | "Put";
	/**
	 * The strike price of the option.
	 */
	strike_price: number;
	/**
	 * The expiration date of the option in ISO 8601 format.
	 */
	expiration_date: string;
	/**
	 * The number of shares per contract.
	 */
	shares_per_contract: number;
	/**
	 * The trading volume of the option.
	 */
	volume: number;
	/**
	 * The open interest of the option.
	 */
	open_interest: number;
	/**
	 * The bid price of the option.
	 */
	bid_price: number;
	/**
	 * The bid size of the option.
	 */
	bid_size: number;
	/**
	 * The ask price of the option.
	 */
	ask_price: number;
	/**
	 * The ask size of the option.
	 */
	ask_size: number;
	/**
	 * The last traded price of the option.
	 */
	last_trade_price: number;
	/**
	 * The size of the last trade.
	 */
	last_trade_size: number;
	/**
	 * The time of the last trade in ISO 8601 format.
	 */
	last_trade_time: string;
	/**
	 * The nanoseconds part of the last trade time.
	 */
	last_trade_time_nanoseconds: number;
};

/**
 * The type of option, either "Call" or "Put".
 */
export enum type {
	CALL = "Call",
	PUT = "Put",
}

/**
 * Represents the response of the `getOptionsChain` endpoint.
 */
export type OptionsChainAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The options chain data.
	 */
	data?: Array<OptionsChainItem>;
};

/**
 * Represents the price data for a financial instrument.
 */
export type PriceData = {
	/**
	 * The opening price of the instrument.
	 */
	open: number;
	/**
	 * The closing price of the instrument.
	 */
	close: number;
	/**
	 * The highest price of the instrument during the time period.
	 */
	high: number;
	/**
	 * The lowest price of the instrument during the time period.
	 */
	low: number;
	/**
	 * The trading volume of the instrument.
	 */
	volume: number;
	/**
	 * The time of the data point in ISO 8601 format.
	 */
	time: string;
	/**
	 * The time of the data point in milliseconds since the Unix epoch.
	 */
	time_milliseconds: number;
};

/**
 * Represents the response of the `getPrices` endpoint.
 */
export type PricesAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The price data.
	 */
	data?: Array<PriceData>;
};

/**
 * Represents the price interval for historical price data.
 */
export enum PriceInterval {
	SECOND = "second",
	MINUTE = "minute",
	DAY = "day",
	WEEK = "week",
	MONTH = "month",
	QUARTER = "quarter",
	YEAR = "year",
}

/**
 * Represents a financial dataset search result.
 */
export type SearchResult = {
	/**
	 * The stock ticker symbol of the company.
	 */
	ticker: string;
	/**
	 * The reporting period of the financial data.
	 */
	report_period: string;
	/**
	 * The currency in which the financial data is denominated.
	 */
	period: string;
	/**
	 * The currency in which the financial data is denominated.
	 */
	currency: string;
	[key: string]: (unknown | string) | undefined;
};

/**
 * Represents the response of the `searchFinancials` endpoint.
 */
export type SearchFinancialsAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The search results.
	 */
	data?: Array<SearchResult>;
};

/**
 * Represents a filter to be applied in a search query.
 */
export type SearchFilter = {
	/**
	 * The name of the field to filter on.
	 */
	field: string;
	/**
	 * The operator to use for comparison.
	 */
	operator: "eq" | "gt" | "gte" | "lt" | "lte";
	/**
	 * The value to compare the field against.
	 */
	value: number;
};

/**
 * The operator to use for comparison.
 */
export enum operator {
	EQ = "eq",
	GT = "gt",
	GTE = "gte",
	LT = "lt",
	LTE = "lte",
}

/**
 * Represents a request to search for financial datasets.
 */
export type SearchRequest = {
	/**
	 * The reporting period for the financial data.
	 */
	period?: "annual" | "quarterly" | "ttm";
	/**
	 * The maximum number of results to return.
	 */
	limit?: number;
	/**
	 * The field by which to order the results.
	 */
	order_by?: "ticker" | "-ticker" | "report_period" | "-report_period";
	/**
	 * The currency in which the financial data is denominated.
	 */
	currency?: "USD" | "EUR" | "GBP" | "JPY" | "CHF" | "AUD" | "CAD" | "SEK";
	/**
	 * An array of filters to apply to the search.
	 */
	filters: Array<SearchFilter>;
};

/**
 * The field by which to order the results.
 */
export enum order_by {
	TICKER = "ticker",
	_TICKER = "-ticker",
	REPORT_PERIOD = "report_period",
	_REPORT_PERIOD = "-report_period",
}

/**
 * The currency in which the financial data is denominated.
 */
export enum currency {
	USD = "USD",
	EUR = "EUR",
	GBP = "GBP",
	JPY = "JPY",
	CHF = "CHF",
	AUD = "AUD",
	CAD = "CAD",
	SEK = "SEK",
}

/**
 * Represents a snapshot of a financial instrument's price at a specific point in time.
 */
export type PriceSnapshot = {
	/**
	 * The stock ticker symbol of the company.
	 */
	price: number;
	/**
	 * The percentage change in price for the day.
	 */
	ticker: string;
	/**
	 * The absolute change in price for the day.
	 */
	day_change: number;
	/**
	 * The percentage change in price for the day.
	 */
	day_change_percent: number;
	/**
	 * The opening price of the instrument.
	 */
	time: string;
	/**
	 * The time of the snapshot in milliseconds since the Unix epoch.
	 */
	time_nanoseconds: number;
};

/**
 * Represents the response of the `getPriceSnapshot` endpoint.
 */
export type PriceSnapshotAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The price snapshot data.
	 */
	data?: PriceSnapshot;
};

/**
 * Represents the result of a search for line items in financial datasets.
 */
export type LineItemsSearchResult = {
	/**
	 * The stock ticker symbol.
	 */
	ticker: string;
	/**
	 * The reporting period of the financial data.
	 */
	report_period: string;
	/**
	 * The period for which the financial data is reported.
	 */
	period: string;
	/**
	 * The currency in which the financial data is denominated.
	 */
	currency: string;
	[key: string]: (unknown | string) | undefined;
};

/**
 * Represents the response of the `searchFinancials` endpoint.
 */
export type LineItemsSearchAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The search results.
	 */
	data?: Array<LineItemsSearchResult>;
};

/**
 * Construct a type with a set of properties K of type T
 */
export type Record_string_string_ = {
	[key: string]: unknown;
};

/**
 * Represents the structure of a response from the Jupiter API.
 */
export type JupiterAPIResponse_Record_string_string__ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * Optional data returned by the API. The type of this property is determined by the generic type parameter `T`.
	 */
	data?: Record_string_string_;
};

/**
 * Represents the structure of a response from the Jupiter API.
 */
export type JupiterAPIResponse_any_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * Optional data returned by the API. The type of this property is determined by the generic type parameter `T`.
	 */
	data?: unknown;
};

/**
 * Represents the structure of a response from the Jupiter API.
 */
export type JupiterAPIResponse_string_Array_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * Optional data returned by the API. The type of this property is determined by the generic type parameter `T`.
	 */
	data?: Array<string>;
};

/**
 * Represents the result of executing a function in the Jupiter system.
 */
export type JupiterExecuteFunctionResult = {
	/**
	 * The transaction object associated with the execution.
	 */
	transaction?: unknown;
	/**
	 * The name of the function that was executed.
	 */
	function: string;
	/**
	 * The parameters passed to the function.
	 */
	params: Array<unknown>;
	/**
	 * Additional data returned by the function execution.
	 */
	data?: unknown;
	/**
	 * Indicates whether the function execution was successful.
	 */
	success?: boolean;
	/**
	 * A message providing additional information about the execution result.
	 */
	message?: string;
	/**
	 * The Jupiter-specific data related to the execution.
	 */
	jupiter?: unknown;
	/**
	 * The hash of the transaction associated with the
	 */
	transactionHash?: string;
};

/**
 * Represents the structure of a response from the Jupiter API.
 */
export type JupiterAPIResponse_JupiterExecuteFunctionResult_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * Optional data returned by the API. The type of this property is determined by the generic type parameter `T`.
	 */
	data?: JupiterExecuteFunctionResult;
};

/**
 * From T, pick a set of properties whose keys are in the union K
 */
export type Pick_JupiterInputBody_Exclude_keyofJupiterInputBody_accountName__ =
	{
		/**
		 * The mint address of the input token.
		 */
		inputMint: string;
		/**
		 * The mint address of the output token.
		 */
		outputMint: string;
		/**
		 * The amount of input tokens to be exchanged.
		 */
		amount: number;
		/**
		 * The maximum allowable slippage for the transaction, expressed as a percentage.
		 * Optional.
		 */
		slippage?: number;
		/**
		 * The fee in basis points (bps) to be applied to the transaction.
		 * Optional.
		 */
		feeBps?: number;
		/**
		 * If true, the transaction will be simulated but not executed.
		 * Optional.
		 */
		dryrun?: boolean;
		/**
		 * If true, the transaction will be broadcast to the network.
		 * Optional.
		 */
		broadcast?: boolean;
	};

/**
 * Construct a type with the properties of T except for those in type K.
 */
export type Omit_JupiterInputBody_accountName_ =
	Pick_JupiterInputBody_Exclude_keyofJupiterInputBody_accountName__;

/**
 * Represents the structure of the API response for the Lending Pool.
 */
export type LendingPoolAPIResponse_number_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * Provides a message related to the API response.
	 */
	message: string;
	/**
	 * Contains the data returned by the API, if any.
	 */
	data?: number;
};

/**
 * Represents a transaction in the lending pool.
 */
export type LendingPoolTransaction = {
	/**
	 * The data payload of the transaction.
	 */
	data: string;
	/**
	 * The value being transferred in the transaction.
	 */
	value: string;
	/**
	 * The recipient address of the transaction.
	 */
	to: string;
	/**
	 * The sender address of the transaction.
	 */
	from: string;
	/**
	 * The gas price for the transaction (optional).
	 */
	gasPrice?: string;
	/**
	 * The gas limit for the transaction (optional).
	 */
	gasLimit?: string;
	/**
	 * The maximum priority fee per gas for the transaction (optional).
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The maximum fee per gas for the transaction (optional).
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce: number;
	/**
	 * The type of the transaction (optional).
	 */
	type?: number;
	/**
	 * The chain ID of the blockchain network.
	 */
	chainId: string;
};

/**
 * Represents the result of executing a function on the lending pool.
 */
export type LendingPoolExecuteFunctionResult = {
	/**
	 * Optional response from broadcasting the raw transaction.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * Optional message providing additional information about the execution result.
	 */
	message?: string;
	/**
	 * Optional flag indicating if the function execution was successful.
	 */
	success?: boolean;
	/**
	 * Optional user operation identifier.
	 */
	user_op?: string;
	/**
	 * Optional transaction data.
	 */
	data?: Transaction;
	/**
	 * The parameters passed to the executed function.
	 */
	params: Array<unknown>;
	/**
	 * The name of the executed function.
	 */
	function: string;
	/**
	 * Optional response from simulating asset changes.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * The transaction details of the executed function.
	 */
	transaction: LendingPoolTransaction;
};

/**
 * Represents the structure of the API response for the Lending Pool.
 */
export type LendingPoolAPIResponse_LendingPoolExecuteFunctionResult_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * Provides a message related to the API response.
	 */
	message: string;
	/**
	 * Contains the data returned by the API, if any.
	 */
	data?: LendingPoolExecuteFunctionResult;
};

/**
 * Interface representing the input body for LendingPool operations.
 * Extends the InputBody interface.
 */
export type LendingPoolInputBody = {
	/**
	 * The address to which the operation is directed.
	 */
	to?: string;
	/**
	 * Additional data for the operation.
	 */
	data?: string;
	/**
	 * The value involved in the operation.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce for the transaction
	 */
	nonce?: string;
	/**
	 * Flag indicating if the operation should be simulated.
	 */
	simulate?: boolean;
	/**
	 * The gas for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Flag indicating if the operation is a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Flag indicating if the operation is performed by an Externally Owned Account.
	 */
	EOA?: boolean;
	/**
	 * The contract address involved in the operation.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Flag indicating if the transaction should be broadcasted.
	 */
	broadcast?: boolean;
	/**
	 * Flag indicating if the nonce should always be incremented.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the operation.
	 */
	asset?: string;
	/**
	 * The amount involved in the operation.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the operation is performed.
	 */
	onBehalfOf?: string;
	/**
	 * The address of the receiver.
	 */
	receiverAddress?: string;
	/**
	 * Array of assets involved in the operation.
	 */
	assets?: Array<string>;
	/**
	 * Array of amounts involved in the operation.
	 */
	amounts?: Array<string>;
	/**
	 * Array of modes involved in the operation.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters for the operation.
	 */
	params?: string;
	/**
	 * The rate mode for the operation.
	 */
	rateMode?: number;
	/**
	 * Flag indicating if the asset should be used as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the operation.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Flag indicating if AToken should be received.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
};

/**
 * Represents the structure of the API response for the Lending Pool.
 */
export type LendingPoolAPIResponse_any_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * Provides a message related to the API response.
	 */
	message: string;
	/**
	 * Contains the data returned by the API, if any.
	 */
	data?: unknown;
};

/**
 * Represents the structure of the API response for the Lending Pool.
 */
export type LendingPoolAPIResponse_string_Array_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * Provides a message related to the API response.
	 */
	message: string;
	/**
	 * Contains the data returned by the API, if any.
	 */
	data?: Array<string>;
};

/**
 * Represents the structure of the API response for the Lending Pool.
 */
export type LendingPoolAPIResponse_string_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * Provides a message related to the API response.
	 */
	message: string;
	/**
	 * Contains the data returned by the API, if any.
	 */
	data?: string;
};

/**
 * Represents the structure of the API response for the Lending Pool.
 */
export type LendingPoolAPIResponse_boolean_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * Provides a message related to the API response.
	 */
	message: string;
	/**
	 * Contains the data returned by the API, if any.
	 */
	data?: boolean;
};

export type LeveragerAPIResponse_string_ = {
	success: boolean;
	message: string;
	data?: string;
};

export type LeveragerAPIResponse_boolean_ = {
	success: boolean;
	message: string;
	data?: boolean;
};

/**
 * Represents a transaction for the Leverager.
 */
export type LeveragerTransaction = {
	/**
	 * The data payload of the transaction.
	 */
	data: string;
	/**
	 * The value to be transferred in the transaction.
	 */
	value: string;
	/**
	 * The recipient address of the transaction.
	 */
	to: string;
	/**
	 * The sender address of the transaction.
	 */
	from: string;
	/**
	 * The gas price for the transaction (optional).
	 */
	gasPrice?: string;
	/**
	 * The gas limit for the transaction (optional).
	 */
	gasLimit?: string;
	/**
	 * The maximum priority fee per gas for the transaction (optional).
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The maximum fee per gas for the transaction (optional).
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce: number;
	/**
	 * The type of the transaction (optional).
	 */
	type?: number;
	/**
	 * The chain ID of the blockchain network.
	 */
	chainId: string;
};

export type LeveragerExecuteFunctionResult = {
	/**
	 * Optional response from simulating asset changes
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * Optional response from broadcasting the raw transaction
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * Optional message providing additional information about the execution
	 */
	message?: string;
	/**
	 * Optional flag indicating if the execution was successful
	 */
	success?: boolean;
	/**
	 * Optional user operation identifier
	 */
	user_op?: string;
	/**
	 * Optional transaction data
	 */
	data?: Transaction;
	/**
	 * The parameters passed to the function
	 */
	params: Array<unknown>;
	/**
	 * The name of the function that was executed
	 */
	function: string;
	/**
	 * The transaction associated with the
	 */
	transaction: LeveragerTransaction;
};

export type LeveragerAPIResponse_LeveragerExecuteFunctionResult_ = {
	success: boolean;
	message: string;
	data?: LeveragerExecuteFunctionResult;
};

/**
 * Represents the input body for the Leverager.
 */
export type LeveragerInputBody = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * Additional data for the transaction.
	 */
	data?: string;
	/**
	 * The value of the transaction.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce?: string;
	/**
	 * Indicates if the transaction should be simulated.
	 */
	simulate?: boolean;
	/**
	 * The gas amount for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Indicates if the transaction is a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Indicates if the transaction is from an externally owned account.
	 */
	EOA?: boolean;
	/**
	 * The contract address involved in the transaction.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Indicates if the transaction should be broadcasted.
	 */
	broadcast?: boolean;
	/**
	 * Indicates if the nonce should always be incremented
	 * for the transaction.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount involved in the transaction.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * An array of assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters for the transaction.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor required.
	 */
	minHealthFactor?: string;
	/**
	 * An array of premiums for the transaction.
	 */
	premiums?: Array<string>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user in the
	 * transaction.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit amount.
	 */
	initialDeposit?: string;
	/**
	 * The amount to be borrowed.
	 */
	borrowAmount?: string;
	/**
	 * An array of amounts corresponding to the assets.
	 */
	amouts?: Array<string>;
};

export type TokenDetails = {
	address: string;
	chainId: number;
	symbol: string;
	decimals: number;
	name: string;
	coinKey: string;
	logoURI: string;
	priceUSD: string;
};

export type Action = {
	fromChainId: number;
	fromAmount: string;
	fromToken: TokenDetails;
	fromAddress: string;
	toChainId: number;
	toToken: TokenDetails;
	toAddress: string;
	slippage: number;
};

export type TokenInfo = {
	address: string;
	symbol: string;
	name: string;
	decimals: number;
	logoURI?: string;
};

export type GasCost = {
	type: string;
	price: string;
	estimate: string;
	limit: string;
	amount: string;
	amountUSD: string;
	token: TokenInfo;
};

export type Token = {
	name: string;
	address: string;
	symbol: string;
	decimals: number;
	logoURI: string;
	chainId: number;
};

export type FeeCost = {
	name: string;
	percentage: number;
	token: Token;
	amount: number;
};

export type Estimate = {
	fromAmount: string;
	toAmount: string;
	toAmountMin: string;
	approvalAddress: string;
	gasCosts: Array<GasCost>;
	executionDuration: number;
	feeCosts?: Array<FeeCost>;
	fromAmountUSD: string;
	toAmountUSD: string;
};

export type Step = {
	id: string;
	type: string;
	tool: string;
	action: Action;
	estimate: Estimate;
};

export type Quote = {
	id: string;
	type: string;
	tool: string;
	action: Action;
	estimate: Estimate;
	includedSteps: Array<Step>;
	transactionRequest: TransactionRequest;
};

/**
 * Represents a standard API response.
 */
export type ApiResponse_Quote_ = {
	success: boolean;
	message: string;
	data?: Quote;
};

/**
 * Interface representing the structure of a post quote.
 */
export type PostQuote = {
	/**
	 * The quote object.
	 */
	quote: Quote;
	/**
	 * The input body.
	 */
	input: InputBody;
	/**
	 * The signed transaction.
	 */
	signed: unknown;
	/**
	 * The broadcasted transaction.
	 */
	broadcast: unknown;
};

/**
 * Represents a standard API response.
 */
export type ApiResponse_PostQuote_ = {
	success: boolean;
	message: string;
	data?: PostQuote;
};

export type TransactionStatus = {
	chainId: number;
	txHash: string;
	txLink: string;
	amount: string;
	token: TokenInfo;
	gasPrice: string;
	gasUsed: string;
};

export type StatusResponse = {
	sending: TransactionStatus;
	receiving: TransactionStatus;
	tool: string;
	status: string;
	substatus: string;
};

/**
 * Represents a standard API response.
 */
export type ApiResponse_StatusResponse_ = {
	success: boolean;
	message: string;
	data?: StatusResponse;
};

export type Chain = {
	key: string;
	chainType: "EVM" | "SOL";
	name: string;
	coin: string;
	id: number;
	mainnet: boolean;
	logoURI: string;
	tokenlistUrl: string;
	multicallAddress: string;
	metamask: {
		rpcUrls: Array<string>;
		nativeCurrency: {
			decimals: number;
			symbol: string;
			name: string;
		};
		chainName: string;
		blockExplorerUrls: Array<string>;
		chainId: string;
	};
	nativeToken: {
		priceUSD: string;
		logoURI: string;
		coinKey: string;
		name: string;
		decimals: number;
		symbol: string;
		chainId: number;
		address: string;
	};
};

export enum chainType {
	EVM = "EVM",
	SOL = "SOL",
}

export type ChainsResponse = {
	chains: Array<Chain>;
};

/**
 * Represents a standard API response.
 */
export type ApiResponse_ChainsResponse_ = {
	success: boolean;
	message: string;
	data?: ChainsResponse;
};

export type BridgeSupportedChain = {
	fromChainId: number;
	toChainId: number;
};

export type Bridge = {
	key: string;
	name: string;
	logoURI: string;
	supportedChains: Array<BridgeSupportedChain>;
};

export type Exchange = {
	key: string;
	name: string;
	logoURI: string;
	supportedChains: Array<number>;
};

export type ToolsResponse = {
	bridges: Array<Bridge>;
	exchanges: Array<Exchange>;
};

/**
 * Represents a standard API response.
 */
export type ApiResponse_ToolsResponse_ = {
	success: boolean;
	message: string;
	data?: ToolsResponse;
};

export type TokensResponse = {
	tokens: {
		[key: string]: Array<Token>;
	};
};

/**
 * Represents a standard API response.
 */
export type ApiResponse_TokensResponse_ = {
	success: boolean;
	message: string;
	data?: TokensResponse;
};

/**
 * Represents a standard API response.
 */
export type ApiResponse_TokenDetails_ = {
	success: boolean;
	message: string;
	data?: TokenDetails;
};

export type Connection = {
	fromChainId: number;
	toChainId: number;
	fromTokens: Array<Token>;
	toTokens: Array<Token>;
};

export type ConnectionsResponse = {
	connections: Array<Connection>;
};

/**
 * Represents a standard API response.
 */
export type ApiResponse_ConnectionsResponse_ = {
	success: boolean;
	message: string;
	data?: ConnectionsResponse;
};

/**
 * Interface representing token information by chain ID.
 */
export type TokenInfoByChainId = {
	[key: string]: Array<TokenInfo>;
};

/**
 * Represents a standard API response.
 */
export type ApiResponse_TokenInfoByChainId_ = {
	success: boolean;
	message: string;
	data?: TokenInfoByChainId;
};

/**
 * Represents the input data required for a Litecoin transaction.
 */
export type LitecoinInput = {
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * The private key of the account.
	 */
	private_key?: string;
};

/**
 * Represents the output of a Litecoin transaction.
 */
export type LitecoinTransactionOutput = {
	/**
	 * The signed transaction.
	 */
	signedTx?: string;
	/**
	 * The transaction hash.
	 */
	transaction_hash?: string;
};

export type LitecoinAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The data associated with the Litecoin response.
	 */
	data?: LitecoinTransactionOutput;
};

/**
 * Represents an input for a Litecoin transaction.
 */
export type LitecoinTransactionInput = {
	/**
	 * The recipient address of the transaction.
	 */
	to?: string;
	/**
	 * The amount to be sent.
	 */
	value?: number;
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * Indicates whether to compress the public key.
	 */
	compress?: boolean;
};

/**
 * Represents the response structure from the Lynex API.
 */
export type LynexAPIResponse = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * Optional data returned by the API, if any.
	 */
	data?: unknown;
};

export type LynexNFTAPIResponse_string_ = {
	success: boolean;
	message: string;
	data?: string;
};

export type LynexNFTAPIResponse_any_ = {
	success: boolean;
	message: string;
	data?: unknown;
};

/**
 * Represents a transaction for a Lynex NFT.
 */
export type LynexNFTTransaction = {
	/**
	 * The data payload of the transaction.
	 */
	data: string;
	/**
	 * The value to be transferred in the transaction.
	 */
	value: string;
	/**
	 * The recipient address of the transaction.
	 */
	to: string;
	/**
	 * The sender address of the transaction.
	 */
	from: string;
	/**
	 * The gas price for the transaction (optional).
	 */
	gasPrice?: string;
	/**
	 * The gas limit for the transaction (optional).
	 */
	gasLimit?: string;
	/**
	 * The maximum priority fee per gas for the transaction (optional).
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The maximum fee per gas for the transaction (optional).
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce: number;
	/**
	 * The type of the transaction (optional).
	 */
	type?: number;
	/**
	 * The chain ID of the blockchain network.
	 */
	chainId: string;
};

export type LynexNFTExecuteFunctionResult = {
	/**
	 * Optional response from simulating asset changes.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * Optional response from broadcasting the raw transaction.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * Optional message providing additional information about the execution.
	 */
	message?: string;
	/**
	 * Optional flag indicating whether the execution was successful.
	 */
	success?: boolean;
	/**
	 * Optional user operation identifier.
	 */
	user_op?: string;
	/**
	 * Optional additional transaction data.
	 */
	data?: Transaction;
	/**
	 * The parameters passed to the executed function.
	 */
	params: Array<unknown>;
	/**
	 * The name of the executed function.
	 */
	function: string;
	/**
	 * The transaction details of the executed function.
	 */
	transaction: LynexNFTTransaction;
};

export type LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_ = {
	success: boolean;
	message: string;
	data?: LynexNFTExecuteFunctionResult;
};

export type LynexNFTInputBody = {
	/**
	 * The recipient address
	 */
	to?: string;
	/**
	 * The data to be sent with the transaction
	 */
	data?: string;
	/**
	 * The value to be sent with the transaction
	 */
	value?: string;
	/**
	 * The gas limit for the transaction
	 */
	gasLimit?: string;
	/**
	 * The nonce for the transaction
	 */
	nonce?: string;
	/**
	 * Indicates if the transaction should be simulated
	 */
	simulate?: boolean;
	/**
	 * The gas limit for the transaction
	 */
	gas?: string;
	/**
	 * The gas price for the transaction
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Indicates if the transaction should be a dry run
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Indicates if the transaction is from an externally owned account
	 */
	EOA?: boolean;
	/**
	 * The contract address
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Indicates if the operator is approved
	 */
	approved?: boolean;
	/**
	 * Indicates if the transaction should be broadcasted
	 */
	broadcast?: boolean;
	/**
	 * Indicates if the nonce should always be incremented
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount to be transferred or locked
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
	/**
	 * The token ID
	 */
	tokenId?: string;
	/**
	 * The lock duration
	 */
	lockDuration?: string;
	/**
	 * Indicates if the lock is permanent
	 */
	permanent?: boolean;
	/**
	 * The delegatee address
	 */
	delegatee?: string;
	/**
	 * The split weights
	 */
	splitWeights?: Array<string>;
	/**
	 * The operator address
	 */
	operator?: string;
	/**
	 * The expiry time
	 */
	expiry?: string;
	/**
	 * The v parameter for the signature
	 */
	v?: string;
	/**
	 * The r parameter for the signature
	 */
	r?: string;
	/**
	 * The s parameter for the signature
	 */
	s?: string;
};

export type LynexNFTAPIResponse_boolean_ = {
	success: boolean;
	message: string;
	data?: boolean;
};

export type VestingPeriodData = {
	start: string;
	end: string;
};

export type LynexNFTAPIResponse_VestingPeriodData_ = {
	success: boolean;
	message: string;
	data?: VestingPeriodData;
};

export type LynexRouterAPIResponse_string_ = {
	success: boolean;
	message: string;
	data?: string;
};

export type LynexRouterAPIResponse__amountOut_string__stable_boolean__ = {
	success: boolean;
	message: string;
	data?: {
		stable: boolean;
		amountOut: string;
	};
};

export type LynexRouterAPIResponse_string_Array_ = {
	success: boolean;
	message: string;
	data?: Array<string>;
};

/**
 * Represents a transaction in the Lynex Router.
 */
export type LynexRouterTransaction = {
	/**
	 * The data payload of the transaction.
	 */
	data: string;
	/**
	 * The value to be transferred in the transaction.
	 */
	value: string;
	/**
	 * The recipient address of the transaction.
	 */
	to: string;
	/**
	 * The sender address of the transaction.
	 */
	from: string;
	/**
	 * The gas price for the transaction (optional).
	 */
	gasPrice?: string;
	/**
	 * The gas limit for the transaction (optional).
	 */
	gasLimit?: string;
	/**
	 * The maximum priority fee per gas unit for the transaction (optional).
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The maximum fee per gas unit for the transaction (optional).
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce: number;
	/**
	 * The type of the transaction (optional).
	 */
	type?: number;
	/**
	 * The chain ID of the blockchain network.
	 */
	chainId: string;
};

export type LynexRouterExecuteFunctionResult = {
	/**
	 * Optional response from simulating asset changes.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * Optional response from broadcasting the raw transaction.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * Optional message providing additional information about the execution.
	 */
	message?: string;
	/**
	 * Optional flag indicating whether the execution was successful.
	 */
	success?: boolean;
	/**
	 * Optional user operation identifier.
	 */
	user_op?: string;
	/**
	 * Optional additional transaction data.
	 */
	data?: Transaction;
	/**
	 * The parameters passed to the executed function.
	 */
	params: Array<unknown>;
	/**
	 * The name of the executed function.
	 */
	function: string;
	/**
	 * The transaction details.
	 */
	transaction: LynexRouterTransaction;
};

export type LynexRouterAPIResponse_LynexRouterExecuteFunctionResult_ = {
	success: boolean;
	message: string;
	data?: LynexRouterExecuteFunctionResult;
};

/**
 * Represents the input body for Lynex Router functions.
 */
export type LynexRouterInputBody = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * The data to be included in the transaction.
	 */
	data?: string;
	/**
	 * The value to be transferred.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce?: string;
	/**
	 * Indicates if the transaction should be simulated.
	 */
	simulate?: boolean;
	/**
	 * The gas limit for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Indicates if the transaction is a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Indicates if the transaction is from an externally owned account.
	 */
	EOA?: boolean;
	/**
	 * The contract address.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Indicates if the transaction should be broadcasted.
	 */
	broadcast?: boolean;
	/**
	 * Indicates if the nonce should always be incremented.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount to be transferred.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
	/**
	 * The address of token A.
	 */
	tokenA: string;
	/**
	 * The address of token B.
	 */
	tokenB: string;
	/**
	 * Indicates if the liquidity is stable.
	 */
	stable: string;
	/**
	 * The desired amount of token A.
	 */
	amountADesired: string;
	/**
	 * The desired amount of token B.
	 */
	amountBDesired: string;
	/**
	 * The minimum amount of token A.
	 */
	amountAMin: string;
	/**
	 * The minimum amount of token B.
	 */
	amountBMin: string;
	/**
	 * The deadline for the transaction.
	 */
	deadline: string;
	/**
	 * The address of the token.
	 */
	token: string;
	/**
	 * The desired amount of the token.
	 */
	amountTokenDesired: string;
	/**
	 * The minimum amount of the token.
	 */
	amountTokenMin: string;
	/**
	 * The minimum amount of ETH.
	 */
	amountETHMin: string;
	/**
	 * The input amount.
	 */
	amountIn: string;
	/**
	 * The minimum output amount.
	 */
	amountOutMin: string;
	/**
	 * The routes for the transaction.
	 */
	routes: Array<unknown>;
};

export type LynexVoterAPIResponse_string_ = {
	success: boolean;
	message: string;
	data?: string;
};

export type LynexVoterAPIResponse_boolean_ = {
	success: boolean;
	message: string;
	data?: boolean;
};

/**
 * Represents a transaction for the Lynex Voter.
 */
export type LynexVoterTransaction = {
	/**
	 * The data to be sent with the transaction.
	 */
	data: string;
	/**
	 * The value to be sent with the transaction, in wei.
	 */
	value: string;
	/**
	 * The recipient address of the transaction.
	 */
	to: string;
	/**
	 * The sender address of the transaction.
	 */
	from: string;
	/**
	 * (Optional) The gas price for the transaction, in wei.
	 */
	gasPrice?: string;
	/**
	 * (Optional) The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * (Optional) The maximum priority fee per gas for the transaction, in wei.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * (Optional) The maximum fee per gas for the transaction, in wei.
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce: number;
	/**
	 * (Optional) The type of the transaction.
	 */
	type?: number;
	/**
	 * The chain ID of the network where the transaction is sent.
	 */
	chainId: string;
};

export type LynexVoterExecuteFunctionResult = {
	/**
	 * Optional response from simulating asset changes.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * Optional response from broadcasting the raw transaction.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * Optional message providing additional information about the execution result.
	 */
	message?: string;
	/**
	 * Optional flag indicating if the function execution was successful.
	 */
	success?: boolean;
	/**
	 * Optional user operation identifier.
	 */
	user_op?: string;
	/**
	 * Optional transaction data.
	 */
	data?: Transaction;
	/**
	 * The parameters passed to the executed function.
	 */
	params: Array<unknown>;
	/**
	 * The name of the executed function.
	 */
	function: string;
	/**
	 * The transaction details of the executed function.
	 */
	transaction: LynexVoterTransaction;
};

export type LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_ = {
	success: boolean;
	message: string;
	data?: LynexVoterExecuteFunctionResult;
};

export type LynexVoterInputBody = {
	/**
	 * The recipient address of the transaction.
	 */
	to?: string;
	/**
	 * The data payload of the transaction.
	 */
	data?: string;
	/**
	 * The value being transferred in the transaction.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce?: string;
	/**
	 * Flag indicating if the operation should be simulated.
	 */
	simulate?: boolean;
	/**
	 * The gas limit for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Flag indicating if the operation is a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Flag indicating if the operation is performed by an Externally Owned Account.
	 */
	EOA?: boolean;
	/**
	 * The contract address involved in the operation.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Flag indicating if the transaction should be broadcasted.
	 */
	broadcast?: boolean;
	/**
	 * Flag indicating if the nonce should always be incremented.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount involved in the transaction.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
	/**
	 * The pool votes for the transaction.
	 */
	pool_vote?: Array<string>;
	/**
	 * The weights for the pool votes.
	 */
	weights?: Array<string>;
	/**
	 * The gauge involved in the operation.
	 */
	gauge?: string;
	/**
	 * The pool involved in the operation.
	 */
	pool?: string;
	/**
	 * The type of the gauge.
	 */
	gauge_type?: string;
	/**
	 * The bribes involved in the operation.
	 */
	bribes?: Array<string>;
	/**
	 * The tokens involved in the operation.
	 */
	tokens?: Array<Array<string>>;
	/**
	 * The fees involved in the operation.
	 */
	fees?: Array<string>;
	/**
	 * The gauges involved in the operation.
	 */
	gauges?: Array<string>;
};

export type MultiCallAPIResponse_string_ = {
	success: boolean;
	message: string;
	data?: string;
};

export type FlowNode = {
	id: string;
	type: "action" | "condition" | "userFunction";
	data: {
		userFunctionName?: string;
		condition?: string;
		params?: unknown;
		function?: string;
		wrapper?: string;
	};
};

export enum type2 {
	ACTION = "action",
	CONDITION = "condition",
	USER_FUNCTION = "userFunction",
}

export type FlowEdge = {
	id: string;
	source: string;
	target: string;
	label?: string;
};

/**
 * Construct a type with a set of properties K of type T
 */
export type Record_string_any_ = {
	/**
	 * The error message.
	 */
	message: string;
};

export type MultiCallInputBody = {
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	flow?: {
		edges: Array<FlowEdge>;
		nodes: Array<FlowNode>;
	};
	globalVariables?: Record_string_any_;
	calls: Array<{
		chainId: string;
		params: unknown;
		function: string;
		wrapper: string;
		from: string;
	}>;
};

export type MultiCallAPIResponse = {
	success: boolean;
	message: string;
	data?: unknown;
};

export type MultiCallAPIResponse_any_ = {
	success: boolean;
	message: string;
	data?: unknown;
};

export type ScheduleJobBody = {
	jobId: string;
	schedule: string;
};

export type MultiCallAPIResponse_any_Array_ = {
	success: boolean;
	message: string;
	data?: Array<unknown>;
};

export type Json =
	| (
			| string
			| number
			| boolean
			| {
					[key: string]: Json;
			  }
			| Array<Json>
	  )
	| null;

export type Jobs = {
	user_id: string;
	updated_at: string;
	status: string;
	id: string;
	global_variables: Json | null;
	flow_id: string | null;
	flow: Json | null;
	error: Json | null;
	created_at: string;
	calls: Json;
};

export type MultiCallAPIResponse_Jobs_Array_ = {
	success: boolean;
	message: string;
	data?: Array<Jobs>;
};

export type MultiCallAPIResponse_Jobs_ = {
	success: boolean;
	message: string;
	data?: Jobs;
};

export type CreateFlowBody = {
	name: string;
	description: string;
	nodes: Array<FlowNode>;
	edges: Array<FlowEdge>;
	created_at: string;
	id: string;
	updated_at: string;
	user_id: string;
};

export type Flow = {
	version: number;
	user_id: string;
	updated_at: string;
	nodes: Json;
	name: string;
	id: string;
	edges: Json;
	description: string | null;
	created_at: string;
};

export type MultiCallAPIResponse_Flow_Array_ = {
	success: boolean;
	message: string;
	data?: Array<Flow>;
};

export type MultiCallAPIResponse_Flow_ = {
	success: boolean;
	message: string;
	data?: Flow;
};

export type UpdateFlowBody = {
	name?: string;
	description?: string;
	nodes?: Array<FlowNode>;
	edges?: Array<FlowEdge>;
};

/**
 * Represents a transaction in the Odos system.
 */
export type OdosTransaction = {
	/**
	 * The data payload of the transaction.
	 */
	data: string;
	/**
	 * The value being transferred in the transaction, in wei.
	 */
	value: string;
	/**
	 * The recipient address of the transaction.
	 */
	to: string;
	/**
	 * The sender address of the transaction.
	 */
	from: string;
	/**
	 * The gas price for the transaction, in wei.
	 * Optional.
	 */
	gasPrice?: string;
	/**
	 * The gas limit for the transaction.
	 * Optional.
	 */
	gasLimit?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce: number;
	/**
	 * The chain ID of the blockchain network.
	 */
	chainId: string;
	/**
	 * The maximum priority fee per gas for EIP-1559 transactions, in wei.
	 * Optional.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The maximum fee per gas for EIP-1559 transactions, in wei.
	 * Optional.
	 */
	maxFeePerGas?: string;
	/**
	 * The type of the transaction.
	 * Optional.
	 */
	type?: number;
};

/**
 * Represents the result of executing an Odos function.
 */
export type OdosExecuteFunctionResult = {
	/**
	 * The broadcasted transaction details.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * The Odos data.
	 */
	odos?: unknown;
	/**
	 * A message providing additional information about the execution.
	 */
	message?: string;
	/**
	 * Indicates if the execution was successful.
	 */
	success?: boolean;
	/**
	 * Indicates if the execution was successful.
	 */
	user_op?: string;
	/**
	 * The data returned by the executed function.
	 */
	data?: unknown;
	/**
	 * The parameters of the executed function.
	 */
	params: Array<unknown>;
	/**
	 * The name of the executed function.
	 */
	function: string;
	/**
	 * The transaction details.
	 */
	transaction?: OdosTransaction;
};

/**
 * Represents the structure of a response from the Odos API.
 */
export type OdosAPIResponse_OdosExecuteFunctionResult_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: OdosExecuteFunctionResult;
};

export type PathVizImageConfig = {
	/**
	 * The colors of the links in the path visualization image.
	 */
	linkColors?: Array<string>;
	/**
	 * The color of the nodes in the path visualization image.
	 */
	nodeColor?: string;
	/**
	 * The color of the text on the nodes in the path visualization image.
	 */
	nodeTextColor?: string;
	/**
	 * The color of the text on the legend in the path visualization image.
	 */
	legendTextColor?: string;
	/**
	 * The width of the path visualization image.
	 */
	width?: number;
	/**
	 * The height of the path visualization image.
	 */
	height?: number;
};

/**
 * Represents the input body for an Odos swap operation.
 */
export type OdosSwapInputBody = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * The data to be sent.
	 */
	data?: string;
	/**
	 * The value to be sent.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce?: string;
	/**
	 * Whether to simulate the transaction.
	 */
	simulate?: boolean;
	/**
	 * The gas for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Whether to perform a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Whether the transaction is from an externally owned account.
	 */
	EOA?: boolean;
	/**
	 * The contract address.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Whether to broadcast the transaction.
	 */
	broadcast?: boolean;
	/**
	 * Whether to always increment the nonce.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount involved in the transaction.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * Referral code for the swap.
	 * Optional.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * An array of input tokens with their respective amounts.
	 */
	inputTokens: Array<TokenAmount>;
	/**
	 * An array of output tokens with their respective proportions.
	 */
	outputTokens: Array<TokenProportion>;
	/**
	 * The maximum allowable slippage percentage for the swap.
	 * Optional.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
	/**
	 * A list of sources to be excluded from the swap.
	 * Optional.
	 */
	sourceBlacklist?: Array<string>;
	/**
	 * A list of sources to be included in the swap.
	 * Optional.
	 */
	sourceWhitelist?: Array<string>;
	/**
	 * A list of pools to be excluded from the swap.
	 * Optional.
	 */
	poolBlacklist?: Array<string>;
	/**
	 * Flag to enable path visualization.
	 * Optional.
	 */
	pathViz?: boolean;
	/**
	 * Flag to enable path visualization image generation.
	 * Optional.
	 */
	pathVizImage?: boolean;
	/**
	 * Configuration for path visualization image generation.
	 * Optional.
	 */
	pathVizImageConfig?: PathVizImageConfig;
	/**
	 * Flag to disable RFQs (Request for Quotes).
	 * Optional.
	 */
	disableRFQs?: boolean;
	/**
	 * Flag to enable compact mode.
	 * Optional.
	 */
	compact?: boolean;
	/**
	 * Flag to indicate if the swap should be performed with like assets.
	 * Optional.
	 */
	likeAsset?: boolean;
	/**
	 * Flag to enable simple mode.
	 * Optional.
	 */
	simple?: boolean;
};

/**
 * Represents a request to assemble a specific path for a user.
 */
export type AssembleRequest = {
	/**
	 * The address of the user making the request.
	 */
	userAddr: string;
	/**
	 * The ID of the path to be assembled.
	 */
	pathId: string;
	/**
	 * Whether to simulate the transaction.
	 */
	simulate?: boolean;
	/**
	 * The address of the receiver, if any.
	 */
	receiver?: string;
};

export type CryptoCurrency = {
	/**
	 * The display name of the network.
	 */
	networkDisplayName: string;
	/**
	 * The URL or path to the icon representing the cryptocurrency.
	 */
	icon: string;
	/**
	 * The chain ID of the network.
	 */
	chainId: number;
	/**
	 * The address of the cryptocurrency on the network.
	 */
	address: string;
	/**
	 * The number of decimal places the cryptocurrency supports.
	 */
	decimals: number;
	/**
	 * The network on which the cryptocurrency operates.
	 */
	network: string;
	/**
	 * The symbol of the cryptocurrency (e.g., ₿, Ξ).
	 */
	symbol: string;
	/**
	 * The name of the cryptocurrency.
	 */
	name: string;
	/**
	 * The code of the cryptocurrency (e.g., BTC, ETH).
	 */
	code: string;
	/**
	 * The unique identifier of the cryptocurrency.
	 */
	id: string;
};

/**
 * Represents a fiat currency.
 */
export type FiatCurrency = {
	/**
	 * The URL or path to the icon representing the fiat currency.
	 */
	icon: string;
	/**
	 * The symbol of the fiat currency (e.g., $, €).
	 */
	symbol: string;
	/**
	 * The name of the fiat currency.
	 */
	name: string;
	/**
	 * The code of the fiat currency (e.g., USD, EUR).
	 */
	code: string;
	/**
	 * The unique identifier for the fiat currency.
	 */
	id: string;
};

export type Message = {
	/**
	 * An array of fiat currency objects.
	 */
	fiat: Array<FiatCurrency>;
	/**
	 * An array of cryptocurrency objects.
	 */
	crypto: Array<CryptoCurrency>;
};

/**
 * Represents the response containing supported currencies.
 */
export type SupportedCurrenciesResponse = {
	/**
	 * The message containing arrays of cryptocurrencies and fiat currencies.
	 */
	message: Message;
};

/**
 * Represents a type of payment method.
 */
export type PaymentType = {
	/**
	 * The URL or path to the icon representing the payment type.
	 */
	icon: string;
	/**
	 * The name of the payment type.
	 */
	name: string;
	/**
	 * The unique identifier for the payment type.
	 */
	paymentTypeId: string;
};

/**
 * Represents a message containing supported payment types.
 */
export type SupportedPaymentTypesMessage = {
	/**
	 * The payment type for Google Pay.
	 */
	googlepay: PaymentType;
	/**
	 * The payment type for Apple Pay.
	 */
	applepay: PaymentType;
	/**
	 * The payment type for credit cards.
	 */
	creditcard: PaymentType;
};

/**
 * Represents the response containing supported payment types and their associated message.
 */
export type SupportedPaymentTypesCurrencyResponse = {
	/**
	 * The message containing supported payment types.
	 */
	message: SupportedPaymentTypesMessage;
};

/**
 * Represents the response structure for supported default values.
 */
export type SupportedDefaultResponse = {
	/**
	 * The default transaction details.
	 */
	defaults: {
		/**
		 * The unique identifier for the transaction.
		 */
		id: {
			/**
			 * The provider of the transaction.
			 */
			provider: string;
			/**
			 * The payment method used for the transaction.
			 */
			paymentMethod: string;
			/**
			 * The amount involved in the transaction.
			 */
			amount: number;
			/**
			 * The destination of the transaction.
			 */
			target: string;
			/**
			 * The source of the transaction.
			 */
			source: string;
		};
	};
	/**
	 * The recommended transaction details.
	 */
	recommended: {
		/**
		 * The provider of the transaction.
		 */
		provider: string;
		/**
		 * The payment method used for the transaction.
		 */
		paymentMethod: string;
		/**
		 * The amount involved in the transaction.
		 */
		amount: number;
		/**
		 * The destination of the transaction.
		 */
		target: string;
		/**
		 * The unique identifier for the transaction.
		 */
		source: string;
	};
};

/**
 * Represents the response structure for supported assets.
 */
export type SupportedAssetResponse = {
	/**
	 * The country code where the assets are supported.
	 */
	country: string;
	/**
	 * An array of objects representing the supported assets.
	 */
	assets: Array<{
		/**
		 * An array of supported cryptocurrencies.
		 */
		crypto: Array<string>;
		/**
		 * An array of supported payment methods.
		 */
		paymentMethods: Array<string>;
		/**
		 * The fiat currency code.
		 */
		fiat: string;
	}>;
};

/**
 * Represents the response from the GetSupportedOnRamps API.
 */
export type GetSupportedOnRampsResponse = {
	/**
	 * An array of supported on-ramp objects.
	 */
	message: Array<{
		/**
		 * The unique identifier of the on-ramp.
		 */
		id: string;
		/**
		 * The display name of the on-ramp.
		 */
		displayName: string;
		/**
		 * The URL of the icon for the on-ramp.
		 */
		icons: {
			/**
			 * An object containing different sizes of the PNG format of the icon.
			 */
			png: {
				"160x160": string;
				"32x32": string;
			};
			/**
			 * The URL of the SVG format of the icon.
			 */
			svg: string;
		};
		/**
		 * The on-ramp service.
		 */
		icon: string;
	}>;
};

/**
 * Represents an array of Quote objects.
 */
export type Quotes = Array<Quote>;

/**
 * Represents a quote for selling cryptocurrency.
 */
export type SellQuote = {
	/**
	 * A list of recommendations related to the quote.
	 */
	recommendations: Array<string>;
	/**
	 * The unique identifier for the quote.
	 */
	quoteId: string;
	/**
	 * The method of payment used for the transaction.
	 */
	paymentMethod: string;
	/**
	 * The ramp service used for the transaction.
	 */
	ramp: string;
	/**
	 * The amount to be paid out after fees.
	 */
	payout: number;
	/**
	 * The fee charged for processing the transaction.
	 */
	transactionFee: number;
	/**
	 * The fee charged by the network for the transaction.
	 */
	networkFee: number;
	/**
	 * The exchange rate for the cryptocurrency.
	 */
	rate: number;
};

/**
 * Represents an array of SellQuote objects.
 */
export type SellQuotes = Array<SellQuote>;

/**
 * Represents the input for a transaction in the OnRamper system.
 */
export type TransactionInput = {
	/**
	 * Supported parameters for the transaction.
	 */
	supportedParams: {
		/**
		 * Partner-specific data for the transaction.
		 */
		partnerData: {
			/**
			 * Redirect URLs for the transaction.
			 */
			redirectUrl: {
				/**
				 * The URL to redirect to upon successful transaction.
				 */
				success: string;
			};
		};
		/**
		 * Theme settings for the transaction.
		 */
		theme: {
			/**
			 * The border radius of the theme.
			 */
			borderRadius: number | null;
			/**
			 * The card color of the theme.
			 */
			cardColor: string;
			/**
			 * The secondary text color of the theme.
			 */
			secondaryTextColor: string;
			/**
			 * The primary text color of the theme.
			 */
			primaryTextColor: string;
			/**
			 * The secondary color of the theme.
			 */
			secondaryColor: string;
			/**
			 * The primary color of the theme.
			 */
			primaryColor: string;
			/**
			 * The name of the theme.
			 */
			themeName: string;
			/**
			 * Indicates if the theme is dark.
			 */
			isDark: boolean;
		};
	};
	/**
	 * The wallet information for the transaction.
	 */
	wallet: {
		/**
		 * The wallet address involved in the transaction.
		 */
		address: string;
	};
	/**
	 * Additional metadata for the transaction.
	 */
	metaData: {
		/**
		 * The quote ID associated with the transaction.
		 */
		quoteId: string;
	};
	/**
	 * The originating host of the transaction.
	 */
	originatingHost: string;
	/**
	 * The context provided by the partner.
	 */
	partnerContext: string;
	/**
	 * The unique identifier for the transaction.
	 */
	uuid: string;
	/**
	 * The network used for the transaction.
	 */
	network: string;
	/**
	 * The payment method used for the transaction.
	 */
	paymentMethod: string;
	/**
	 * The type of transaction.
	 */
	type: string;
	/**
	 * The amount involved in the transaction.
	 */
	amount: number;
	/**
	 * The destination of the transaction.
	 */
	destination: string;
	/**
	 * The source of the transaction.
	 */
	source: string;
	/**
	 * The onramp service used for the transaction.
	 */
	onramp: string;
};

export type OpenSeaAPIResponse = {
	success: boolean;
	message: string;
	data?: unknown;
};

/**
 * Token standards
 */
export enum TokenStandard {
	ERC20 = "ERC20",
	ERC721 = "ERC721",
	ERC1155 = "ERC1155",
}

/**
 * Generic Blockchain Asset.
 */
export type Asset = {
	/**
	 * The asset's token ID, or null if ERC-20
	 */
	tokenId: string | null;
	/**
	 * The asset's contract address
	 */
	tokenAddress: string;
	/**
	 * The token standard (e.g. "ERC721") for this asset
	 */
	tokenStandard?: TokenStandard;
	/**
	 * Optional for ENS names
	 */
	name?: string;
	/**
	 * Optional for fungible items
	 */
	decimals?: number;
};

/**
 * Represents the input body for an OpenSea NFT transaction.
 */
export type OpenSeaNFTInputBody = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * The value to be sent in the transaction.
	 */
	value?: string;
	/**
	 * The data to be sent in the transaction.
	 */
	data?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The chain ID of the blockchain network.
	 */
	chainId?: string;
	/**
	 * Indicates if the transaction is a dry run.
	 */
	dryrun?: boolean;
	/**
	 * Indicates if the transaction should be broadcasted.
	 */
	broadcast?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset: Asset;
	/**
	 * The starting amount for the offer.
	 */
	startAmount: number;
	/**
	 * The expiration time of the offer (optional).
	 */
	expirationTime?: number;
};

/**
 * Represents the input body for an OpenSea collection.
 * Extends the `OpenSeaInputBody` interface.
 */
export type OpenSeaCollectionInputBody = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * The value to be sent in the transaction.
	 */
	value?: string;
	/**
	 * The data to be sent in the transaction.
	 */
	data?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The chain ID of the blockchain network.
	 */
	chainId?: string;
	/**
	 * Indicates if the transaction is a dry run.
	 */
	dryrun?: boolean;
	/**
	 * Indicates if the transaction should be broadcasted.
	 */
	broadcast?: boolean;
	/**
	 * The slug identifier for the collection.
	 */
	collectionSlug: string;
	/**
	 * The amount of the asset.
	 */
	amount: number;
	/**
	 * The quantity of the asset.
	 */
	quantity: number;
	/**
	 * The optional address of the payment token.
	 */
	paymentTokenAddress?: string;
};

export type PingResponse = {
	message: string;
};

export type PolymarketWrapperNewOrder_string_ = {
	order: {
		signature: string;
		signatureType: number;
		side: string;
		feeRateBps: string;
		nonce: string;
		expiration: string;
		takerAmount: string;
		makerAmount: string;
		tokenId: string;
		taker: string;
		signer: string;
		maker: string;
		salt: number;
	};
	owner: string;
	orderType: string;
};

export type CreateOrderResponse = {
	order: PolymarketWrapperNewOrder_string_;
};

export type PolymarketAPIResponse_CreateOrderResponse_ = {
	success: boolean;
	message: string;
	data?: CreateOrderResponse;
};

export type CreateOrderBody = {
	chain_id: string;
	userOrder: {
		taker?: string;
		expiration?: number;
		nonce?: number;
		feeRateBps?: number;
		side: string;
		size: number;
		price: number;
		tokenID: string;
	};
	options: {
		negRisk?: boolean;
		tickSize: string;
	};
};

export type PolymarketWrapperSignedOrder = {
	maker: string;
	taker: string;
	tokenId: string;
	makerAmount: string;
	takerAmount: string;
	side: number;
	expiration: string;
	nonce: string;
	feeRateBps: string;
	signature: string;
	salt: string;
	signer: string;
	signatureType: number;
};

export type CreateMarketBuyOrderResponse = {
	order: PolymarketWrapperSignedOrder;
};

export type PolymarketAPIResponse_CreateMarketBuyOrderResponse_ = {
	success: boolean;
	message: string;
	data?: CreateMarketBuyOrderResponse;
};

export type CreateMarketBuyOrderBody = {
	chain_id: string;
	userMarketOrder: {
		taker?: string;
		nonce?: number;
		feeRateBps?: number;
		amount: number;
		price?: number;
		tokenID: string;
	};
	options?: {
		negRisk?: boolean;
		tickSize?: string;
	};
};

export type PostOrderResponse = {
	success: boolean;
	orderID: string;
};

export type PolymarketAPIResponse_PostOrderResponse_ = {
	success: boolean;
	message: string;
	data?: PostOrderResponse;
};

export type PostOrderBody = {
	chain_id: string;
	order: PolymarketWrapperSignedOrder;
};

export type CancelOrderResponse = {
	success: boolean;
	orderID: string;
};

export type PolymarketAPIResponse_CancelOrderResponse_ = {
	success: boolean;
	message: string;
	data?: CancelOrderResponse;
};

export type CancelOrderBody = {
	chain_id: string;
	orderID: string;
};

export type CancelOrdersResponse = {
	success: boolean;
	orderIDs: Array<string>;
};

export type PolymarketAPIResponse_CancelOrdersResponse_ = {
	success: boolean;
	message: string;
	data?: CancelOrdersResponse;
};

export type CancelOrdersBody = {
	chain_id: string;
	ordersHashes: Array<string>;
};

export type CancelMarketOrdersResponse = {
	success: boolean;
	orderIDs: Array<string>;
};

export type PolymarketAPIResponse_CancelMarketOrdersResponse_ = {
	success: boolean;
	message: string;
	data?: CancelMarketOrdersResponse;
};

export type CancelMarketOrdersBody = {
	chain_id: string;
	payload: {
		outcomeId?: string;
		market: string;
	};
};

export type UpdateBalanceAllowanceResponse = {
	success: boolean;
	newAllowance: string;
};

export type PolymarketAPIResponse_UpdateBalanceAllowanceResponse_ = {
	success: boolean;
	message: string;
	data?: UpdateBalanceAllowanceResponse;
};

export type UpdateBalanceAllowanceBody = {
	chain_id: string;
	params: {
		token_id?: string;
		asset_type: string;
	};
};

export type DropNotificationsResponse = {
	success: boolean;
	droppedCount: number;
};

export type PolymarketAPIResponse_DropNotificationsResponse_ = {
	success: boolean;
	message: string;
	data?: DropNotificationsResponse;
};

export type DropNotificationsBody = {
	chain_id: string;
	params: {
		notification_ids?: Array<string>;
	};
};

export type PaginationPayload = {
	limit: number;
	count: number;
	next_cursor: string;
	data: Array<unknown>;
};

export type PolymarketAPIResponse_PaginationPayload_ = {
	success: boolean;
	message: string;
	data?: PaginationPayload;
};

export type PolymarketAPIResponse_any_ = {
	success: boolean;
	message: string;
	data?: unknown;
};

export type ApproveForPolymarketBody = {
	chain_id: string;
};

export type OrderSummary = {
	price: string;
	size: string;
};

export type OrderBookSummary = {
	market: string;
	asset_id: string;
	timestamp: string;
	bids: Array<OrderSummary>;
	asks: Array<OrderSummary>;
	hash: string;
};

export type PolymarketAPIResponse_OrderBookSummary_ = {
	success: boolean;
	message: string;
	data?: OrderBookSummary;
};

export type OpenOrder = {
	id: string;
	status: string;
	owner: string;
	maker_address: string;
	market: string;
	asset_id: string;
	side: string;
	original_size: string;
	size_matched: string;
	price: string;
	associate_trades: Array<string>;
	outcome: string;
	created_at: number;
	expiration: string;
	order_type: string;
};

export type OpenOrdersResponse = Array<OpenOrder>;

export type PolymarketAPIResponse_OpenOrdersResponse_ = {
	success: boolean;
	message: string;
	data?: OpenOrdersResponse;
};

export type PolymarketAPIResponse_OpenOrder_ = {
	success: boolean;
	message: string;
	data?: OpenOrder;
};

export type MakerOrder = {
	order_id: string;
	owner: string;
	maker_address: string;
	matched_amount: string;
	price: string;
	fee_rate_bps: string;
	asset_id: string;
	outcome: string;
};

export type Trade = {
	id: string;
	taker_order_id: string;
	market: string;
	asset_id: string;
	side: number | string;
	size: string;
	fee_rate_bps: string;
	price: string;
	status: string;
	match_time: string;
	last_update: string;
	outcome: string;
	bucket_index: number;
	owner: string;
	maker_address: string;
	maker_orders: Array<MakerOrder>;
	transaction_hash: string;
	trader_side: "TAKER" | "MAKER";
};

export enum trader_side {
	TAKER = "TAKER",
	MAKER = "MAKER",
}

export type PolymarketAPIResponse_Trade_Array_ = {
	success: boolean;
	message: string;
	data?: Array<Trade>;
};

export type Notification = {
	type: number;
	owner: string;
	payload: unknown;
};

export type PolymarketAPIResponse_Notification_Array_ = {
	success: boolean;
	message: string;
	data?: Array<Notification>;
};

export type BalanceAllowanceResponse = {
	balance: string;
	allowance: string;
};

export type PolymarketAPIResponse_BalanceAllowanceResponse_ = {
	success: boolean;
	message: string;
	data?: BalanceAllowanceResponse;
};

export type MarketPrice = {
	t: number;
	p: number;
};

export type PolymarketAPIResponse_MarketPrice_Array_ = {
	success: boolean;
	message: string;
	data?: Array<MarketPrice>;
};

export enum Side {
	BUY = "BUY",
	SELL = "SELL",
}

export type MarketTradeEvent = {
	event_type: string;
	market: {
		slug: string;
		icon: string;
		question: string;
		asset_id: string;
		condition_id: string;
	};
	user: {
		pseudonym: string;
		optimized_profile_picture: string;
		profile_picture: string;
		username: string;
		address: string;
	};
	side: Side;
	size: string;
	fee_rate_bps: string;
	price: string;
	outcome: string;
	outcome_index: number;
	transaction_hash: string;
	timestamp: string;
};

export type PolymarketAPIResponse_MarketTradeEvent_Array_ = {
	success: boolean;
	message: string;
	data?: Array<MarketTradeEvent>;
};

export type RamsesAPIResponse = {
	success: boolean;
	message: string;
	data?: unknown;
};

export type RamsesNFTAPIResponse_string_ = {
	success: boolean;
	message: string;
	data?: string;
};

export type RamsesNFTTransaction = {
	data: string;
	value: string;
	to: string;
	from: string;
	gasPrice?: string;
	gasLimit?: string;
	maxPriorityFeePerGas?: string;
	maxFeePerGas?: string;
	nonce: number;
	type?: number;
	chainId: string;
};

export type RamsesNFTExecuteFunctionResult = {
	simulation?: SimulateAssetChangesResponse;
	broadcasted?: BroadCastRawTransactionResponse;
	message?: string;
	success?: boolean;
	user_op?: string;
	data?: Transaction;
	params: Array<unknown>;
	function: string;
	transaction: RamsesNFTTransaction;
};

export type RamsesNFTAPIResponse_RamsesNFTExecuteFunctionResult_ = {
	success: boolean;
	message: string;
	data?: RamsesNFTExecuteFunctionResult;
};

export type RamsesNFTInputBody = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * The data to be sent.
	 */
	data?: string;
	/**
	 * The value to be sent.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce?: string;
	/**
	 * Whether to simulate the transaction.
	 */
	simulate?: boolean;
	/**
	 * The gas for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Whether to perform a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Whether the transaction is from an externally owned account.
	 */
	EOA?: boolean;
	/**
	 * The contract address.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Whether to broadcast the transaction.
	 */
	broadcast?: boolean;
	/**
	 * Whether to always increment the nonce.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount involved in the transaction.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
	tokenId?: string;
	lock_duration?: string;
	delegatee?: string;
	expiry?: string;
	v?: number;
	r?: string;
	s?: string;
	from?: string;
	operator?: string;
	_proxy?: string;
	_team?: string;
	_block?: string;
	_t?: string;
	_idx?: string;
	token?: string;
	artProxy?: string;
	voter?: string;
};

export type LockedData = {
	amount: string;
	end: string;
};

export type RamsesNFTAPIResponse_LockedData_ = {
	success: boolean;
	message: string;
	data?: LockedData;
};

/**
 * Interface representing a Ramses Router transaction.
 */
export type RamsesRouterTransaction = {
	/**
	 * The data for the transaction.
	 */
	data: string;
	/**
	 * The value for the transaction.
	 */
	value: string;
	/**
	 * The destination address for the transaction.
	 */
	to: string;
	/**
	 * The source address for the transaction.
	 */
	from: string;
	/**
	 * (Optional) The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * (Optional) The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * (Optional) The maximum priority fee per gas for the transaction, in wei.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * (Optional) The maximum fee per gas for the transaction, in wei.
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce: number;
	/**
	 * (Optional) The type of the transaction.
	 */
	type?: number;
	/**
	 * The chain ID for the transaction.
	 */
	chainId: string;
};

export type RamsesRouterExecuteFunctionResult = {
	/**
	 * The simulation result of the transaction.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * The broadcasted transaction details.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * A message providing additional information about the execution result.
	 */
	message?: string;
	/**
	 * Indicates if the execution was successful.
	 */
	success?: boolean;
	/**
	 * Indicates if the execution was successful.
	 */
	user_op?: string;
	/**
	 * The data returned by the executed function.
	 */
	data?: Transaction;
	/**
	 * The parameters passed to the executed function.
	 */
	params: Array<unknown>;
	/**
	 * The name of the executed function.
	 */
	function: string;
	/**
	 * The transaction details.
	 */
	transaction: RamsesRouterTransaction;
};

export type RamsesRouterAPIResponse_RamsesRouterExecuteFunctionResult_ = {
	success: boolean;
	message: string;
	data?: RamsesRouterExecuteFunctionResult;
};

/**
 * Interface representing the input body for the Ramses Router.
 * Extends the InputBody interface.
 */
export type RamsesRouterInputBody = {
	/**
	 * The destination address.
	 */
	to?: string;
	/**
	 * The data to be sent.
	 */
	data?: string;
	/**
	 * The value to be sent.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce?: string;
	/**
	 * Indicates if the transaction is a simulation.
	 */
	simulate?: boolean;
	/**
	 * The gas for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Whether to perform a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Whether the transaction is from an externally owned account.
	 */
	EOA?: boolean;
	/**
	 * The contract address.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Whether to broadcast the transaction.
	 */
	broadcast?: boolean;
	/**
	 * Whether to always increment the nonce.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount involved in the transaction.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts of the asset.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
	/**
	 * The routes for the asset transfer.
	 * Each route contains the source, destination, and a flag indicating if the route is stable.
	 */
	routes?: Array<{
		stable: boolean;
		to: string;
		from: string;
	}>;
	/**
	 * The deadline for the transaction.
	 */
	deadline?: string;
	/**
	 * The first token involved in the transaction.
	 */
	tokenA?: string;
	/**
	 * The second token involved in the transaction.
	 */
	tokenB?: string;
	/**
	 * Indicates if the transaction is stable.
	 */
	stable?: boolean;
	/**
	 * The desired amount of token A.
	 */
	amountADesired?: string;
	/**
	 * The desired amount of token B.
	 */
	amountBDesired?: string;
	/**
	 * The minimum amount of token A.
	 */
	amountAMin?: string;
	/**
	 * The minimum amount of token B.
	 */
	amountBMin?: string;
	/**
	 * The token involved in the transaction.
	 */
	token?: string;
	/**
	 * The liquidity amount.
	 */
	liquidity?: string;
	/**
	 * The desired amount of the token.
	 */
	amountTokenDesired?: string;
	/**
	 * The minimum amount of the token.
	 */
	amountTokenMin?: string;
	/**
	 * The minimum amount of ETH.
	 */
	amountETHMin?: string;
	/**
	 * Indicates if the maximum approval is granted.
	 */
	approveMax?: boolean;
	/**
	 * The v parameter for the transaction signature.
	 */
	v?: number;
	/**
	 * The r parameter for the transaction signature.
	 */
	r?: string;
	/**
	 * The s parameter for the transaction signature.
	 */
	s?: string;
	/**
	 * The input amount for the transaction.
	 */
	amountIn?: string;
	/**
	 * The minimum output amount for the transaction.
	 */
	amountOutMin?: string;
	/**
	 * The source token for the transaction.
	 */
	tokenFrom?: string;
	/**
	 * The destination token for the transaction.
	 */
	tokenTo?: string;
};

export type RamsesRouterAPIResponse_string_ = {
	success: boolean;
	message: string;
	data?: string;
};

export type RamsesRouterAPIResponse__amountOut_string__stable_boolean__ = {
	success: boolean;
	message: string;
	data?: {
		stable: boolean;
		amountOut: string;
	};
};

export type RamsesRouterAPIResponse_string_Array_ = {
	success: boolean;
	message: string;
	data?: Array<string>;
};

export type RamsesRouterAPIResponse__reserve0_string__reserve1_string__ = {
	success: boolean;
	message: string;
	data?: {
		reserve1: string;
		reserve0: string;
	};
};

export type RamsesRouterAPIResponse_boolean_ = {
	success: boolean;
	message: string;
	data?: boolean;
};

export type RamsesRouterAPIResponse__amountA_string__amountB_string__liquidity_string____ =
	{
		success: boolean;
		message: string;
		data?: {
			liquidity: string;
			amountB: string;
			amountA: string;
		};
	};

export type RamsesRouterAPIResponse__amountA_string__amountB_string__ = {
	success: boolean;
	message: string;
	data?: {
		amountB: string;
		amountA: string;
	};
};

export type SortedTokens = {
	token0: string;
	token1: string;
};

export type RamsesRouterAPIResponse_SortedTokens_ = {
	success: boolean;
	message: string;
	data?: SortedTokens;
};

export type RamsesVoterAPIResponse_string_ = {
	success: boolean;
	message: string;
	data?: string;
};

export type RamsesVoterAPIResponse_boolean_ = {
	success: boolean;
	message: string;
	data?: boolean;
};

/**
 * Represents a transaction for the Ramses Voter.
 */
export type RamsesVoterTransaction = {
	/**
	 * The data payload of the transaction.
	 */
	data: string;
	/**
	 * The value to be transferred in the transaction.
	 */
	value: string;
	/**
	 * The recipient address of the transaction.
	 */
	to: string;
	/**
	 * The sender address of the transaction.
	 */
	from: string;
	/**
	 * The gas price for the transaction (optional).
	 */
	gasPrice?: string;
	/**
	 * The gas limit for the transaction (optional).
	 */
	gasLimit?: string;
	/**
	 * The maximum priority fee per gas for the transaction (optional).
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The maximum fee per gas for the transaction (optional).
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce: number;
	/**
	 * The type of the transaction (optional).
	 */
	type?: number;
	/**
	 * The chain ID of the blockchain network.
	 */
	chainId: string;
};

/**
 * Represents the result of executing a function on the Ramses Voter.
 */
export type RamsesVoterExecuteFunctionResult = {
	/**
	 * The simulation results.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * The broadcasted transaction data.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * The error message.
	 */
	message?: string;
	/**
	 * Indicates if the function was successful.
	 */
	success?: boolean;
	/**
	 * The user operation.
	 */
	user_op?: string;
	/**
	 * The transaction data.
	 */
	data?: Transaction;
	/**
	 * The function parameters.
	 */
	params: Array<unknown>;
	/**
	 * The function name.
	 */
	function: string;
	/**
	 * The transaction data.
	 */
	transaction: RamsesVoterTransaction;
};

export type RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_ = {
	success: boolean;
	message: string;
	data?: RamsesVoterExecuteFunctionResult;
};

export type RamsesVoterInputBody = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * Additional data for the transaction.
	 */
	data?: string;
	/**
	 * The value associated with the transaction.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce?: string;
	/**
	 * Indicates if the transaction should be simulated.
	 */
	simulate?: boolean;
	/**
	 * The gas limit for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Indicates if the transaction is a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Indicates if the transaction is from an Externally Owned Account.
	 */
	EOA?: boolean;
	/**
	 * The contract address involved in the transaction.
	 */
	contract_address?: string;
	/**
	 * The token ID involved in the transaction.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Indicates if the transaction should be broadcasted.
	 */
	broadcast?: boolean;
	/**
	 * Indicates if the nonce should always be incremented.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount to be transferred.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
	/**
	 * The pool involved in the transaction.
	 */
	pool?: string;
	/**
	 * The gauge involved in the transaction.
	 */
	gauge?: string;
	/**
	 * The weights for the transaction.
	 */
	weights?: Array<string>;
	/**
	 * The pool votes for the transaction.
	 */
	pool_vote?: Array<string>;
	/**
	 * The bribes for the transaction.
	 */
	bribes?: Array<string>;
	/**
	 * The tokens involved in the transaction.
	 */
	tokens?: Array<Array<string>>;
	/**
	 * The fees for the transaction.
	 */
	fees?: Array<string>;
	/**
	 * The gauges involved in the transaction.
	 */
	gauges?: Array<string>;
	/**
	 * The token involved in the transaction.
	 */
	token?: string;
};

/**
 * Represents the input data required for Ripple transactions.
 */
export type RippleInput = {
	/**
	 * The network on which the transaction will be executed. This is optional.
	 */
	network?: string;
	/**
	 * The private key used for signing the transaction. This is optional.
	 */
	private_key?: string;
};

/**
 * Represents the output of a Ripple transaction.
 */
export type RippleTransactionOutput = {
	/**
	 * The signed transaction.
	 */
	signedTx?: string;
	/**
	 * The transaction hash.
	 */
	transaction_hash?: string;
};

export type RippleAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The data associated with the Ripple response.
	 */
	data?: RippleTransactionOutput;
};

/**
 * Represents the input data for a Ripple transaction.
 */
export type RippleTransactionInput = {
	/**
	 * The recipient address of the transaction.
	 */
	to?: string;
	/**
	 * The amount to be sent.
	 */
	value?: number;
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * Indicates whether to compress the public key.
	 */
	compress?: boolean;
};

/**
 * Represents the input parameters required for a Solana transaction.
 */
export type SolanaInput = {
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * The private key of the account.
	 */
	private_key?: string;
};

/**
 * Represents the output of a Solana transaction.
 */
export type SolanaTransactionOutput = {
	/**
	 * The signed transaction.
	 */
	signedTx?: string;
	/**
	 * The transaction hash.
	 */
	transaction_hash?: string;
};

export type SolanaAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The data associated with the Solana response.
	 */
	data?: SolanaTransactionOutput;
};

/**
 * Represents the input required to sign a Solana transaction.
 */
export type SolanaSignTransactionInput = {
	/**
	 * The transaction to be signed.
	 */
	unsigned_tx: string;
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
};

/**
 * Represents the input data required for a Solana transaction.
 */
export type SolanaTransactionInput = {
	/**
	 * The recipient address of the transaction.
	 */
	to?: string;
	/**
	 * The amount of value to be transferred in the transaction.
	 */
	value?: number;
	/**
	 * The network on which the transaction is to be executed.
	 */
	network?: string;
	/**
	 * Indicates whether the transaction data should be compressed.
	 */
	compress?: boolean;
};

export type ThenaAPIResponse = {
	success: boolean;
	message: string;
	data?: unknown;
};

export type ThorSwapAPIResponse_Quote_ = {
	success: boolean;
	message: string;
	data?: Quote;
};

export type ThorSwapAPIResponse_string_ = {
	success: boolean;
	message: string;
	data?: string;
};

/**
 * Represents the gas price information for a specific blockchain.
 */
export type GasPrice = {
	/**
	 * The timestamp of the last recorded gas price.
	 */
	lastTimestamp: number;
	/**
	 * The identifier of the blockchain.
	 */
	chainId: string;
	/**
	 * The unit name of the gas price (e.g., Gwei, Wei).
	 */
	unitName: string;
	/**
	 * The historical gas prices with their respective timestamps.
	 */
	history: Array<{
		timestamp: number;
		value: number;
	}>;
	/**
	 * The average gas price over the last 24 hours.
	 */
	average24h: number;
	/**
	 * The average gas price over the last 7 days.
	 */
	average7d: number;
};

export type ThorSwapAPIResponse_GasPrice_ = {
	success: boolean;
	message: string;
	data?: GasPrice;
};

export type ThorSwapAPIResponse_string_Array_ = {
	success: boolean;
	message: string;
	data?: Array<string>;
};

/**
 * Represents the input data required for Tron network operations.
 */
export type TronInput = {
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * The private key of the account.
	 */
	private_key?: string;
};

/**
 * Represents the output of a Tron transaction.
 */
export type TronTransactionOutput = {
	/**
	 * The signed transaction.
	 */
	signedTx?: string;
	/**
	 * The transaction hash.
	 */
	transaction_hash?: string;
};

export type TronAPIResponse = {
	/**
	 * The success status of the operation.
	 */
	success: boolean;
	/**
	 * The message associated with the operation.
	 */
	message: string;
	/**
	 * The data associated with the operation.
	 */
	body?: InputBody;
	/**
	 * The address associated with the operation.
	 */
	address?: string;
	/**
	 * The data associated with the Tron response.
	 */
	data?: TronTransactionOutput;
};

/**
 * Represents an input for a Tron transaction.
 */
export type TronTransactionInput = {
	/**
	 * The recipient address of the transaction.
	 */
	to?: string;
	/**
	 * The amount to be sent.
	 */
	value?: number;
	/**
	 * The network on which the transaction is taking place.
	 */
	network?: string;
	/**
	 * Indicates whether to compress the public key.
	 */
	compress?: boolean;
};

/**
 * Represents a UniswapV2 transaction.
 */
export type UniswapV2Transaction = {
	/**
	 * The data to include in the transaction.
	 */
	data: string;
	/**
	 * The value to send with the transaction.
	 */
	value: string;
	/**
	 * The address of the recipient.
	 */
	to: string;
	/**
	 * The address of the sender.
	 */
	from: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce: number;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The chain ID for the transaction.
	 */
	chainId: string;
};

/**
 * Represents the result of executing a UniswapV2 function.
 */
export type UniswapV2ExecuteFunctionResult = {
	/**
	 * The simulation data.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * The broadcasted transaction.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * The broadcasted result of the transaction.
	 */
	message?: string;
	/**
	 * The message returned by the API.
	 */
	success?: boolean;
	/**
	 * Indicates whether the function was successful.
	 */
	user_op?: string;
	/**
	 * The data returned by the API.
	 */
	data?: Transaction;
	/**
	 * The parameters passed to the function.
	 */
	params: Array<unknown>;
	/**
	 * The name of the function executed.
	 */
	function: string;
	/**
	 * The UniswapV2 transaction.
	 */
	transaction: UniswapV2Transaction;
};

export type UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_ = {
	success: boolean;
	message: string;
	data?: UniswapV2ExecuteFunctionResult;
};

/**
 * Represents the input body for a UniswapV2 transaction.
 */
export type UniswapV2InputBody = {
	/**
	 * The address of the token to swap.
	 */
	to?: string;
	/**
	 * The address of the token to swap.
	 */
	data?: string;
	/**
	 * The address of the token to swap.
	 */
	value?: string;
	/**
	 * The address of the token to swap.
	 */
	gasLimit?: string;
	/**
	 * The address of the token to swap.
	 */
	nonce?: string;
	/**
	 * The address of the token to swap.
	 */
	simulate?: boolean;
	/**
	 * The address of the token to swap.
	 */
	gas?: string;
	/**
	 * The address of the token to swap.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * The address of the token to swap.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * The address of the token to swap.
	 */
	EOA?: boolean;
	/**
	 * The address of the token to swap.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * The address of the token to swap.
	 */
	broadcast?: boolean;
	/**
	 * The address of the token to swap.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The address of the token to swap.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
	/**
	 * The address of the token to swap.
	 */
	amountIn?: string;
	/**
	 * The address of the token to swap.
	 */
	amountInMax?: string;
	/**
	 * The address of the token to swap.
	 */
	amountOut?: string;
	/**
	 * The address of the token to swap.
	 */
	amountOutMin?: string;
	/**
	 * The address of the token to swap.
	 */
	amountADesired?: string;
	/**
	 * The address of the token to swap.
	 */
	amountBDesired?: string;
	/**
	 * The address of the token to swap.
	 */
	amountAMin?: string;
	/**
	 * The address of the token to swap.
	 */
	amountBMin?: string;
	/**
	 * The address of the token to swap.
	 */
	amountETHMin?: string;
	/**
	 * The address of the token to swap.
	 */
	amountTokenDesired?: string;
	/**
	 * The address of the token to swap.
	 */
	amountTokenMin?: string;
	/**
	 * The address of the token to swap.
	 */
	liquidity?: string;
	/**
	 * The address of the token to swap.
	 */
	path?: Array<string>;
	/**
	 * The address of the token to swap.
	 */
	deadline?: string;
	/**
	 * The address of the token to swap.
	 */
	approveMax?: boolean;
	/**
	 * The address of the token to swap.
	 */
	v?: number;
	/**
	 * The address of the token to swap.
	 */
	r?: string;
	/**
	 * The address of the token to swap.
	 */
	s?: string;
	/**
	 * The address of the token to swap.
	 */
	tokenA?: string;
	/**
	 * The address of the token to swap.
	 */
	tokenB?: string;
	/**
	 * The address of the token to swap.
	 */
	reserveA?: string;
	/**
	 * The address of the token to swap.
	 */
	reserveB?: string;
	/**
	 * The address of the token to swap.
	 */
	reserve?: string;
	/**
	 * The address of the token to swap.
	 */
	reserveETH?: string;
	/**
	 * The address of the token to swap.
	 */
	token?: string;
	/**
	 * The address of the token to swap.
	 */
	amountA?: string;
	/**
	 * The address of the token to swap.
	 */
	reserveIn?: string;
	/**
	 * The address of the token to swap.
	 */
	reserveOut?: string;
};

/**
 * Represents a Uniswap V3 transaction.
 */
export type UniswapV3Transaction = {
	/**
	 * The data payload of the transaction.
	 */
	data: string;
	/**
	 * The value to be sent with the transaction, in wei.
	 */
	value: string;
	/**
	 * The recipient address of the transaction.
	 */
	to: string;
	/**
	 * The sender address of the transaction.
	 */
	from: string;
	/**
	 * The gas price for the transaction, in wei (optional).
	 */
	gasPrice?: string;
	/**
	 * The gas limit for the transaction (optional).
	 */
	gasLimit?: string;
	/**
	 * The maximum priority fee per gas for EIP-1559 transactions, in wei (optional).
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The maximum fee per gas for EIP-1559 transactions, in wei (optional).
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce: number;
	/**
	 * The type of the transaction (optional).
	 */
	type?: number;
	/**
	 * The chain ID of the network where the transaction is sent.
	 */
	chainId: string;
};

export type UniswapV3ExecuteFunctionResult = {
	/**
	 * Optional response containing the simulation of asset changes.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * Optional response indicating whether the transaction was broadcasted.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * Optional message providing additional information about the execution.
	 */
	message?: string;
	/**
	 * Indicates whether the function execution was successful.
	 */
	success?: boolean;
	/**
	 * Optional user operation identifier.
	 */
	user_op?: string;
	/**
	 * Optional transaction data.
	 */
	data?: Transaction;
	/**
	 * The parameters passed to the executed function.
	 */
	params: Array<unknown>;
	/**
	 * The name of the executed function.
	 */
	function: string;
	/**
	 * The transaction details of the executed function.
	 */
	transaction: UniswapV3Transaction;
};

export type UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_ = {
	success: boolean;
	message: string;
	data?: UniswapV3ExecuteFunctionResult;
};

/**
 * Interface representing the input body for Uniswap V3 operations.
 * Extends the InputBody interface.
 */
export type UniswapV3InputBody = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * The data to be sent with the transaction.
	 */
	data?: string;
	/**
	 * The value of the transaction.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce?: string;
	/**
	 * Indicates if the transaction should be simulated.
	 */
	simulate?: boolean;
	/**
	 * The gas limit for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Indicates if the transaction is a dry run.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Indicates if the transaction is from an externally owned account.
	 */
	EOA?: boolean;
	/**
	 * The address of the contract.
	 */
	contract_address?: string;
	/**
	 * The token ID.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Indicates if the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Indicates if the transaction should be broadcasted.
	 */
	broadcast?: boolean;
	/**
	 * Indicates if the nonce should always be incremented.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount to be transferred.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
	/**
	 * The address of the first token.
	 */
	token0?: string;
	/**
	 * The address of the second token.
	 */
	token1?: string;
	/**
	 * The fee tier of the pool.
	 */
	fee?: number;
	/**
	 * The lower tick of the position.
	 */
	tickLower?: number;
	/**
	 * The upper tick of the position.
	 */
	tickUpper?: number;
	/**
	 * The desired amount of token0.
	 */
	amount0Desired?: string;
	/**
	 * The desired amount of token1.
	 */
	amount1Desired?: string;
	/**
	 * The minimum amount of token0.
	 */
	amount0Min?: string;
	/**
	 * The minimum amount of token1.
	 */
	amount1Min?: string;
	/**
	 * The recipient address.
	 */
	recipient?: string;
	/**
	 * The deadline for the transaction.
	 */
	deadline?: string;
	/**
	 * The ID of the token.
	 */
	tokenId?: string;
	/**
	 * The liquidity of the position.
	 */
	liquidity?: string;
	/**
	 * The address of the token.
	 */
	token?: string;
	/**
	 * The maximum amount of token0.
	 */
	amount0Max?: string;
	/**
	 * The maximum amount of token1.
	 */
	amount1Max?: string;
	/**
	 * The sqrt price of the pool.
	 */
	sqrtPriceX96?: string;
	/**
	 * The operator address.
	 */
	operator?: string;
	/**
	 * The address of the spender.
	 */
	spender?: string;
	/**
	 * The recovery id of the signature.
	 */
	v?: number;
	/**
	 * The r value of the signature.
	 */
	r?: string;
	/**
	 * The s value of the signature.
	 */
	s?: string;
	/**
	 * The minimum amount.
	 */
	amountMinimum?: string;
};

export type UniswapV3NFTAPIResponse_any_ = {
	success: boolean;
	message: string;
	data?: unknown;
};

export type UniswapV3NFTAPIResponse_string_ = {
	success: boolean;
	message: string;
	data?: string;
};

export type UniswapV3NFTAPIResponse_boolean_ = {
	success: boolean;
	message: string;
	data?: boolean;
};

export type UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_ = {
	success: boolean;
	message: string;
	data?: UniswapV3ExecuteFunctionResult;
};

export type UniswapV3APIResponse_string_ = {
	success: boolean;
	message: string;
	data?: string;
};

export type VeTheNFTAPIResponse_string_ = {
	success: boolean;
	message: string;
	data?: string;
};

export type VeTheNFTAPIResponse_boolean_ = {
	success: boolean;
	message: string;
	data?: boolean;
};

export type VeTheNFTAPIResponse_LockedData_ = {
	success: boolean;
	message: string;
	data?: LockedData;
};

/**
 * Represents a transaction involving a VeNFT.
 */
export type VeNFTTransaction = {
	/**
	 * The data payload of the transaction.
	 */
	data: string;
	/**
	 * The value being transferred in the transaction.
	 */
	value: string;
	/**
	 * The recipient address of the transaction.
	 */
	to: string;
	/**
	 * The sender address of the transaction.
	 */
	from: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The maximum priority fee per gas unit for the transaction.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The maximum fee per gas unit for the transaction.
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce: number;
	/**
	 * The type of the transaction.
	 */
	type?: number;
	/**
	 * The chain ID where the transaction is executed.
	 */
	chainId: string;
};

/**
 * Represents the result of executing a VeNFT function.
 */
export type VeNFTExecuteFunctionResult = {
	/**
	 * Optional response from simulating asset changes.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * Optional response from broadcasting the raw transaction.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * Optional message providing additional information about the execution.
	 */
	message?: string;
	/**
	 * Optional flag indicating if the execution was successful.
	 */
	success?: boolean;
	/**
	 * Optional user operation identifier.
	 */
	user_op?: string;
	/**
	 * Optional additional transaction data.
	 */
	data?: Transaction;
	/**
	 * The parameters passed to the function.
	 */
	params: Array<unknown>;
	/**
	 * The name of the executed function.
	 */
	function: string;
	/**
	 * The transaction associated with the function execution.
	 */
	transaction: VeNFTTransaction;
};

export type VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_ = {
	success: boolean;
	message: string;
	data?: VeNFTExecuteFunctionResult;
};

/**
 * Interface representing the input body for VeNFT operations.
 */
export type VeNFTInputBody = {
	/**
	 * The recipient address.
	 */
	to?: string;
	/**
	 * Additional data for the transaction.
	 */
	data?: string;
	/**
	 * The value of the transaction.
	 */
	value?: string;
	/**
	 * The gas limit for the transaction.
	 */
	gasLimit?: string;
	/**
	 * The nonce for the transaction.
	 */
	nonce?: string;
	/**
	 * Indicates whether to simulate the transaction.
	 */
	simulate?: boolean;
	/**
	 * The gas limit for the transaction.
	 */
	gas?: string;
	/**
	 * The gas price for the transaction.
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Indicates whether to perform a dry run of the transaction.
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Indicates whether the transaction is from an externally owned account.
	 */
	EOA?: boolean;
	/**
	 * The contract address involved in the transaction.
	 */
	contract_address?: string;
	/**
	 * The token ID involved in the transaction.
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Indicates whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Indicates whether to broadcast the transaction.
	 */
	broadcast?: boolean;
	/**
	 * Indicates whether to always increment the nonce.
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount to be transferred.
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
	/**
	 * The lock duration for the transaction.
	 */
	lock_duration?: string;
	/**
	 * The spender address for the transaction.
	 */
	spender?: string;
	/**
	 * The operator address for the transaction.
	 */
	operator?: string;
	/**
	 * The token ID involved in the transaction.
	 */
	tokenId?: string;
	/**
	 * The lock value for the transaction.
	 */
	lock_value?: string;
	/**
	 * The delegatee address for the transaction.
	 */
	delegatee?: string;
	/**
	 * The expiry time for the transaction.
	 */
	expiry?: string;
};

export type UserPointHistoryData = {
	bias: string;
	slope: string;
	ts: string;
	blk: string;
};

export type VeTheNFTAPIResponse_UserPointHistoryData_ = {
	success: boolean;
	message: string;
	data?: UserPointHistoryData;
};

/**
 * Represents the structure of the API response for the VeTheNftVoter.
 */
export type VeTheNftVoterAPIResponse_string_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the
	 * API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: string;
};

/**
 * Represents the structure of the API response for the VeTheNftVoter.
 */
export type VeTheNftVoterAPIResponse_boolean_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the
	 * API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: boolean;
};

/**
 * Represents a transaction for the VeTheNftVoter.
 */
export type VeTheNftVoterTransaction = {
	/**
	 * The data payload of the transaction.
	 */
	data: string;
	/**
	 * The value to be transferred in the transaction, in wei.
	 */
	value: string;
	/**
	 * The recipient address of the transaction.
	 */
	to: string;
	/**
	 * The sender address of the transaction.
	 */
	from: string;
	/**
	 * The gas price for the transaction, in wei (optional).
	 */
	gasPrice?: string;
	/**
	 * The gas limit for the transaction (optional).
	 */
	gasLimit?: string;
	/**
	 * The maximum priority fee per gas for the transaction, in wei (optional).
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The maximum fee per gas for the transaction, in wei (optional).
	 */
	maxFeePerGas?: string;
	/**
	 * The nonce of the transaction.
	 */
	nonce: number;
	/**
	 * The type of the transaction (optional).
	 */
	type?: number;
	/**
	 * The chain ID of the network where the transaction is to be executed.
	 */
	chainId: string;
};

/**
 * Represents the result of executing a function in the VeTheNftVoter.
 */
export type VeTheNftVoterExecuteFunctionResult = {
	/**
	 * Optional simulation response indicating asset changes.
	 */
	simulation?: SimulateAssetChangesResponse;
	/**
	 * Optional response from broadcasting the transaction.
	 */
	broadcasted?: BroadCastRawTransactionResponse;
	/**
	 * Optional message providing additional information about the execution.
	 */
	message?: string;
	/**
	 * Optional flag indicating whether the execution was successful.
	 */
	success?: boolean;
	/**
	 * Optional user operation identifier.
	 */
	user_op?: string;
	/**
	 * Optional data related to the transaction.
	 */
	data?: Transaction;
	/**
	 * The parameters passed to the function.
	 */
	params: Array<unknown>;
	/**
	 * The name of the function that was executed.
	 */
	function: string;
	/**
	 * The transaction associated with the execution.
	 */
	transaction: VeTheNftVoterTransaction;
};

/**
 * Represents the structure of the API response for the VeTheNftVoter.
 */
export type VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_ = {
	/**
	 * Indicates whether the API request was successful.
	 */
	success: boolean;
	/**
	 * A message providing additional information about the
	 * API response.
	 */
	message: string;
	/**
	 * The data returned by the API, if any.
	 */
	data?: VeTheNftVoterExecuteFunctionResult;
};

export type VeTheNftVoterInputBody = {
	/**
	 * The recipient address of the transaction (optional).
	 */
	to?: string;
	/**
	 * The data payload of the transaction (optional).
	 */
	data?: string;
	/**
	 * The value to be sent with the transaction, in wei (optional).
	 */
	value?: string;
	/**
	 * The gas limit for the transaction (optional).
	 */
	gasLimit?: string;
	/**
	 * The nonce of the transaction (optional).
	 */
	nonce?: string;
	/**
	 * Indicates whether to simulate the transaction (optional).
	 */
	simulate?: boolean;
	/**
	 * The gas limit for the transaction (optional).
	 */
	gas?: string;
	/**
	 * The gas price for the transaction, in wei (optional).
	 */
	gasPrice?: string;
	/**
	 * The maximum fee per gas.
	 */
	maxFeePerGas?: string;
	/**
	 * The maximum priority fee per gas.
	 */
	maxPriorityFeePerGas?: string;
	/**
	 * The chain ID.
	 */
	chain_id?: string;
	/**
	 * The encoding type.
	 */
	encoding?: string;
	/**
	 * The type of transaction.
	 */
	type?: number;
	/**
	 * The access list for the transaction.
	 */
	accessList?: Array<AccessTuple>;
	/**
	 * The gas for blob transactions.
	 */
	blobGas?: string;
	/**
	 * The gas fee cap for blob transactions.
	 */
	blobGasFeeCap?: string;
	/**
	 * The hashes for blob transactions.
	 */
	blobHashes?: Array<string>;
	/**
	 * Indicates whether to perform a dry run of the transaction (optional).
	 */
	dryrun?: boolean;
	/**
	 * The input data.
	 */
	input?: string;
	/**
	 * Indicates whether the transaction is from an externally owned account (optional).
	 */
	EOA?: boolean;
	/**
	 * The contract address involved in the transaction (optional).
	 */
	contract_address?: string;
	/**
	 * The token ID involved in the transaction (optional).
	 */
	token_id?: string;
	/**
	 * The token IDs.
	 */
	token_ids?: string;
	/**
	 * Whether the transaction is approved.
	 */
	approved?: boolean;
	/**
	 * Indicates whether to broadcast the transaction (optional).
	 */
	broadcast?: boolean;
	/**
	 * Indicates whether to always increment the nonce (optional).
	 */
	alwaysIncrementNonce?: boolean;
	/**
	 * The asset involved in the transaction.
	 */
	asset?: string;
	/**
	 * The amount to be transferred (optional).
	 */
	amount?: string;
	/**
	 * The interest rate mode.
	 */
	interestRateMode?: number;
	/**
	 * The referral code.
	 */
	referralCode?: number;
	/**
	 * The address on behalf of which the transaction is made.
	 */
	onBehalfOf?: string;
	/**
	 * The receiver address.
	 */
	receiverAddress?: string;
	/**
	 * The assets involved in the transaction.
	 */
	assets?: Array<string>;
	/**
	 * The amounts involved in the transaction.
	 */
	amounts?: Array<string>;
	/**
	 * The modes of the transaction.
	 */
	modes?: Array<number>;
	/**
	 * Additional parameters.
	 */
	params?: string;
	/**
	 * The rate mode.
	 */
	rateMode?: number;
	/**
	 * Whether to use as collateral.
	 */
	useAsCollateral?: boolean;
	/**
	 * The collateral asset.
	 */
	collateralAsset?: string;
	/**
	 * The debt asset.
	 */
	debtAsset?: string;
	/**
	 * The user involved in the transaction.
	 */
	user?: string;
	/**
	 * The debt to cover.
	 */
	debtToCover?: string;
	/**
	 * Whether to receive a token.
	 */
	receiveAToken?: boolean;
	/**
	 * The input tokens.
	 */
	inputTokens?: Array<TokenAmount>;
	/**
	 * The output tokens.
	 */
	outputTokens?: Array<TokenProportion>;
	/**
	 * The slippage limit percentage.
	 */
	slippageLimitPercent?: number;
	/**
	 * The minimum health factor.
	 */
	minHealthFactor?: string | number;
	/**
	 * The premiums.
	 */
	premiums?: Array<string> | Array<number>;
	/**
	 * The initiator of the transaction.
	 */
	initiator?: string;
	/**
	 * The role of the user.
	 */
	role?: string;
	/**
	 * The account involved in the transaction.
	 */
	account?: string;
	/**
	 * The initial deposit.
	 */
	initialDeposit?: string | number;
	/**
	 * The borrow amount.
	 */
	borrowAmount?: string | number;
	/**
	 * The pool address involved in the transaction (optional).
	 */
	pool?: string;
	/**
	 * The gauge address involved in the transaction (optional).
	 */
	gauge?: string;
	/**
	 * The weights for the pool votes (optional).
	 */
	weights?: Array<string>;
	/**
	 * The pool votes (optional).
	 */
	pool_vote?: Array<string>;
	/**
	 * The type of the gauge (optional).
	 */
	gauge_type?: string;
	/**
	 * The bribes involved in the transaction (optional).
	 */
	bribes?: Array<string>;
	/**
	 * The tokens involved in the transaction (optional).
	 */
	tokens?: Array<Array<string>>;
	/**
	 * The fees involved in the transaction (optional).
	 */
	fees?: Array<string>;
	/**
	 * The gauges involved in the transaction (optional).
	 */
	gauges?: Array<string>;
};

export type Aavev3PoolGetReserveDataData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account identifier.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address of the Aave pool.
		 */
		address: string;
		/**
		 * - The asset for which to retrieve reserve data.
		 */
		asset: string;
		/**
		 * - The blockchain chain ID.
		 */
		chainId: string;
	};
};

export type Aavev3PoolGetReserveDataResponse = AavePoolAPIResponse_any_;

export type Aavev3PoolGetReserveDataError = unknown;

export type Aavev3PoolGetUserAccountDataData = {
	headers: {
		/**
		 * - The authorization token from the header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account identifier from the path.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address from the query parameters.
		 */
		address: string;
		/**
		 * - The chain ID from the query parameters.
		 */
		chainId: string;
		/**
		 * - The user identifier from the query parameters.
		 */
		user: string;
	};
};

export type Aavev3PoolGetUserAccountDataResponse = AavePoolAPIResponse_any_;

export type Aavev3PoolGetUserAccountDataError = unknown;

export type Aavev3PoolSupplyData = {
	/**
	 * - The input body containing details for the supply operation.
	 */
	body: AavePoolInputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the user supplying the assets.
		 */
		address: string;
	};
};

export type Aavev3PoolSupplyResponse =
	AavePoolAPIResponse_AavePoolExecuteFunctionResult_;

export type Aavev3PoolSupplyError = unknown;

export type Aavev3PoolWithdrawData = {
	/**
	 * - The body containing the withdrawal details.
	 */
	body: AavePoolInputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address from which to withdraw assets.
		 */
		address: string;
	};
};

export type Aavev3PoolWithdrawResponse =
	AavePoolAPIResponse_AavePoolExecuteFunctionResult_;

export type Aavev3PoolWithdrawError = unknown;

export type Aavev3PoolBorrowData = {
	/**
	 * - The input body containing details for the borrow operation.
	 */
	body: AavePoolInputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the borrower.
		 */
		address: string;
	};
};

export type Aavev3PoolBorrowResponse =
	AavePoolAPIResponse_AavePoolExecuteFunctionResult_;

export type Aavev3PoolBorrowError = unknown;

export type Aavev3PoolRepayData = {
	/**
	 * - The body of the request containing repayment details.
	 */
	body: AavePoolInputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the borrower.
		 */
		address: string;
	};
};

export type Aavev3PoolRepayResponse =
	AavePoolAPIResponse_AavePoolExecuteFunctionResult_;

export type Aavev3PoolRepayError = unknown;

export type Aavev3PoolSetUserUseReserveAsCollateralData = {
	/**
	 * - The body containing the Aave pool input data.
	 */
	body: AavePoolInputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the user.
		 */
		address: string;
	};
};

export type Aavev3PoolSetUserUseReserveAsCollateralResponse =
	AavePoolAPIResponse_AavePoolExecuteFunctionResult_;

export type Aavev3PoolSetUserUseReserveAsCollateralError = unknown;

export type Aavev3PoolLiquidationCallData = {
	/**
	 * - The body containing the Aave pool input data.
	 */
	body: AavePoolInputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address to be liquidated.
		 */
		address: string;
	};
};

export type Aavev3PoolLiquidationCallResponse =
	AavePoolAPIResponse_AavePoolExecuteFunctionResult_;

export type Aavev3PoolLiquidationCallError = unknown;

export type Aavev3PoolAddressProviderGetAclAdminData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account address to query.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address of the pool address provider.
		 */
		address: string;
		/**
		 * - The chain ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type Aavev3PoolAddressProviderGetAclAdminResponse =
	PoolAddressProviderAPIResponse_string_;

export type Aavev3PoolAddressProviderGetAclAdminError = unknown;

export type Aavev3PoolAddressProviderGetAclManagerData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account path parameter.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address query parameter.
		 */
		address: string;
		/**
		 * - The chain ID query parameter.
		 */
		chainId: string;
	};
};

export type Aavev3PoolAddressProviderGetAclManagerResponse =
	PoolAddressProviderAPIResponse_string_;

export type Aavev3PoolAddressProviderGetAclManagerError = unknown;

export type Aavev3PoolAddressProviderGetAddressData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account path parameter.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address from the query parameters.
		 */
		address: string;
		/**
		 * - The chain ID from the query parameters.
		 */
		chainId: string;
		/**
		 * - The ID from the query parameters.
		 */
		id: string;
	};
};

export type Aavev3PoolAddressProviderGetAddressResponse =
	PoolAddressProviderAPIResponse_string_;

export type Aavev3PoolAddressProviderGetAddressError = unknown;

export type Aavev3PoolAddressProviderGetMarketIdData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account path parameter.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address from the query parameters.
		 */
		address: string;
		/**
		 * - The chain ID from the query parameters.
		 */
		chainId: string;
	};
};

export type Aavev3PoolAddressProviderGetMarketIdResponse =
	PoolAddressProviderAPIResponse_string_;

export type Aavev3PoolAddressProviderGetMarketIdError = unknown;

export type Aavev3PoolAddressProviderGetPoolData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account identifier.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address to query.
		 */
		address: string;
		/**
		 * - The blockchain network identifier.
		 */
		chainId: string;
	};
};

export type Aavev3PoolAddressProviderGetPoolResponse =
	PoolAddressProviderAPIResponse_string_;

export type Aavev3PoolAddressProviderGetPoolError = unknown;

export type Aavev3PoolAddressProviderGetPoolConfiguratorData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account identifier.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address of the pool.
		 */
		address: string;
		/**
		 * - The chain identifier.
		 */
		chainId: string;
	};
};

export type Aavev3PoolAddressProviderGetPoolConfiguratorResponse =
	PoolAddressProviderAPIResponse_string_;

export type Aavev3PoolAddressProviderGetPoolConfiguratorError = unknown;

export type Aavev3PoolAddressProviderGetPriceOracleData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account identifier.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address of the pool address provider.
		 */
		address: string;
		/**
		 * - The blockchain chain identifier.
		 */
		chainId: string;
	};
};

export type Aavev3PoolAddressProviderGetPriceOracleResponse =
	PoolAddressProviderAPIResponse_string_;

export type Aavev3PoolAddressProviderGetPriceOracleError = unknown;

export type Aavev3PoolAddressProviderSetAclAdminData = {
	/**
	 * - The body of the request containing additional parameters.
	 */
	body: PoolAddressProviderInputBody;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address for which the ACL admin is being set.
		 */
		address: string;
	};
};

export type Aavev3PoolAddressProviderSetAclAdminResponse =
	PoolAddressProviderAPIResponse_PoolAddressProviderExecuteFunctionResult_;

export type Aavev3PoolAddressProviderSetAclAdminError = unknown;

export type Aavev3PoolAddressProviderSetAclManagerData = {
	/**
	 * - The input body containing the chain ID and other necessary information.
	 */
	body: PoolAddressProviderInputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the pool address provider.
		 */
		address: string;
	};
};

export type Aavev3PoolAddressProviderSetAclManagerResponse =
	PoolAddressProviderAPIResponse_PoolAddressProviderExecuteFunctionResult_;

export type Aavev3PoolAddressProviderSetAclManagerError = unknown;

export type Aavev3PoolAddressProviderSetAddressData = {
	/**
	 * - The body containing the chain ID and other necessary information.
	 */
	body: PoolAddressProviderInputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address to be set.
		 */
		address: string;
	};
};

export type Aavev3PoolAddressProviderSetAddressResponse =
	PoolAddressProviderAPIResponse_PoolAddressProviderExecuteFunctionResult_;

export type Aavev3PoolAddressProviderSetAddressError = unknown;

export type Aavev3PoolAddressProviderSetMarketIdData = {
	/**
	 * - The input body containing the chain ID and other necessary information.
	 */
	body: PoolAddressProviderInputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the pool address provider.
		 */
		address: string;
	};
};

export type Aavev3PoolAddressProviderSetMarketIdResponse =
	PoolAddressProviderAPIResponse_PoolAddressProviderExecuteFunctionResult_;

export type Aavev3PoolAddressProviderSetMarketIdError = unknown;

export type Aavev3PoolAddressProviderSetPoolConfiguratorImplData = {
	/**
	 * - The body containing the pool address provider input data.
	 */
	body: PoolAddressProviderInputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the pool.
		 */
		address: string;
	};
};

export type Aavev3PoolAddressProviderSetPoolConfiguratorImplResponse =
	PoolAddressProviderAPIResponse_PoolAddressProviderExecuteFunctionResult_;

export type Aavev3PoolAddressProviderSetPoolConfiguratorImplError = unknown;

export type Aavev3PoolAddressProviderSetPoolImplData = {
	/**
	 * - The body containing the pool address provider input data.
	 */
	body: PoolAddressProviderInputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the pool.
		 */
		address: string;
	};
};

export type Aavev3PoolAddressProviderSetPoolImplResponse =
	PoolAddressProviderAPIResponse_PoolAddressProviderExecuteFunctionResult_;

export type Aavev3PoolAddressProviderSetPoolImplError = unknown;

export type Aavev3PoolAddressProviderRegistryGetAddressesProviderData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account identifier.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address of the registry.
		 */
		address: string;
		/**
		 * - The blockchain chain identifier.
		 */
		chainId: string;
	};
};

export type Aavev3PoolAddressProviderRegistryGetAddressesProviderResponse =
	PoolAddressProviderRegistryAPIResponse_string_;

export type Aavev3PoolAddressProviderRegistryGetAddressesProviderError =
	unknown;

export type Aavev3PoolAddressProviderRegistryGetAtokenTotalSupplyData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account address.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address of the pool address provider registry.
		 */
		address: string;
		/**
		 * - The asset for which to get the total supply.
		 */
		asset: string;
		/**
		 * - The chain ID.
		 */
		chainId: string;
	};
};

export type Aavev3PoolAddressProviderRegistryGetAtokenTotalSupplyResponse =
	PoolAddressProviderRegistryAPIResponse_string_;

export type Aavev3PoolAddressProviderRegistryGetAtokenTotalSupplyError =
	unknown;

export type Aavev3PoolAddressProviderRegistryGetAllAtokensData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account identifier.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address to query.
		 */
		address: string;
		/**
		 * - The blockchain chain identifier.
		 */
		chainId: string;
	};
};

export type Aavev3PoolAddressProviderRegistryGetAllAtokensResponse =
	PoolAddressProviderRegistryAPIResponse_any_Array_;

export type Aavev3PoolAddressProviderRegistryGetAllAtokensError = unknown;

export type GetAllReservesTokensData = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetAllReservesTokensResponse =
	PoolAddressProviderRegistryAPIResponse_any_Array_;

export type GetAllReservesTokensError = unknown;

export type Aavev3PoolAddressProviderRegistryGetDebtCeilingData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account identifier.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address of the Pool Address Provider Registry.
		 */
		address: string;
		/**
		 * - The asset for which to retrieve the debt ceiling.
		 */
		asset: string;
		/**
		 * - The blockchain chain identifier.
		 */
		chainId: string;
	};
};

export type Aavev3PoolAddressProviderRegistryGetDebtCeilingResponse =
	PoolAddressProviderRegistryAPIResponse_string_;

export type Aavev3PoolAddressProviderRegistryGetDebtCeilingError = unknown;

export type AavEv3RewardsGetRewardsByAssetData = {
	headers: {
		/**
		 * - Authorization token from the request header
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - Account identifier for the request
		 */
		account: string;
	};
	query: {
		/**
		 * - Contract address
		 */
		address: string;
		/**
		 * - Asset address to query rewards for
		 */
		asset: string;
		/**
		 * - Chain ID to target
		 */
		chainId: string;
	};
};

export type AavEv3RewardsGetRewardsByAssetResponse =
	AAVEv3RewardsAPIResponse_string_Array_;

export type AavEv3RewardsGetRewardsByAssetError = unknown;

export type AavEv3RewardsGetUserRewardsData = {
	headers: {
		/**
		 * - Authorization token from the request header
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - Account identifier for the request
		 */
		account: string;
	};
	query: {
		/**
		 * - Contract address
		 */
		address: string;
		/**
		 * - Array of asset addresses to check rewards for
		 */
		assets: Array<string>;
		/**
		 * - Chain ID to target
		 */
		chainId: string;
		/**
		 * - Reward token address
		 */
		reward: string;
		/**
		 * - User address to check rewards for
		 */
		user: string;
	};
};

export type AavEv3RewardsGetUserRewardsResponse =
	AAVEv3RewardsAPIResponse_string_;

export type AavEv3RewardsGetUserRewardsError = unknown;

export type AavEv3RewardsGetRewardsDataData = {
	headers: {
		/**
		 * - Authorization token from the request header
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - Account identifier for the request
		 */
		account: string;
	};
	query: {
		/**
		 * - Contract address
		 */
		address: string;
		/**
		 * - Asset address to get rewards data for
		 */
		asset: string;
		/**
		 * - Chain ID to target
		 */
		chainId: string;
		/**
		 * - Reward token address
		 */
		reward: string;
	};
};

export type AavEv3RewardsGetRewardsDataResponse =
	AAVEv3RewardsAPIResponse_string_Array_;

export type AavEv3RewardsGetRewardsDataError = unknown;

export type AavEv3RewardsClaimRewardsData = {
	/**
	 * - Input parameters for claiming rewards
	 */
	body: AAVEv3RewardsInputBody;
	headers: {
		/**
		 * - Authorization token from the request header
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - Address claiming the rewards
		 */
		address: string;
	};
};

export type AavEv3RewardsClaimRewardsResponse =
	AAVEv3RewardsAPIResponse_AAVEv3RewardsExecuteFunctionResult_;

export type AavEv3RewardsClaimRewardsError = unknown;

export type AavEv3RewardsClaimRewardsOnBehalfData = {
	/**
	 * - Input parameters for claiming rewards
	 */
	body: AAVEv3RewardsInputBody;
	headers: {
		/**
		 * - Authorization token from the request header
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - Address claiming the rewards
		 */
		address: string;
	};
};

export type AavEv3RewardsClaimRewardsOnBehalfResponse =
	AAVEv3RewardsAPIResponse_AAVEv3RewardsExecuteFunctionResult_;

export type AavEv3RewardsClaimRewardsOnBehalfError = unknown;

export type AavEv3RewardsClaimRewardsToSelfData = {
	/**
	 * - Input parameters for claiming rewards
	 */
	body: AAVEv3RewardsInputBody;
	headers: {
		/**
		 * - Authorization token from the request header
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - Address claiming the rewards
		 */
		address: string;
	};
};

export type AavEv3RewardsClaimRewardsToSelfResponse =
	AAVEv3RewardsAPIResponse_AAVEv3RewardsExecuteFunctionResult_;

export type AavEv3RewardsClaimRewardsToSelfError = unknown;

export type AavEv3RewardsClaimAllRewardsData = {
	/**
	 * - Input parameters for claiming all rewards
	 */
	body: AAVEv3RewardsInputBody;
	headers: {
		/**
		 * - Authorization token from the request header
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - Address claiming the rewards
		 */
		address: string;
	};
};

export type AavEv3RewardsClaimAllRewardsResponse =
	AAVEv3RewardsAPIResponse_AAVEv3RewardsExecuteFunctionResult_;

export type AavEv3RewardsClaimAllRewardsError = unknown;

export type AavEv3RewardsClaimAllRewardsOnBehalfData = {
	/**
	 * - Input parameters for claiming all rewards
	 */
	body: AAVEv3RewardsInputBody;
	headers: {
		/**
		 * - Authorization token from the request header
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - Address claiming the rewards
		 */
		address: string;
	};
};

export type AavEv3RewardsClaimAllRewardsOnBehalfResponse =
	AAVEv3RewardsAPIResponse_AAVEv3RewardsExecuteFunctionResult_;

export type AavEv3RewardsClaimAllRewardsOnBehalfError = unknown;

export type AavEv3RewardsClaimAllRewardsToSelfData = {
	/**
	 * - Input parameters for claiming all rewards
	 */
	body: AAVEv3RewardsInputBody;
	headers: {
		/**
		 * - Authorization token from the request header
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - Address claiming the rewards
		 */
		address: string;
	};
};

export type AavEv3RewardsClaimAllRewardsToSelfResponse =
	AAVEv3RewardsAPIResponse_AAVEv3RewardsExecuteFunctionResult_;

export type AavEv3RewardsClaimAllRewardsToSelfError = unknown;

export type AavEv3IncentiveDataProviderGetFullReservesDataData = {
	headers: {
		/**
		 * - Authorization token from request header
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - Chain ID to target
		 */
		chain_id: string;
		/**
		 * - Address of the incentive data provider contract
		 */
		contract_address: string;
		/**
		 * - Address of the pool address provider
		 */
		provider: string;
		/**
		 * - Address of the user to get incentive data for
		 */
		user: string;
	};
};

export type AavEv3IncentiveDataProviderGetFullReservesDataResponse =
	AAVEv3UiIncentiveDataProviderAPIResponse_FullReservesIncentiveData_;

export type AavEv3IncentiveDataProviderGetFullReservesDataError = unknown;

export type AavEv3IncentiveDataProviderGetReservesDataData = {
	headers: {
		/**
		 * - Authorization token from request header
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - Chain ID to target
		 */
		chain_id: string;
		/**
		 * - Address of the incentive data provider contract
		 */
		contract_address: string;
		/**
		 * - Address of the pool address provider
		 */
		provider: string;
	};
};

export type AavEv3IncentiveDataProviderGetReservesDataResponse =
	AAVEv3UiIncentiveDataProviderAPIResponse_AggregatedReserveIncentiveData_Array_;

export type AavEv3IncentiveDataProviderGetReservesDataError = unknown;

export type AavEv3IncentiveDataProviderGetUserReservesDataData = {
	headers: {
		/**
		 * - Authorization token from request header
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - Chain ID to target
		 */
		chain_id: string;
		/**
		 * - Address of the incentive data provider contract
		 */
		contract_address: string;
		/**
		 * - Address of the pool address provider
		 */
		provider: string;
		/**
		 * - Address of the user to get incentive data for
		 */
		user: string;
	};
};

export type AavEv3IncentiveDataProviderGetUserReservesDataResponse =
	AAVEv3UiIncentiveDataProviderAPIResponse_UserReserveIncentiveData_Array_;

export type AavEv3IncentiveDataProviderGetUserReservesDataError = unknown;

export type AaveV3UiPoolDataProviderEthCurrencyUnitData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The chain ID to query.
		 */
		chain_id: string;
		/**
		 * - The contract address to query.
		 */
		contract_address: string;
	};
};

export type AaveV3UiPoolDataProviderEthCurrencyUnitResponse =
	AAVEv3UiPoolDataProviderAPIResponse_string_;

export type AaveV3UiPoolDataProviderEthCurrencyUnitError = unknown;

export type GetReservesDataData = {
	headers: {
		Authorization: string;
	};
	query: {
		chain_id: string;
		contract_address: string;
		provider: string;
	};
};

export type GetReservesDataResponse =
	AAVEv3UiPoolDataProviderAPIResponse_ReservesData_;

export type GetReservesDataError = unknown;

export type AaveV3UiPoolDataProviderReservesListData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The chain ID to query.
		 */
		chain_id: string;
		/**
		 * - The contract address to query.
		 */
		contract_address: string;
		/**
		 * - The provider to use for querying the reserves list.
		 */
		provider: string;
	};
};

export type AaveV3UiPoolDataProviderReservesListResponse =
	AAVEv3UiPoolDataProviderAPIResponse_string_Array_;

export type AaveV3UiPoolDataProviderReservesListError = unknown;

export type AaveV3UiPoolDataProviderUserReservesDataData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The chain ID where the contract is deployed.
		 */
		chain_id: string;
		/**
		 * - The contract address of the AAVE v3 UI Pool Data Provider.
		 */
		contract_address: string;
		/**
		 * - The provider address.
		 */
		provider: string;
		/**
		 * - The user address whose reserve data is to be fetched.
		 */
		user: string;
	};
};

export type AaveV3UiPoolDataProviderUserReservesDataResponse =
	AAVEv3UiPoolDataProviderAPIResponse_UserReserveData_Array_;

export type AaveV3UiPoolDataProviderUserReservesDataError = unknown;

export type AaveV3UiPoolDataProviderMarketReferenceCurrencyPriceInUsdProxyAggregatorData =
	{
		headers: {
			/**
			 * - The authorization token.
			 */
			Authorization: string;
		};
		query: {
			/**
			 * - The chain ID to query.
			 */
			chain_id: string;
			/**
			 * - The contract address to query.
			 */
			contract_address: string;
		};
	};

export type AaveV3UiPoolDataProviderMarketReferenceCurrencyPriceInUsdProxyAggregatorResponse =
	AAVEv3UiPoolDataProviderAPIResponse_string_;

export type AaveV3UiPoolDataProviderMarketReferenceCurrencyPriceInUsdProxyAggregatorError =
	unknown;

export type AaveV3UiPoolDataProviderNetworkBaseTokenPriceInUsdProxyAggregatorData =
	{
		headers: {
			/**
			 * - The authorization token.
			 */
			Authorization: string;
		};
		query: {
			/**
			 * - The chain ID to query.
			 */
			chain_id: string;
			/**
			 * - The contract address to query.
			 */
			contract_address: string;
		};
	};

export type AaveV3UiPoolDataProviderNetworkBaseTokenPriceInUsdProxyAggregatorResponse =
	AAVEv3UiPoolDataProviderAPIResponse_string_;

export type AaveV3UiPoolDataProviderNetworkBaseTokenPriceInUsdProxyAggregatorError =
	unknown;

export type AaveV3WalletBalanceOfData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The ID of the blockchain network.
		 */
		chain_id: string;
		/**
		 * - The address of the contract to query.
		 */
		contract_address: string;
		/**
		 * - The address of the token to query the balance for.
		 */
		token_address: string;
		/**
		 * - The address of the user whose balance is being queried.
		 */
		user: string;
	};
};

export type AaveV3WalletBalanceOfResponse =
	AAVEv3WalletBalanceProviderAPIResponse_string_;

export type AaveV3WalletBalanceOfError = unknown;

export type AaveV3WalletBatchBalanceOfData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The ID of the blockchain network.
		 */
		chain_id: string;
		/**
		 * - The address of the contract.
		 */
		contract_address: string;
		/**
		 * - An array of token addresses to retrieve balances for.
		 */
		tokens: Array<string>;
		/**
		 * - An array of user addresses to retrieve balances for.
		 */
		users: Array<string>;
	};
};

export type AaveV3WalletBatchBalanceOfResponse =
	AAVEv3WalletBalanceProviderAPIResponse_string_Array_;

export type AaveV3WalletBatchBalanceOfError = unknown;

export type AaveV3WalletUserWalletBalancesData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The chain ID to query.
		 */
		chain_id: string;
		/**
		 * - The contract address to query.
		 */
		contract_address: string;
		/**
		 * - The provider to use for querying balances.
		 */
		provider: string;
		/**
		 * - The user address to query balances for.
		 */
		user: string;
	};
};

export type AaveV3WalletUserWalletBalancesResponse =
	AAVEv3WalletBalanceProviderAPIResponse__tokens_string_Array__balances_string_Array____;

export type AaveV3WalletUserWalletBalancesError = unknown;

export type AccountsCreateEthereumAccountData = {
	/**
	 * - The input data required to create a new account.
	 */
	body: CreateAccountInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type AccountsCreateEthereumAccountResponse = AccountAPIResponse;

export type AccountsCreateEthereumAccountError = unknown;

export type AccountsListEthereumAccountsData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type AccountsListEthereumAccountsResponse = AccountAPIResponse;

export type AccountsListEthereumAccountsError = unknown;

export type AccountsGetEthreumAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to retrieve.
		 */
		accountName: string;
	};
};

export type AccountsGetEthreumAccountResponse = AccountAPIResponse;

export type AccountsGetEthreumAccountError = unknown;

export type AccountsDeleteEthereumAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be deleted.
		 */
		accountName: string;
	};
};

export type AccountsDeleteEthereumAccountResponse = AccountAPIResponse;

export type AccountsDeleteEthereumAccountError = unknown;

export type AccountsEthereumGetNonceData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to retrieve the nonce for.
		 */
		accountName: string;
	};
	query: {
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type AccountsEthereumGetNonceResponse = NonceAPIResponse;

export type AccountsEthereumGetNonceError = unknown;

export type AccountsEthereumGetNativeBalanceData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to retrieve the balance for.
		 */
		accountName: string;
	};
	query: {
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type AccountsEthereumGetNativeBalanceResponse = BalanceAPIResponse;

export type AccountsEthereumGetNativeBalanceError = unknown;

export type AccountsSuggestGasPriceData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account for which to suggest the gas price.
		 */
		accountName: string;
	};
	query: {
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type AccountsSuggestGasPriceResponse = TransactionAPIResponse;

export type AccountsSuggestGasPriceError = unknown;

export type AccountsEstimateGasData = {
	/**
	 * - The input body containing transaction details.
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account for which to estimate gas.
		 */
		accountName: string;
	};
};

export type AccountsEstimateGasResponse = TransactionAPIResponse;

export type AccountsEstimateGasError = unknown;

export type AccountsTransferEthData = {
	/**
	 * - The input body containing transfer details.
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account from which Ethereum will be transferred.
		 */
		accountName: string;
	};
};

export type AccountsTransferEthResponse = TransactionAPIResponse;

export type AccountsTransferEthError = unknown;

export type AccountsSignEthreumMessageData = {
	/**
	 * - The body of the request containing the message to be signed.
	 */
	body: SignMessage;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to sign the message with.
		 */
		accountName: string;
	};
};

export type AccountsSignEthreumMessageResponse = SignMessageAPIResponse;

export type AccountsSignEthreumMessageError = unknown;

export type AccountsSignEthereumTransactionData = {
	/**
	 * - The input body containing transaction details.
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account for which the transaction is to be signed.
		 */
		accountName: string;
	};
};

export type AccountsSignEthereumTransactionResponse = TransactionAPIResponse;

export type AccountsSignEthereumTransactionError = unknown;

export type AccountsExportEthreumAccountData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be exported.
		 */
		accountName: string;
	};
};

export type AccountsExportEthreumAccountResponse = ExportAccountAPIResponse;

export type AccountsExportEthreumAccountError = unknown;

export type AccountsSignEthereumTypedDataData = {
	/**
	 * - The data to be signed.
	 */
	body: SignTypedData;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account for which the data is to be signed.
		 */
		accountName: string;
	};
};

export type AccountsSignEthereumTypedDataResponse = SignMessageAPIResponse;

export type AccountsSignEthereumTypedDataError = unknown;

export type AccountsDeployContractData = {
	/**
	 * - The deployment input data.
	 */
	body: DeployInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to deploy the contract to.
		 */
		accountName: string;
	};
};

export type AccountsDeployContractResponse = TransactionAPIResponse;

export type AccountsDeployContractError = unknown;

export type AccountsBroadcastEthreeumTransactionData = {
	/**
	 * - The transaction details to be broadcasted.
	 */
	body: BroadcastInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to broadcast the transaction from.
		 */
		accountName: string;
	};
};

export type AccountsBroadcastEthreeumTransactionResponse =
	BroadCastRawTransactionAPIResponse;

export type AccountsBroadcastEthreeumTransactionError = unknown;

export type AccountsEncodeAbiDataData = {
	/**
	 * - The input object containing the ABI, function name, and parameters.
	 */
	body: AbiEncodeInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type AccountsEncodeAbiDataResponse = AbiEncodeOutput;

export type AccountsEncodeAbiDataError = unknown;

export type BitcoinListAccountsData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type BitcoinListAccountsResponse = AccountAPIResponse;

export type BitcoinListAccountsError = unknown;

export type BitcoinBitcoinCreateAccountData = {
	/**
	 * - The input data required to create a Bitcoin account.
	 */
	body: BitcoinInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type BitcoinBitcoinCreateAccountResponse = AccountAPIResponse;

export type BitcoinBitcoinCreateAccountError = unknown;

export type BitcoinBitcoinGetAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to retrieve.
		 */
		accountName: string;
	};
};

export type BitcoinBitcoinGetAccountResponse = AccountAPIResponse;

export type BitcoinBitcoinGetAccountError = unknown;

export type BitcoinBitcoinSignTransactionData = {
	/**
	 * - The transaction input details.
	 */
	body: BitcoinTransactionInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to sign the transaction for.
		 */
		accountName: string;
	};
};

export type BitcoinBitcoinSignTransactionResponse = BitcoinAPIResponse;

export type BitcoinBitcoinSignTransactionError = unknown;

export type BitcoinBitcoinCreateSrc20InscriptionData = {
	/**
	 * - The input data for the SRC20 inscription.
	 */
	body: SRC20InscriptionInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account for which the inscription is being created.
		 */
		accountName: string;
	};
};

export type BitcoinBitcoinCreateSrc20InscriptionResponse = BitcoinAPIResponse;

export type BitcoinBitcoinCreateSrc20InscriptionError = unknown;

export type BitcoinBitcoinCreateBrc20TransactionData = {
	/**
	 * - The input data for the BRC20 transaction.
	 */
	body: BRC20TransactionInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account for which the transaction is being created.
		 */
		accountName: string;
	};
};

export type BitcoinBitcoinCreateBrc20TransactionResponse = BitcoinAPIResponse;

export type BitcoinBitcoinCreateBrc20TransactionError = unknown;

export type BitcoinBitcoinGenerateUnsignedPsbtHexData = {
	/**
	 * - The input data required to generate the unsigned PSBT.
	 */
	body: UnsignedPSBTInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account for which to generate the PSBT.
		 */
		accountName: string;
	};
};

export type BitcoinBitcoinGenerateUnsignedPsbtHexResponse = BitcoinAPIResponse;

export type BitcoinBitcoinGenerateUnsignedPsbtHexError = unknown;

export type BitcoinBitcoinExportAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be exported.
		 */
		accountName: string;
	};
};

export type BitcoinBitcoinExportAccountResponse = AccountAPIResponse;

export type BitcoinBitcoinExportAccountError = unknown;

export type BitcoinBitcoinDeleteAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be deleted.
		 */
		accountName: string;
	};
};

export type BitcoinBitcoinDeleteAccountResponse = AccountAPIResponse;

export type BitcoinBitcoinDeleteAccountError = unknown;

export type BitcoinCashListAccountsData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type BitcoinCashListAccountsResponse =
	BitcoinCashAPIResponse_AccountResponse_;

export type BitcoinCashListAccountsError = unknown;

export type BitcoinCashBitcoinCashCreateAccountData = {
	/**
	 * - The input data required to create a Bitcoin Cash account.
	 */
	body: BitcoinCashInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type BitcoinCashBitcoinCashCreateAccountResponse =
	BitcoinCashAPIResponse_AccountResponse_;

export type BitcoinCashBitcoinCashCreateAccountError = unknown;

export type BitcoinCashBitcoinCashGetAccountData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to read.
		 */
		accountName: string;
	};
};

export type BitcoinCashBitcoinCashGetAccountResponse =
	BitcoinCashAPIResponse_AccountResponse_;

export type BitcoinCashBitcoinCashGetAccountError = unknown;

export type BitcoinCashBitcoinCashExportAccountData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to export.
		 */
		accountName: string;
	};
};

export type BitcoinCashBitcoinCashExportAccountResponse =
	BitcoinCashAPIResponse_AccountResponse_;

export type BitcoinCashBitcoinCashExportAccountError = unknown;

export type BitcoinCashBitcoinCashDeleteAccountData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be deleted.
		 */
		accountName: string;
	};
};

export type BitcoinCashBitcoinCashDeleteAccountResponse =
	BitcoinCashAPIResponse_AccountResponse_;

export type BitcoinCashBitcoinCashDeleteAccountError = unknown;

export type BitcoinCashBitcoinCashSignTransactionData = {
	/**
	 * - The transaction input data.
	 */
	body: BitcoinCashTransactionInput;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to sign the transaction for.
		 */
		accountName: string;
	};
};

export type BitcoinCashBitcoinCashSignTransactionResponse =
	BitcoinCashAPIResponse_BitcoinCashTransactionOutput_;

export type BitcoinCashBitcoinCashSignTransactionError = unknown;

export type BitcoinCashBitcoinCashSignTransactionWithMemoData = {
	/**
	 * - The input data for the Bitcoin Cash transaction.
	 */
	body: BitcoinCashTransactionInput;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to sign the transaction for.
		 */
		accountName: string;
	};
};

export type BitcoinCashBitcoinCashSignTransactionWithMemoResponse =
	BitcoinCashAPIResponse_BitcoinCashTransactionOutput_;

export type BitcoinCashBitcoinCashSignTransactionWithMemoError = unknown;

export type BitcoinCashBitcoinCashSignBitcoinTransactionData = {
	/**
	 * - The request body containing the network, inputs, and outputs.
	 */
	body: {
		outputs: string;
		inputs: string;
		network: string;
	};
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to sign the transaction for.
		 */
		accountName: string;
	};
};

export type BitcoinCashBitcoinCashSignBitcoinTransactionResponse =
	BitcoinCashAPIResponse__signed_tx_string__;

export type BitcoinCashBitcoinCashSignBitcoinTransactionError = unknown;

export type BitcoinCashBitcoinCashGenerateUnsignedPsbtHexData = {
	/**
	 * - The input data required to generate the unsigned PSBT.
	 */
	body: UnsignedPSBTInput;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account for which to generate the PSBT.
		 */
		accountName: string;
	};
};

export type BitcoinCashBitcoinCashGenerateUnsignedPsbtHexResponse =
	BitcoinCashAPIResponse__psbt_hex_string__;

export type BitcoinCashBitcoinCashGenerateUnsignedPsbtHexError = unknown;

export type BitcoinCashBitcoinCashSignPsbtWithKeyPathAndScriptPathData = {
	/**
	 * - The request body containing the network and PSBT in hexadecimal format.
	 */
	body: {
		psbt_hex: string;
		network: string;
	};
	headers: {
		/**
		 * - The authorization token for authentication.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to use for signing.
		 */
		accountName: string;
	};
};

export type BitcoinCashBitcoinCashSignPsbtWithKeyPathAndScriptPathResponse =
	BitcoinCashAPIResponse__signed_psbt_hex_string__;

export type BitcoinCashBitcoinCashSignPsbtWithKeyPathAndScriptPathError =
	unknown;

export type ChartsGetChartAnalysisData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The trading view symbol for which the chart analysis is requested.
		 */
		symbol: string;
		/**
		 * - The timeframe for the chart analysis. Defaults to "1D". Can be "1D", "4H", or "1H".
		 */
		timeframe: "1D" | "4H" | "1H";
	};
};

export type ChartsGetChartAnalysisResponse = ChartAnalysisAPIResponse;

export type ChartsGetChartAnalysisError = unknown;

export type ComponentsGetComponentsData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type ComponentsGetComponentsResponse =
	ComponentAPIResponse_ComponentDefinition_Array_;

export type ComponentsGetComponentsError = unknown;

export type ComponentsCreateComponentData = {
	/**
	 * - The component data to be created, excluding the "id" field.
	 */
	body: Omit_ComponentDefinition_id_;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type ComponentsCreateComponentResponse =
	ComponentAPIResponse_ComponentDefinition_;

export type ComponentsCreateComponentError = unknown;

export type ComponentsGetComponentData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ID of the component to retrieve.
		 */
		id: string;
	};
};

export type ComponentsGetComponentResponse =
	ComponentAPIResponse_ComponentDefinition_;

export type ComponentsGetComponentError = unknown;

export type ComponentsUpdateComponentData = {
	/**
	 * The partial component data to be updated.
	 */
	body: Partial_ComponentDefinition_;
	headers: {
		/**
		 * The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * The ID of the component.
		 */
		id: string;
	};
};

export type ComponentsUpdateComponentResponse =
	ComponentAPIResponse_ComponentDefinition_;

export type ComponentsUpdateComponentError = unknown;

export type ComponentsSearchComponentsData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The maximum number of results to return.
		 */
		limit?: string;
		/**
		 * - The query to search for.
		 */
		query: string;
		/**
		 * - The similarity threshold for the search.
		 */
		threshold?: string;
	};
};

export type ComponentsSearchComponentsResponse =
	ComponentAPIResponse_ComponentMatch_Array_;

export type ComponentsSearchComponentsError = unknown;

export type ComponentsUpdateEmbeddingData = {
	/**
	 * - The request body containing the description.
	 */
	body: {
		description: string;
	};
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ID of the component.
		 */
		id: string;
	};
};

export type ComponentsUpdateEmbeddingResponse = ComponentAPIResponse_void_;

export type ComponentsUpdateEmbeddingError = unknown;

export type ComponentsForceEmbeddingData = {
	/**
	 * - The request body containing the description.
	 */
	body: {
		description: string;
	};
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ID of the component.
		 */
		id: string;
	};
};

export type ComponentsForceEmbeddingResponse = ComponentAPIResponse_void_;

export type ComponentsForceEmbeddingError = unknown;

export type ComponentsGetComponentCapabilitiesDescriptionData = {
	headers: {
		/**
		 * - The authorization token provided in the request header.
		 */
		Authorization: string;
	};
};

export type ComponentsGetComponentCapabilitiesDescriptionResponse =
	ComponentAPIResponse_Partial_ComponentDefinition__Array_;

export type ComponentsGetComponentCapabilitiesDescriptionError = unknown;

export type CosmosCosmosListAccountsData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type CosmosCosmosListAccountsResponse = CosmosAccountListAPIResponse;

export type CosmosCosmosListAccountsError = unknown;

export type CosmosCosmosCreateAccountData = {
	/**
	 * - The request body containing optional network information.
	 */
	body: {
		network?: string;
	};
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type CosmosCosmosCreateAccountResponse = CosmosAccountAPIResponse;

export type CosmosCosmosCreateAccountError = unknown;

export type CosmosCosmosGetAccountData = {
	headers: {
		/**
		 * - The authorization token provided in the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to retrieve.
		 */
		accountName: string;
	};
};

export type CosmosCosmosGetAccountResponse = CosmosAccountAPIResponse;

export type CosmosCosmosGetAccountError = unknown;

export type CosmosCosmosDeleteAccountData = {
	headers: {
		/**
		 * - The authorization token provided in the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be deleted.
		 */
		accountName: string;
	};
};

export type CosmosCosmosDeleteAccountResponse = BaseCosmosAPIResponse;

export type CosmosCosmosDeleteAccountError = unknown;

export type CosmosCosmosExportAccountData = {
	headers: {
		/**
		 * - The authorization token provided in the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be exported.
		 */
		accountName: string;
	};
};

export type CosmosCosmosExportAccountResponse = BaseCosmosAPIResponse;

export type CosmosCosmosExportAccountError = unknown;

export type CosmosCosmosSignTransferTransactionData = {
	/**
	 * - The transfer input details required for the transaction.
	 */
	body: CosmosTransferInput;
	headers: {
		/**
		 * - The authorization token provided in the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to sign the transaction for.
		 */
		accountName: string;
	};
};

export type CosmosCosmosSignTransferTransactionResponse =
	CosmosTransactionAPIResponse;

export type CosmosCosmosSignTransferTransactionError = unknown;

export type CosmosCosmosSignMessageData = {
	/**
	 * - The input data required to sign the message.
	 */
	body: CosmosSignMessageInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to sign the message for.
		 */
		accountName: string;
	};
};

export type CosmosCosmosSignMessageResponse = CosmosSignedMessageAPIResponse;

export type CosmosCosmosSignMessageError = unknown;

export type CosmosCosmosSignIbcTransferTransactionData = {
	/**
	 * - The input data for the Cosmos IBC transfer transaction.
	 */
	body: CosmosIBCTransferInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account for which the transaction is being signed.
		 */
		accountName: string;
	};
};

export type CosmosCosmosSignIbcTransferTransactionResponse =
	CosmosTransactionAPIResponse;

export type CosmosCosmosSignIbcTransferTransactionError = unknown;

export type DataGetWalletTokenBalancesData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The wallet address to retrieve the balance for.
		 */
		address: string;
	};
	query: {
		/**
		 * - The blockchain network to query.
		 */
		chain: string;
		/**
		 * - Optional flag to exclude native currency from the balance.
		 */
		excludeNative?: boolean;
	};
};

export type DataGetWalletTokenBalancesResponse = WalletBalanceAPIResponse;

export type DataGetWalletTokenBalancesError = unknown;

export type DataGetWalletTransactionHistoryData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The wallet address to retrieve history for.
		 */
		address: string;
	};
	query: {
		/**
		 * - The blockchain chain to retrieve history from.
		 */
		chain: string;
	};
};

export type DataGetWalletTransactionHistoryResponse = WalletHistoryAPIResponse;

export type DataGetWalletTransactionHistoryError = unknown;

export type DataGetTokensMetadataData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - An array of token addresses to fetch metadata for.
		 */
		addresses: Array<string>;
		/**
		 * - The blockchain network identifier.
		 */
		chain: string;
	};
};

export type DataGetTokensMetadataResponse = TokenMetadataAPIResponse;

export type DataGetTokensMetadataError = unknown;

export type DataGetWalletNfTsData = {
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
	query: {
		chain: string;
	};
};

export type DataGetWalletNfTsResponse = NFTsAPIResponse;

export type DataGetWalletNfTsError = unknown;

export type DataGetUserWalletPortfolioData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The wallet address of the user.
		 */
		address: string;
	};
	query?: {
		/**
		 * - The page number for pagination (default is 1).
		 */
		page?: number;
		/**
		 * - The number of items per page for pagination (default is 100).
		 */
		pageSize?: number;
	};
};

export type DataGetUserWalletPortfolioResponse = PortfolioAPIResponse;

export type DataGetUserWalletPortfolioError = unknown;

export type DataGetPortfolioFetchStatusData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ID of the job to retrieve the status for.
		 */
		jobId: string;
	};
};

export type DataGetPortfolioFetchStatusResponse = PortfolioAPIResponse;

export type DataGetPortfolioFetchStatusError = unknown;

export type DataExecuteCustomSupabaseQueryData = {
	/**
	 * - The query string to be executed.
	 */
	body: string;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
};

export type DataExecuteCustomSupabaseQueryResponse = unknown;

export type DataExecuteCustomSupabaseQueryError = unknown;

export type DogeCoinListAccountsData = {
	headers: {
		/**
		 * - The authorization token for accessing Dogecoin accounts.
		 */
		Authorization: string;
	};
};

export type DogeCoinListAccountsResponse = AccountAPIResponse;

export type DogeCoinListAccountsError = unknown;

export type DogecoinDogeCoinCreateNewAccountData = {
	/**
	 * - The input data required to create a Dogecoin account.
	 */
	body: DogeCoinInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type DogecoinDogeCoinCreateNewAccountResponse = AccountAPIResponse;

export type DogecoinDogeCoinCreateNewAccountError = unknown;

export type DogecoinDogeCoinGetAccountDetailsData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to retrieve.
		 */
		accountName: string;
	};
};

export type DogecoinDogeCoinGetAccountDetailsResponse = AccountAPIResponse;

export type DogecoinDogeCoinGetAccountDetailsError = unknown;

export type DogecoinDogeCoinSignTransactionData = {
	/**
	 * - The transaction input data.
	 */
	body: DogeCoinTransactionInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account for which the transaction is being signed.
		 */
		accountName: string;
	};
};

export type DogecoinDogeCoinSignTransactionResponse = DogeCoinAPIResponse;

export type DogecoinDogeCoinSignTransactionError = unknown;

export type DogecoinDogeCoinExportAccountDetailsData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be exported.
		 */
		accountName: string;
	};
};

export type DogecoinDogeCoinExportAccountDetailsResponse = AccountAPIResponse;

export type DogecoinDogeCoinExportAccountDetailsError = unknown;

export type DogecoinDogeCoinDeleteAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be deleted.
		 */
		accountName: string;
	};
};

export type DogecoinDogeCoinDeleteAccountResponse = AccountAPIResponse;

export type DogecoinDogeCoinDeleteAccountError = unknown;

export type DogecoinDogeCoinSignTransactionWithMemoData = {
	/**
	 * - The transaction input data.
	 */
	body: DogeCoinTransactionInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to sign the transaction for.
		 */
		accountName: string;
	};
};

export type DogecoinDogeCoinSignTransactionWithMemoResponse =
	DogeCoinAPIResponse;

export type DogecoinDogeCoinSignTransactionWithMemoError = unknown;

export type EnsResolveData = {
	/**
	 * - The input data required for ENS resolution.
	 */
	body: EnsResolveInput;
	headers: {
		/**
		 * - The authorization token for accessing the ENS service.
		 */
		Authorization: string;
	};
};

export type EnsResolveResponse2 = EnsResolveAPIResponse;

export type EnsResolveError = unknown;

export type EnsReverseResolveData = {
	/**
	 * - The input data required for ENS reverse resolution.
	 */
	body: ENSReverseResolveInput;
	headers: {
		/**
		 * - The authorization token for accessing the ENS service.
		 */
		Authorization: string;
	};
};

export type EnsReverseResolveResponse = ENSReverseResolveAPIResponse;

export type EnsReverseResolveError = unknown;

export type ListEosAccountsData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type ListEosAccountsResponse = AccountAPIResponse;

export type ListEosAccountsError = unknown;

export type CreateEosAccountData = {
	/**
	 * - The input data required to create the EOS account.
	 */
	body: EosInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type CreateEosAccountResponse = AccountAPIResponse;

export type CreateEosAccountError = unknown;

export type GetEosAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the EOS account to retrieve information for.
		 */
		accountName: string;
	};
};

export type GetEosAccountResponse = AccountAPIResponse;

export type GetEosAccountError = unknown;

export type SignEosTransactionData = {
	/**
	 * - The transaction input data from the request body.
	 */
	body: EosTransactionInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The EOS account name from the request path.
		 */
		accountName: string;
	};
};

export type SignEosTransactionResponse = EosAPIResponse;

export type SignEosTransactionError = unknown;

export type ExportEosAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the EOS account to export.
		 */
		accountName: string;
	};
};

export type ExportEosAccountResponse = AccountAPIResponse;

export type ExportEosAccountError = unknown;

export type DeleteEosAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the EOS account to be deleted.
		 */
		accountName: string;
	};
};

export type DeleteEosAccountResponse = AccountAPIResponse;

export type DeleteEosAccountError = unknown;

export type Erc1155Erc1155BalanceOfData = {
	/**
	 * - The request body containing ERC1155 parameters
	 */
	body: Erc1155Request;
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name identifier for the request
		 */
		name: string;
	};
};

export type Erc1155Erc1155BalanceOfResponse = TransactionAPIResponse;

export type Erc1155Erc1155BalanceOfError = unknown;

export type Erc1155Erc1155BalanceOfBatchData = {
	/**
	 * - The request body containing arrays of accounts and token IDs
	 */
	body: Erc1155Request;
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name identifier for the request
		 */
		name: string;
	};
};

export type Erc1155Erc1155BalanceOfBatchResponse = TransactionAPIResponse;

export type Erc1155Erc1155BalanceOfBatchError = unknown;

export type Erc1155Erc1155SetApprovalForAllData = {
	/**
	 * - The request body containing operator address and approval status
	 */
	body: Erc1155Request;
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name identifier for the request
		 */
		name: string;
	};
};

export type Erc1155Erc1155SetApprovalForAllResponse = TransactionAPIResponse;

export type Erc1155Erc1155SetApprovalForAllError = unknown;

export type Erc1155Erc1155IsApprovedForAllData = {
	/**
	 * - The request body containing owner and operator addresses
	 */
	body: Erc1155Request;
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name identifier for the request
		 */
		name: string;
	};
};

export type Erc1155Erc1155IsApprovedForAllResponse = TransactionAPIResponse;

export type Erc1155Erc1155IsApprovedForAllError = unknown;

export type Erc1155Erc1155SafeTransferFromData = {
	/**
	 * - The request body containing transfer details
	 */
	body: Erc1155Request;
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name identifier for the request
		 */
		name: string;
	};
};

export type Erc1155Erc1155SafeTransferFromResponse = TransactionAPIResponse;

export type Erc1155Erc1155SafeTransferFromError = unknown;

export type Erc1155Erc1155SafeBatchTransferFromData = {
	/**
	 * - The request body containing batch transfer details
	 */
	body: Erc1155Request;
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name identifier for the request
		 */
		name: string;
	};
};

export type Erc1155Erc1155SafeBatchTransferFromResponse =
	TransactionAPIResponse;

export type Erc1155Erc1155SafeBatchTransferFromError = unknown;

export type Erc20GetErc20TokenDecimalsData = {
	headers: {
		/**
		 * - The authorization token for accessing the ERC20 token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account address for the ERC20 token.
		 */
		account: string;
	};
	query: {
		/**
		 * - The contract address for the ERC20 token.
		 */
		address: string;
		/**
		 * - The chain ID for the ERC20 token.
		 */
		chainId: string;
	};
};

export type Erc20GetErc20TokenDecimalsResponse = ERC20APIResponse_number_;

export type Erc20GetErc20TokenDecimalsError = unknown;

export type Erc20GetErc20TokenSymbolData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account address.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address of the ERC20 token contract.
		 */
		address: string;
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type Erc20GetErc20TokenSymbolResponse = ERC20APIResponse_string_;

export type Erc20GetErc20TokenSymbolError = unknown;

export type Erc20GetErc20TokenNameData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account address.
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC20 token contract address.
		 */
		address: string;
		/**
		 * - The blockchain chain ID.
		 */
		chainId: string;
	};
};

export type Erc20GetErc20TokenNameResponse = ERC20APIResponse_string_;

export type Erc20GetErc20TokenNameError = unknown;

export type Erc20GetErc20TokenTotalSupplyData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account address.
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC20 token contract address.
		 */
		address: string;
		/**
		 * - The blockchain chain ID.
		 */
		chainId: string;
	};
};

export type Erc20GetErc20TokenTotalSupplyResponse = ERC20APIResponse_string_;

export type Erc20GetErc20TokenTotalSupplyError = unknown;

export type Erc20GetErc20TokenBalanceData = {
	headers: {
		/**
		 * - The authorization token for accessing the ERC20 instance.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the account to retrieve the balance for.
		 */
		account: string;
	};
	query: {
		/**
		 * - The address of the ERC20 token contract.
		 */
		address: string;
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type Erc20GetErc20TokenBalanceResponse = ERC20APIResponse_string_;

export type Erc20GetErc20TokenBalanceError = unknown;

export type Erc20GetErc20TokenAllowanceData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account address making the request.
		 */
		account: string;
	};
	query: {
		/**
		 * - The contract address of the ERC20 token.
		 */
		address: string;
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: string;
		/**
		 * - The address of the token owner.
		 */
		owner: string;
		/**
		 * - The address of the spender.
		 */
		spender: string;
	};
};

export type Erc20GetErc20TokenAllowanceResponse = ERC20APIResponse_string_;

export type Erc20GetErc20TokenAllowanceError = unknown;

export type Erc20ApproveErc20TokenSpendingData = {
	/**
	 * - The body of the request containing contract address and chain ID.
	 */
	body: ERC20InputBody;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address to be approved.
		 */
		address: string;
	};
};

export type Erc20ApproveErc20TokenSpendingResponse =
	ERC20APIResponse_ERC20ExecuteFunctionResult_;

export type Erc20ApproveErc20TokenSpendingError = unknown;

export type Erc20TransferErc20TokenData = {
	/**
	 * - The body of the request containing transfer details.
	 */
	body: ERC20InputBody;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address to transfer tokens to.
		 */
		address: string;
	};
};

export type Erc20TransferErc20TokenResponse =
	ERC20APIResponse_ERC20ExecuteFunctionResult_;

export type Erc20TransferErc20TokenError = unknown;

export type Erc20TransferFromErc20TokenData = {
	/**
	 * - The body containing the contract address and chain ID.
	 */
	body: ERC20InputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address from which the tokens will be transferred.
		 */
		address: string;
	};
};

export type Erc20TransferFromErc20TokenResponse =
	ERC20APIResponse_ERC20ExecuteFunctionResult_;

export type Erc20TransferFromErc20TokenError = unknown;

export type Erc4626GetErc4626AssetData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
	};
};

export type Erc4626GetErc4626AssetResponse = ERC4626APIResponse;

export type Erc4626GetErc4626AssetError = unknown;

export type Erc4626GetErc4626TotalAssetsData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
	};
};

export type Erc4626GetErc4626TotalAssetsResponse = ERC4626APIResponse;

export type Erc4626GetErc4626TotalAssetsError = unknown;

export type Erc4626GetErc4626ConvertToSharesData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The amount of assets to deposit
		 */
		assets: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
	};
};

export type Erc4626GetErc4626ConvertToSharesResponse = ERC4626APIResponse;

export type Erc4626GetErc4626ConvertToSharesError = unknown;

export type Erc4626GetErc4626ConvertToAssetsData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
		/**
		 * - The amount of shares to redeem
		 */
		shares: string;
	};
};

export type Erc4626GetErc4626ConvertToAssetsResponse = ERC4626APIResponse;

export type Erc4626GetErc4626ConvertToAssetsError = unknown;

export type Erc4626GetErc4626MaxDepositData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
		/**
		 * - The address of the receiver
		 */
		receiver: string;
	};
};

export type Erc4626GetErc4626MaxDepositResponse = ERC4626APIResponse;

export type Erc4626GetErc4626MaxDepositError = unknown;

export type Erc4626DepositToErc4626Data = {
	/**
	 * - The input body containing the contract address, chain ID, and amount
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the receiver
		 */
		address: string;
	};
};

export type Erc4626DepositToErc4626Response = ERC4626APIResponse;

export type Erc4626DepositToErc4626Error = unknown;

export type Erc4626WithdrawFromErc4626Data = {
	/**
	 * - The input body containing the contract address, chain ID, and amount
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the receiver
		 */
		address: string;
	};
};

export type Erc4626WithdrawFromErc4626Response = ERC4626APIResponse;

export type Erc4626WithdrawFromErc4626Error = unknown;

export type Erc4626GetErc4626MaxMintData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
		/**
		 * - The address of the receiver
		 */
		receiver: string;
	};
};

export type Erc4626GetErc4626MaxMintResponse = ERC4626APIResponse;

export type Erc4626GetErc4626MaxMintError = unknown;

export type Erc4626GetErc4626MaxWithdrawData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
		/**
		 * - The address of the owner
		 */
		owner: string;
	};
};

export type Erc4626GetErc4626MaxWithdrawResponse = ERC4626APIResponse;

export type Erc4626GetErc4626MaxWithdrawError = unknown;

export type Erc4626GetErc4626MaxRedeemData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
		/**
		 * - The address of the owner
		 */
		owner: string;
	};
};

export type Erc4626GetErc4626MaxRedeemResponse = ERC4626APIResponse;

export type Erc4626GetErc4626MaxRedeemError = unknown;

export type Erc4626GetErc4626PreviewDepositData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The amount of assets to deposit
		 */
		assets: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
	};
};

export type Erc4626GetErc4626PreviewDepositResponse = ERC4626APIResponse;

export type Erc4626GetErc4626PreviewDepositError = unknown;

export type Erc4626GetErc4626PreviewMintData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
		/**
		 * - The amount of shares to mint
		 */
		shares: string;
	};
};

export type Erc4626GetErc4626PreviewMintResponse = ERC4626APIResponse;

export type Erc4626GetErc4626PreviewMintError = unknown;

export type Erc4626GetErc4626PreviewWithdrawData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The amount of assets to withdraw
		 */
		assets: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
	};
};

export type Erc4626GetErc4626PreviewWithdrawResponse = ERC4626APIResponse;

export type Erc4626GetErc4626PreviewWithdrawError = unknown;

export type Erc4626GetErc4626PreviewRedeemData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
		/**
		 * - The amount of shares to redeem
		 */
		shares: string;
	};
};

export type Erc4626GetErc4626PreviewRedeemResponse = ERC4626APIResponse;

export type Erc4626GetErc4626PreviewRedeemError = unknown;

export type Erc4626MintErc4626SharesData = {
	/**
	 * - The input body containing the contract address, chain ID, and amount
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the receiver
		 */
		address: string;
	};
};

export type Erc4626MintErc4626SharesResponse = ERC4626APIResponse;

export type Erc4626MintErc4626SharesError = unknown;

export type Erc4626RedeemErc4626SharesData = {
	/**
	 * - The input body containing the contract address, chain ID, and amount
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the receiver
		 */
		address: string;
	};
};

export type Erc4626RedeemErc4626SharesResponse = ERC4626APIResponse;

export type Erc4626RedeemErc4626SharesError = unknown;

export type Erc4626GetErc4626TotalSupplyData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
	};
};

export type Erc4626GetErc4626TotalSupplyResponse = ERC4626APIResponse;

export type Erc4626GetErc4626TotalSupplyError = unknown;

export type Erc4626GetErc4626BalanceOfData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
	};
};

export type Erc4626GetErc4626BalanceOfResponse = ERC4626APIResponse;

export type Erc4626GetErc4626BalanceOfError = unknown;

export type Erc4626GetErc4626AllowanceData = {
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account making the request
		 */
		account: string;
	};
	query: {
		/**
		 * - The ERC4626 vault contract address
		 */
		address: string;
		/**
		 * - The blockchain network ID
		 */
		chainId: string;
		/**
		 * - The address of the owner
		 */
		owner: string;
		/**
		 * - The address of the spender
		 */
		spender: string;
	};
};

export type Erc4626GetErc4626AllowanceResponse = ERC4626APIResponse;

export type Erc4626GetErc4626AllowanceError = unknown;

export type Erc4626ApproveErc4626Data = {
	/**
	 * - The input body containing the contract address, chain ID, and amount
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the spender
		 */
		address: string;
	};
};

export type Erc4626ApproveErc4626Response = ERC4626APIResponse;

export type Erc4626ApproveErc4626Error = unknown;

export type Erc4626TransferErc4626Data = {
	/**
	 * - The input body containing the contract address, chain ID, and amount
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the receiver
		 */
		address: string;
	};
};

export type Erc4626TransferErc4626Response = ERC4626APIResponse;

export type Erc4626TransferErc4626Error = unknown;

export type Erc4626TransferFromErc4626Data = {
	/**
	 * - The input body containing the contract address, chain ID, and amount
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the receiver
		 */
		address: string;
	};
};

export type Erc4626TransferFromErc4626Response = ERC4626APIResponse;

export type Erc4626TransferFromErc4626Error = unknown;

export type Erc721GetErc721BalanceOfData = {
	headers: {
		/**
		 * - The authorization token for accessing the ERC721 instance.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account address to query the balance for.
		 */
		account: string;
	};
	query: {
		/**
		 * - The contract address of the ERC721 token.
		 */
		address: string;
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type Erc721GetErc721BalanceOfResponse = ERC721APIResponse;

export type Erc721GetErc721BalanceOfError = unknown;

export type Erc721GetErc721OwnerOfData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ID of the token to query.
		 */
		tokenId: string;
	};
	query: {
		/**
		 * - The address of the ERC721 contract.
		 */
		address: string;
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type Erc721GetErc721OwnerOfResponse = ERC721APIResponse;

export type Erc721GetErc721OwnerOfError = unknown;

export type Erc721GetErc721NameData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The address of the ERC721 contract.
		 */
		address: string;
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type Erc721GetErc721NameResponse = ERC721APIResponse;

export type Erc721GetErc721NameError = unknown;

export type Erc721GetErc721SymbolData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The address of the ERC721 contract.
		 */
		address: string;
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type Erc721GetErc721SymbolResponse = ERC721APIResponse;

export type Erc721GetErc721SymbolError = unknown;

export type Erc721GetErc721TokenUriData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ID of the token to retrieve the URI for.
		 */
		tokenId: string;
	};
	query: {
		/**
		 * - The address of the ERC721 contract.
		 */
		address: string;
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type Erc721GetErc721TokenUriResponse = ERC721APIResponse;

export type Erc721GetErc721TokenUriError = unknown;

export type Erc721GetErc721ApprovedData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ID of the token to check approval for.
		 */
		tokenId: string;
	};
	query: {
		/**
		 * - The address of the ERC721 contract.
		 */
		address: string;
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type Erc721GetErc721ApprovedResponse = ERC721APIResponse;

export type Erc721GetErc721ApprovedError = unknown;

export type Erc721GetErc721IsApprovedForAllData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the operator to check for approval.
		 */
		operator: string;
		/**
		 * - The address of the owner of the assets.
		 */
		owner: string;
	};
	query: {
		/**
		 * - The address of the ERC721 contract.
		 */
		address: string;
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type Erc721GetErc721IsApprovedForAllResponse = ERC721APIResponse;

export type Erc721GetErc721IsApprovedForAllError = unknown;

export type Erc721ApproveErc721Data = {
	/**
	 * - The request body containing contract address and chain ID.
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address to approve the token for.
		 */
		address: string;
	};
};

export type Erc721ApproveErc721Response = ERC721APIResponse;

export type Erc721ApproveErc721Error = unknown;

export type Erc721SetApprovalForAllErc721Data = {
	/**
	 * - The request body containing contract address and chain ID.
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address to set approval for.
		 */
		address: string;
	};
};

export type Erc721SetApprovalForAllErc721Response = ERC721APIResponse;

export type Erc721SetApprovalForAllErc721Error = unknown;

export type Erc721TransferFromErc721Data = {
	/**
	 * - The input body containing the contract address and chain ID.
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address from which the token is being transferred.
		 */
		address: string;
	};
};

export type Erc721TransferFromErc721Response = ERC721APIResponse;

export type Erc721TransferFromErc721Error = unknown;

export type Erc721SafeTransferFromErc721Data = {
	/**
	 * - The request body containing the contract address and chain ID.
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address from which the token is being transferred.
		 */
		address: string;
	};
};

export type Erc721SafeTransferFromErc721Response = ERC721APIResponse;

export type Erc721SafeTransferFromErc721Error = unknown;

export type Erc721SafeTransferFromWithDataErc721Data = {
	/**
	 * - The input body containing the contract address and chain ID.
	 */
	body: InputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address to transfer the token to.
		 */
		address: string;
	};
};

export type Erc721SafeTransferFromWithDataErc721Response = ERC721APIResponse;

export type Erc721SafeTransferFromWithDataErc721Error = unknown;

export type FinancialDatasetsGetCompanyFactsData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ticker symbol of the company.
		 */
		ticker: string;
	};
};

export type FinancialDatasetsGetCompanyFactsResponse = CompanyFactsAPIResponse;

export type FinancialDatasetsGetCompanyFactsError = unknown;

export type FinancialDatasetsGetIncomeStatementsData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ticker symbol of the company.
		 */
		ticker: string;
	};
	query: {
		/**
		 * - The CIK number of the company.
		 */
		cik?: string;
		/**
		 * - The maximum number of income statements to return.
		 */
		limit?: number;
		/**
		 * - The period type of the income statements.
		 */
		period: "annual" | "quarterly" | "ttm";
	};
};

export type FinancialDatasetsGetIncomeStatementsResponse =
	IncomeStatementsAPIResponse;

export type FinancialDatasetsGetIncomeStatementsError = unknown;

export type FinancialDatasetsGetBalanceSheetsData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ticker symbol of the company.
		 */
		ticker: string;
	};
	query: {
		/**
		 * - The CIK number of the company.
		 */
		cik?: string;
		/**
		 * - The maximum number of balance sheets to return.
		 */
		limit?: number;
		/**
		 * - The period type of the balance sheets.
		 */
		period: "annual" | "quarterly" | "ttm";
	};
};

export type FinancialDatasetsGetBalanceSheetsResponse =
	BalanceSheetsAPIResponse;

export type FinancialDatasetsGetBalanceSheetsError = unknown;

export type FinancialDatasetsGetCashFlowStatementsData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ticker symbol of the company.
		 */
		ticker: string;
	};
	query: {
		/**
		 * - The CIK number of the company.
		 */
		cik?: string;
		/**
		 * - The maximum number of cash flow statements to return.
		 */
		limit?: number;
		/**
		 * - The period type of the cash flow statements.
		 */
		period: "annual" | "quarterly" | "ttm";
	};
};

export type FinancialDatasetsGetCashFlowStatementsResponse =
	CashFlowStatementsAPIResponse;

export type FinancialDatasetsGetCashFlowStatementsError = unknown;

export type FinancialDatasetsGetSegmentedRevenuesData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ticker symbol of the company.
		 */
		ticker: string;
	};
	query: {
		/**
		 * - The CIK number of the company.
		 */
		cik?: string;
		/**
		 * - The maximum number of segmented revenues to return.
		 */
		limit?: number;
		/**
		 * - The period type of the segmented revenues.
		 */
		period: "annual" | "quarterly";
	};
};

export type FinancialDatasetsGetSegmentedRevenuesResponse =
	SegmentedRevenuesAPIResponse;

export type FinancialDatasetsGetSegmentedRevenuesError = unknown;

export type FinancialDatasetsGetAllFinancialsData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ticker symbol of the company.
		 */
		ticker: string;
	};
	query: {
		/**
		 * - The CIK number of the company.
		 */
		cik?: string;
		/**
		 * - The maximum number of financials to return.
		 */
		limit?: number;
		/**
		 * - The period type of the financials.
		 */
		period: "annual" | "quarterly" | "ttm";
	};
};

export type FinancialDatasetsGetAllFinancialsResponse =
	AllFinancialsAPIResponse;

export type FinancialDatasetsGetAllFinancialsError = unknown;

export type FinancialDatasetsGetAvailableTickersData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
};

export type FinancialDatasetsGetAvailableTickersResponse =
	AvailableTickersAPIResponse;

export type FinancialDatasetsGetAvailableTickersError = unknown;

export type FinancialDatasetsGetInsiderTransactionsData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ticker symbol of the company.
		 */
		ticker: string;
	};
	query?: {
		/**
		 * - The maximum number of insider transactions to return.
		 */
		limit?: number;
	};
};

export type FinancialDatasetsGetInsiderTransactionsResponse =
	InsiderTransactionsAPIResponse;

export type FinancialDatasetsGetInsiderTransactionsError = unknown;

export type FinancialDatasetsGetOptionsChainData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ticker symbol of the company.
		 */
		ticker: string;
	};
	query?: {
		/**
		 * - The expiration date of the options.
		 */
		expiration_date?: string;
		/**
		 * - The type of option (call or put).
		 */
		option_type?: "call" | "put";
		/**
		 * - The strike price of the options.
		 */
		strike_price?: number;
	};
};

export type FinancialDatasetsGetOptionsChainResponse = OptionsChainAPIResponse;

export type FinancialDatasetsGetOptionsChainError = unknown;

export type FinancialDatasetsGetPricesData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ticker symbol of the company.
		 */
		ticker: string;
	};
	query: {
		/**
		 * - The end date of the price data.
		 */
		end_date: string;
		/**
		 * - The interval of the price data.
		 */
		interval: PriceInterval;
		/**
		 * - The interval multiplier of the price data.
		 */
		interval_multiplier: number;
		/**
		 * - The maximum number of price data to return.
		 */
		limit?: number;
		/**
		 * - The start date of the price data.
		 */
		start_date: string;
	};
};

export type FinancialDatasetsGetPricesResponse = PricesAPIResponse;

export type FinancialDatasetsGetPricesError = unknown;

export type FinancialDatasetsSearchFinancialsData = {
	/**
	 * - The search request.
	 */
	body: SearchRequest;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
};

export type FinancialDatasetsSearchFinancialsResponse =
	SearchFinancialsAPIResponse;

export type FinancialDatasetsSearchFinancialsError = unknown;

export type FinancialDatasetsGetPriceSnapshotData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The ticker symbol of the company.
		 */
		ticker: string;
	};
};

export type FinancialDatasetsGetPriceSnapshotResponse =
	PriceSnapshotAPIResponse;

export type FinancialDatasetsGetPriceSnapshotError = unknown;

export type FinancialDatasetsSearchFinancialsByLineItemsData = {
	/**
	 * - The search request.
	 */
	body: {
		limit?: number;
		period?: "annual" | "quarterly" | "ttm";
		tickers: Array<string>;
		line_items: Array<string>;
	};
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
};

export type FinancialDatasetsSearchFinancialsByLineItemsResponse =
	LineItemsSearchAPIResponse;

export type FinancialDatasetsSearchFinancialsByLineItemsError = unknown;

export type JupiterGetProgramIdToLabelData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
};

export type JupiterGetProgramIdToLabelResponse =
	JupiterAPIResponse_Record_string_string__;

export type JupiterGetProgramIdToLabelError = unknown;

export type JupiterGetIndexedRouteMapData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	query?: {
		/**
		 * - A boolean value indicating whether to only include direct routes in the map.
		 */
		onlyDirectRoutes?: boolean;
	};
};

export type JupiterGetIndexedRouteMapResponse = JupiterAPIResponse_any_;

export type JupiterGetIndexedRouteMapError = unknown;

export type JupiterGetTokensData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
};

export type JupiterGetTokensResponse = JupiterAPIResponse_string_Array_;

export type JupiterGetTokensError = unknown;

export type JupiterGetQuoteData = {
	/**
	 * - The input body for the Jupiter swap operation, excluding the account name.
	 */
	body: Omit_JupiterInputBody_accountName_;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to perform the swap for.
		 */
		accountName: string;
	};
};

export type JupiterGetQuoteResponse =
	JupiterAPIResponse_JupiterExecuteFunctionResult_;

export type JupiterGetQuoteError = unknown;

export type JupiterSwapData = {
	/**
	 * - The input body for the Jupiter swap operation, excluding the account name.
	 */
	body: Omit_JupiterInputBody_accountName_;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to perform the swap for.
		 */
		accountName: string;
	};
};

export type JupiterSwapResponse =
	JupiterAPIResponse_JupiterExecuteFunctionResult_;

export type JupiterSwapError = unknown;

export type JupiterGetSwapInstructionsData = {
	/**
	 * - The body of the request, omitting the account name.
	 */
	body: Omit_JupiterInputBody_accountName_;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account for which to retrieve swap instructions.
		 */
		accountName: string;
	};
};

export type JupiterGetSwapInstructionsResponse =
	JupiterAPIResponse_JupiterExecuteFunctionResult_;

export type JupiterGetSwapInstructionsError = unknown;

export type LendingPoolGetFlashLoanPremiumTotalData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The address of the lending pool.
		 */
		address: string;
		/**
		 * - The chain ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type LendingPoolGetFlashLoanPremiumTotalResponse =
	LendingPoolAPIResponse_number_;

export type LendingPoolGetFlashLoanPremiumTotalError = unknown;

export type LendingPoolGetLendingPoolRevisionData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The address of the lending pool.
		 */
		address: string;
		/**
		 * - The chain ID where the lending pool is located.
		 */
		chainId: string;
	};
};

export type LendingPoolGetLendingPoolRevisionResponse =
	LendingPoolAPIResponse_number_;

export type LendingPoolGetLendingPoolRevisionError = unknown;

export type LendingPoolGetMaxNumberReservesData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The address of the lending pool.
		 */
		address: string;
		/**
		 * - The chain ID where the lending pool is located.
		 */
		chainId: string;
	};
};

export type LendingPoolGetMaxNumberReservesResponse =
	LendingPoolAPIResponse_number_;

export type LendingPoolGetMaxNumberReservesError = unknown;

export type LendingPoolGetMaxStableRateBorrowSizePercentData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The address of the lending pool.
		 */
		address: string;
		/**
		 * - The chain ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type LendingPoolGetMaxStableRateBorrowSizePercentResponse =
	LendingPoolAPIResponse_number_;

export type LendingPoolGetMaxStableRateBorrowSizePercentError = unknown;

export type LendingPoolBorrowData = {
	/**
	 * - The body of the request containing lending pool input details.
	 */
	body: LendingPoolInputBody;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account requesting the borrow.
		 */
		accountName: string;
	};
};

export type LendingPoolBorrowResponse =
	LendingPoolAPIResponse_LendingPoolExecuteFunctionResult_;

export type LendingPoolBorrowError = unknown;

export type LendingPoolDepositData = {
	/**
	 * - The body of the request containing deposit details.
	 */
	body: LendingPoolInputBody;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account making the deposit.
		 */
		accountName: string;
	};
};

export type LendingPoolDepositResponse =
	LendingPoolAPIResponse_LendingPoolExecuteFunctionResult_;

export type LendingPoolDepositError = unknown;

export type LendingPoolFlashLoanData = {
	/**
	 * - The input body containing details for the flash loan.
	 */
	body: LendingPoolInputBody;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account requesting the flash loan.
		 */
		accountName: string;
	};
};

export type LendingPoolFlashLoanResponse =
	LendingPoolAPIResponse_LendingPoolExecuteFunctionResult_;

export type LendingPoolFlashLoanError = unknown;

export type LendingPoolRepayData = {
	/**
	 * - The body containing the lending pool input details.
	 */
	body: LendingPoolInputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to repay the loan for.
		 */
		accountName: string;
	};
};

export type LendingPoolRepayResponse =
	LendingPoolAPIResponse_LendingPoolExecuteFunctionResult_;

export type LendingPoolRepayError = unknown;

export type LendingPoolSwapBorrowRateModeData = {
	/**
	 * - The input body containing the contract address and chain ID.
	 */
	body: LendingPoolInputBody;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account for which the borrow rate mode is to be swapped.
		 */
		accountName: string;
	};
};

export type LendingPoolSwapBorrowRateModeResponse =
	LendingPoolAPIResponse_LendingPoolExecuteFunctionResult_;

export type LendingPoolSwapBorrowRateModeError = unknown;

export type LendingPoolSetUserUseReserveAsCollateralData = {
	/**
	 * - The body containing lending pool input data.
	 */
	body: LendingPoolInputBody;
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the user's account.
		 */
		accountName: string;
	};
};

export type LendingPoolSetUserUseReserveAsCollateralResponse =
	LendingPoolAPIResponse_LendingPoolExecuteFunctionResult_;

export type LendingPoolSetUserUseReserveAsCollateralError = unknown;

export type LendingPoolLiquidationCallData = {
	/**
	 * - The body of the request containing necessary parameters.
	 */
	body: LendingPoolInputBody;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be liquidated.
		 */
		accountName: string;
	};
};

export type LendingPoolLiquidationCallResponse =
	LendingPoolAPIResponse_LendingPoolExecuteFunctionResult_;

export type LendingPoolLiquidationCallError = unknown;

export type LendingPoolGetReserveDataData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The address of the lending pool.
		 */
		address: string;
		/**
		 * - The asset for which to retrieve reserve data.
		 */
		asset: string;
		/**
		 * - The chain ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type LendingPoolGetReserveDataResponse = LendingPoolAPIResponse_any_;

export type LendingPoolGetReserveDataError = unknown;

export type LendingPoolGetUserAccountDataData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The address of the lending pool.
		 */
		address: string;
		/**
		 * - The chain ID of the blockchain network.
		 */
		chainId: string;
		/**
		 * - The user address for which to retrieve account data.
		 */
		user: string;
	};
};

export type LendingPoolGetUserAccountDataResponse = LendingPoolAPIResponse_any_;

export type LendingPoolGetUserAccountDataError = unknown;

export type LendingPoolGetReservesListData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The address of the lending pool.
		 */
		address: string;
		/**
		 * - The chain ID of the blockchain network.
		 */
		chainId: string;
	};
};

export type LendingPoolGetReservesListResponse =
	LendingPoolAPIResponse_string_Array_;

export type LendingPoolGetReservesListError = unknown;

export type LendingPoolGetAddressesProviderData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The address query parameter.
		 */
		address: string;
		/**
		 * - The chain ID query parameter.
		 */
		chainId: string;
	};
};

export type LendingPoolGetAddressesProviderResponse =
	LendingPoolAPIResponse_string_;

export type LendingPoolGetAddressesProviderError = unknown;

export type LendingPoolIsPausedData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The address of the lending pool from the query parameters.
		 */
		address: string;
		/**
		 * - The chain ID of the lending pool from the query parameters.
		 */
		chainId: string;
	};
};

export type LendingPoolIsPausedResponse = LendingPoolAPIResponse_boolean_;

export type LendingPoolIsPausedError = unknown;

export type LeveragerGetAddressesProviderData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type LeveragerGetAddressesProviderResponse =
	LeveragerAPIResponse_string_;

export type LeveragerGetAddressesProviderError = unknown;

export type LeveragerGetDefaultAdminRoleData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type LeveragerGetDefaultAdminRoleResponse = LeveragerAPIResponse_string_;

export type LeveragerGetDefaultAdminRoleError = unknown;

export type LeveragerGetLendingPoolData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type LeveragerGetLendingPoolResponse = LeveragerAPIResponse_string_;

export type LeveragerGetLendingPoolError = unknown;

export type LeveragerGetMinHfData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type LeveragerGetMinHfResponse = LeveragerAPIResponse_string_;

export type LeveragerGetMinHfError = unknown;

export type LeveragerIsPausedData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type LeveragerIsPausedResponse = LeveragerAPIResponse_boolean_;

export type LeveragerIsPausedError = unknown;

export type LeveragerGetWethData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type LeveragerGetWethResponse = LeveragerAPIResponse_string_;

export type LeveragerGetWethError = unknown;

export type LeveragerGetRoleAdminData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		role: string;
	};
};

export type LeveragerGetRoleAdminResponse = LeveragerAPIResponse_string_;

export type LeveragerGetRoleAdminError = unknown;

export type LeveragerHasRoleData = {
	headers: {
		Authorization: string;
	};
	query: {
		account: string;
		address: string;
		chainId: string;
		role: string;
	};
};

export type LeveragerHasRoleResponse = LeveragerAPIResponse_boolean_;

export type LeveragerHasRoleError = unknown;

export type LeveragerSupportsInterfaceData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		interfaceId: string;
	};
};

export type LeveragerSupportsInterfaceResponse = LeveragerAPIResponse_boolean_;

export type LeveragerSupportsInterfaceError = unknown;

export type LeveragerDeleverageErc20Data = {
	body: LeveragerInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type LeveragerDeleverageErc20Response =
	LeveragerAPIResponse_LeveragerExecuteFunctionResult_;

export type LeveragerDeleverageErc20Error = unknown;

export type LeveragerDeleverageNativeData = {
	body: LeveragerInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type LeveragerDeleverageNativeResponse =
	LeveragerAPIResponse_LeveragerExecuteFunctionResult_;

export type LeveragerDeleverageNativeError = unknown;

export type LeveragerExecuteOperationData = {
	body: LeveragerInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type LeveragerExecuteOperationResponse =
	LeveragerAPIResponse_LeveragerExecuteFunctionResult_;

export type LeveragerExecuteOperationError = unknown;

export type LeveragerGrantRoleData = {
	body: LeveragerInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type LeveragerGrantRoleResponse =
	LeveragerAPIResponse_LeveragerExecuteFunctionResult_;

export type LeveragerGrantRoleError = unknown;

export type LeveragerLeverageErc20Data = {
	body: LeveragerInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type LeveragerLeverageErc20Response =
	LeveragerAPIResponse_LeveragerExecuteFunctionResult_;

export type LeveragerLeverageErc20Error = unknown;

export type LeveragerLeverageNativeData = {
	body: LeveragerInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type LeveragerLeverageNativeResponse =
	LeveragerAPIResponse_LeveragerExecuteFunctionResult_;

export type LeveragerLeverageNativeError = unknown;

export type LeveragerPauseData = {
	body: LeveragerInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type LeveragerPauseResponse =
	LeveragerAPIResponse_LeveragerExecuteFunctionResult_;

export type LeveragerPauseError = unknown;

export type LeveragerRenounceRoleData = {
	body: LeveragerInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type LeveragerRenounceRoleResponse =
	LeveragerAPIResponse_LeveragerExecuteFunctionResult_;

export type LeveragerRenounceRoleError = unknown;

export type LeveragerRevokeRoleData = {
	body: LeveragerInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type LeveragerRevokeRoleResponse =
	LeveragerAPIResponse_LeveragerExecuteFunctionResult_;

export type LeveragerRevokeRoleError = unknown;

export type LeveragerUnpauseData = {
	body: LeveragerInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type LeveragerUnpauseResponse =
	LeveragerAPIResponse_LeveragerExecuteFunctionResult_;

export type LeveragerUnpauseError = unknown;

export type LifiGetQuoteData = {
	query: {
		/**
		 * - A list of allowed bridges (optional).
		 */
		allowBridges?: Array<string>;
		/**
		 * - A list of allowed exchanges (optional).
		 */
		allowExchanges?: Array<string>;
		/**
		 * - A list of denied bridges (optional).
		 */
		denyBridges?: Array<string>;
		/**
		 * - A list of denied exchanges (optional).
		 */
		denyExchanges?: Array<string>;
		/**
		 * - The fee amount (optional).
		 */
		fee?: number;
		/**
		 * - The address of the sender on the source chain.
		 */
		fromAddress: string;
		/**
		 * - The amount of the source token to swap.
		 */
		fromAmount: string;
		/**
		 * - The source blockchain identifier.
		 */
		fromChain: string;
		/**
		 * - The token address on the source chain.
		 */
		fromToken: string;
		/**
		 * - The integrator identifier (optional).
		 */
		integrator?: string;
		/**
		 * - The order preference for the quote ('BEST_VALUE', 'BEST_FEE', 'BEST_FEE_GAS') (optional).
		 */
		order?: "BEST_VALUE" | "BEST_FEE" | "BEST_FEE_GAS";
		/**
		 * - A list of preferred bridges (optional).
		 */
		preferBridges?: Array<string>;
		/**
		 * - A list of preferred exchanges (optional).
		 */
		preferExchanges?: Array<string>;
		/**
		 * - The referrer identifier (optional).
		 */
		referrer?: string;
		/**
		 * - The maximum acceptable slippage percentage (optional).
		 */
		slippage?: number;
		/**
		 * - The address of the recipient on the destination chain (optional).
		 */
		toAddress?: string;
		/**
		 * - The destination blockchain identifier.
		 */
		toChain: string;
		/**
		 * - The token address on the destination chain.
		 */
		toToken: string;
	};
};

export type LifiGetQuoteResponse = ApiResponse_Quote_;

export type LifiGetQuoteError = unknown;

export type LifiPostQuoteData = {
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account requesting the quote.
		 */
		accountName: string;
	};
	query: {
		/**
		 * - (Optional) The list of allowed bridges for the swap.
		 */
		allowBridges?: Array<string>;
		/**
		 * - (Optional) The list of allowed exchanges for the swap.
		 */
		allowExchanges?: Array<string>;
		/**
		 * - (Optional) The list of denied bridges for the swap.
		 */
		denyBridges?: Array<string>;
		/**
		 * - (Optional) The list of denied exchanges for the swap.
		 */
		denyExchanges?: Array<string>;
		/**
		 * - (Optional) The fee for the swap.
		 */
		fee?: number;
		/**
		 * - The address from which the token swap will originate.
		 */
		fromAddress: string;
		/**
		 * - The amount of the token to be swapped from.
		 */
		fromAmount: string;
		/**
		 * - The chain from which the token swap will originate.
		 */
		fromChain: string;
		/**
		 * - The token to be swapped from.
		 */
		fromToken: string;
		/**
		 * - (Optional) The integrator identifier.
		 */
		integrator?: string;
		/**
		 * - (Optional) The order preference for the quote (BEST_VALUE, BEST_FEE, BEST_FEE_GAS).
		 */
		order?: "BEST_VALUE" | "BEST_FEE" | "BEST_FEE_GAS";
		/**
		 * - (Optional) The list of preferred bridges for the swap.
		 */
		preferBridges?: Array<string>;
		/**
		 * - (Optional) The list of preferred exchanges for the swap.
		 */
		preferExchanges?: Array<string>;
		/**
		 * - (Optional) The referrer identifier.
		 */
		referrer?: string;
		/**
		 * - (Optional) The acceptable slippage percentage for the swap.
		 */
		slippage?: number;
		/**
		 * - (Optional) The address to which the token swap will be sent.
		 */
		toAddress?: string;
		/**
		 * - The chain to which the token swap will be sent.
		 */
		toChain: string;
		/**
		 * - The token to be swapped to.
		 */
		toToken: string;
	};
};

export type LifiPostQuoteResponse = ApiResponse_PostQuote_;

export type LifiPostQuoteError = unknown;

export type LifiGetStatusData = {
	query: {
		/**
		 * - The hash of the transaction to retrieve the status for.
		 */
		txHash: string;
	};
};

export type LifiGetStatusResponse = ApiResponse_StatusResponse_;

export type LifiGetStatusError = unknown;

export type LifiGetChainsData = {
	query?: {
		/**
		 * - Optional parameter to filter chains by type ('EVM' or 'SOL').
		 */
		optionalChainTypes?: "EVM" | "SOL";
	};
};

export type LifiGetChainsResponse = ApiResponse_ChainsResponse_;

export type LifiGetChainsError = unknown;

export type GetToolsData = {
	query?: {
		/**
		 * - Optional query parameter specifying the chains to filter tools.
		 */
		chains?: string;
	};
};

export type GetToolsResponse = ApiResponse_ToolsResponse_;

export type GetToolsError = unknown;

export type LifiGetTokensResponse = ApiResponse_TokensResponse_;

export type LifiGetTokensError = unknown;

export type LifiGetTokenDetailsData = {
	query: {
		/**
		 * - The blockchain on which the token resides.
		 */
		chain: string;
		/**
		 * - The address or symbol of the token to fetch details for.
		 */
		token: string;
	};
};

export type LifiGetTokenDetailsResponse = ApiResponse_TokenDetails_;

export type LifiGetTokenDetailsError = unknown;

export type LifiGetConnectionsData = {
	query: {
		/**
		 * - Optional parameter to specify types of chains.
		 */
		chainTypes?: string;
		/**
		 * - The source blockchain identifier.
		 */
		fromChain: string;
		/**
		 * - The source token identifier.
		 */
		fromToken: string;
		/**
		 * - The destination blockchain identifier.
		 */
		toChain: string;
		/**
		 * - The destination token identifier.
		 */
		toToken: string;
	};
};

export type LifiGetConnectionsResponse = ApiResponse_ConnectionsResponse_;

export type LifiGetConnectionsError = unknown;

export type LifiGetAllPossibleConnectionsData = {
	query: {
		/**
		 * - The target chain identifier.
		 */
		toChain: string;
		/**
		 * - The target token identifier.
		 */
		toToken: string;
	};
};

export type LifiGetAllPossibleConnectionsResponse =
	ApiResponse_TokenInfoByChainId_;

export type LifiGetAllPossibleConnectionsError = unknown;

export type ListLitecoinAccountsData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type ListLitecoinAccountsResponse = AccountAPIResponse;

export type ListLitecoinAccountsError = unknown;

export type LitecoinCreateLitecoinAccountData = {
	/**
	 * - The input data required to create a Litecoin account.
	 */
	body: LitecoinInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type LitecoinCreateLitecoinAccountResponse = AccountAPIResponse;

export type LitecoinCreateLitecoinAccountError = unknown;

export type LitecoinGetLitecoinAccountData = {
	headers: {
		/**
		 * - The authorization token provided in the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to retrieve information for.
		 */
		accountName: string;
	};
};

export type LitecoinGetLitecoinAccountResponse = AccountAPIResponse;

export type LitecoinGetLitecoinAccountError = unknown;

export type LitecoinSignLitecoinTransactionData = {
	/**
	 * - The transaction input details.
	 */
	body: LitecoinTransactionInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to sign the transaction for.
		 */
		accountName: string;
	};
};

export type LitecoinSignLitecoinTransactionResponse = LitecoinAPIResponse;

export type LitecoinSignLitecoinTransactionError = unknown;

export type LitecoinExportLitecoinAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be exported.
		 */
		accountName: string;
	};
};

export type LitecoinExportLitecoinAccountResponse = AccountAPIResponse;

export type LitecoinExportLitecoinAccountError = unknown;

export type LitecoinDeleteLitecoinAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be deleted.
		 */
		accountName: string;
	};
};

export type LitecoinDeleteLitecoinAccountResponse = AccountAPIResponse;

export type LitecoinDeleteLitecoinAccountError = unknown;

export type LitecoinSignLitecoinTransactionWithMemoData = {
	/**
	 * - The transaction input details.
	 */
	body: LitecoinTransactionInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The account name from the request path.
		 */
		accountName: string;
	};
};

export type LitecoinSignLitecoinTransactionWithMemoResponse =
	LitecoinAPIResponse;

export type LitecoinSignLitecoinTransactionWithMemoError = unknown;

export type GetAssetsData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type GetAssetsResponse = LynexAPIResponse;

export type GetAssetsError = unknown;

export type GetAssetByAddressData = {
	headers: {
		/**
		 * - The authorization token.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The address of the asset to retrieve.
		 */
		address: string;
	};
};

export type GetAssetByAddressResponse = LynexAPIResponse;

export type GetAssetByAddressError = unknown;

export type GetPoolsData = {
	headers: {
		Authorization: string;
	};
};

export type GetPoolsResponse = LynexAPIResponse;

export type GetPoolsError = unknown;

export type GetPoolByAddressData = {
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type GetPoolByAddressResponse = LynexAPIResponse;

export type GetPoolByAddressError = unknown;

export type GetPoolsByTypeData = {
	headers: {
		Authorization: string;
	};
	path: {
		type: string;
	};
};

export type GetPoolsByTypeResponse = LynexAPIResponse;

export type GetPoolsByTypeError = unknown;

export type GetTopAprPoolsData = {
	headers: {
		Authorization: string;
	};
	query?: {
		limit?: number;
	};
};

export type GetTopAprPoolsResponse = LynexAPIResponse;

export type GetTopAprPoolsError = unknown;

export type GetTotalValueLockedData = {
	headers: {
		Authorization: string;
	};
};

export type GetTotalValueLockedResponse = LynexAPIResponse;

export type GetTotalValueLockedError = unknown;

export type CalculateOptimalVoteDistributionData = {
	headers: {
		Authorization: string;
	};
	query: {
		maxPools?: number;
		totalVotes: number;
	};
};

export type CalculateOptimalVoteDistributionResponse = LynexAPIResponse;

export type CalculateOptimalVoteDistributionError = unknown;

export type GetBalanceOfData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		owner: string;
	};
};

export type GetBalanceOfResponse = LynexNFTAPIResponse_string_;

export type GetBalanceOfError = unknown;

export type GetOwnerOfData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type GetOwnerOfResponse = LynexNFTAPIResponse_string_;

export type GetOwnerOfError = unknown;

export type GetTokenUriData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type GetTokenUriResponse = LynexNFTAPIResponse_string_;

export type GetTokenUriError = unknown;

export type GetLockDetailsData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type GetLockDetailsResponse = LynexNFTAPIResponse_any_;

export type GetLockDetailsError = unknown;

export type CreateLockData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type CreateLockResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type CreateLockError = unknown;

export type IncreaseLockAmountData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type IncreaseLockAmountResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type IncreaseLockAmountError = unknown;

export type IncreaseUnlockTimeData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type IncreaseUnlockTimeResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type IncreaseUnlockTimeError = unknown;

export type GetTotalSupplyData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetTotalSupplyResponse = LynexNFTAPIResponse_string_;

export type GetTotalSupplyError = unknown;

export type GetTokenOfOwnerByIndexData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		index: string;
		owner: string;
	};
};

export type GetTokenOfOwnerByIndexResponse = LynexNFTAPIResponse_string_;

export type GetTokenOfOwnerByIndexError = unknown;

export type GetTokenByIndexData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		index: string;
	};
};

export type GetTokenByIndexResponse = LynexNFTAPIResponse_string_;

export type GetTokenByIndexError = unknown;

export type DelegateData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type DelegateResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type DelegateError = unknown;

export type MergeData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type MergeResponse = LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type MergeError = unknown;

export type SplitData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SplitResponse = LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type SplitError = unknown;

export type ClaimData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ClaimResponse = LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type ClaimError = unknown;

export type UnlockPermanentData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type UnlockPermanentResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type UnlockPermanentError = unknown;

export type GetNameData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetNameResponse = LynexNFTAPIResponse_string_;

export type GetNameError = unknown;

export type GetSymbolData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetSymbolResponse = LynexNFTAPIResponse_string_;

export type GetSymbolError = unknown;

export type GetApprovedData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type GetApprovedResponse = LynexNFTAPIResponse_string_;

export type GetApprovedError = unknown;

export type IsApprovedForAllData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		operator: string;
		owner: string;
	};
};

export type IsApprovedForAllResponse = LynexNFTAPIResponse_boolean_;

export type IsApprovedForAllError = unknown;

export type GetBalanceOfNftData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type GetBalanceOfNftResponse = LynexNFTAPIResponse_string_;

export type GetBalanceOfNftError = unknown;

export type GetBalanceOfNftAtData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		timestamp: string;
		tokenId: string;
	};
};

export type GetBalanceOfNftAtResponse = LynexNFTAPIResponse_string_;

export type GetBalanceOfNftAtError = unknown;

export type GetTotalNftsMintedData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetTotalNftsMintedResponse = LynexNFTAPIResponse_string_;

export type GetTotalNftsMintedError = unknown;

export type GetDelegatesData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		timestamp: string;
		tokenId: string;
	};
};

export type GetDelegatesResponse = LynexNFTAPIResponse_string_;

export type GetDelegatesError = unknown;

export type GetVotesData = {
	headers: {
		Authorization: string;
	};
	query: {
		account: string;
		address: string;
		chainId: string;
	};
};

export type GetVotesResponse = LynexNFTAPIResponse_string_;

export type GetVotesError = unknown;

export type GetPastVotesData = {
	headers: {
		Authorization: string;
	};
	query: {
		account: string;
		address: string;
		chainId: string;
		timestamp: string;
	};
};

export type GetPastVotesResponse = LynexNFTAPIResponse_string_;

export type GetPastVotesError = unknown;

export type GetVestedPayoutData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type GetVestedPayoutResponse = LynexNFTAPIResponse_string_;

export type GetVestedPayoutError = unknown;

export type GetVestedPayoutAtTimeData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		timestamp: string;
		tokenId: string;
	};
};

export type GetVestedPayoutAtTimeResponse = LynexNFTAPIResponse_string_;

export type GetVestedPayoutAtTimeError = unknown;

export type GetVestingPayoutData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type GetVestingPayoutResponse = LynexNFTAPIResponse_string_;

export type GetVestingPayoutError = unknown;

export type GetVestingPeriodData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type GetVestingPeriodResponse = LynexNFTAPIResponse_VestingPeriodData_;

export type GetVestingPeriodError = unknown;

export type ApproveData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ApproveResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type ApproveError = unknown;

export type SetApprovalForAllData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SetApprovalForAllResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type SetApprovalForAllError = unknown;

export type TransferFromData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type TransferFromResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type TransferFromError = unknown;

export type SafeTransferFromData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SafeTransferFromResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type SafeTransferFromError = unknown;

export type BurnData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type BurnResponse = LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type BurnError = unknown;

export type CreateDelegatedLockForData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type CreateDelegatedLockForResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type CreateDelegatedLockForError = unknown;

export type CreateLockForData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type CreateLockForResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type CreateLockForError = unknown;

export type CheckpointData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type CheckpointResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type CheckpointError = unknown;

export type CheckpointDelegateeData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type CheckpointDelegateeResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type CheckpointDelegateeError = unknown;

export type SetClaimApprovalData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SetClaimApprovalResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type SetClaimApprovalError = unknown;

export type SetClaimApprovalForAllData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SetClaimApprovalForAllResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type SetClaimApprovalForAllError = unknown;

export type DelegateBySigData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type DelegateBySigResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type DelegateBySigError = unknown;

export type GlobalCheckpointData = {
	body: LynexNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type GlobalCheckpointResponse =
	LynexNFTAPIResponse_LynexNFTExecuteFunctionResult_;

export type GlobalCheckpointError = unknown;

export type GetFactoryData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetFactoryResponse = LynexRouterAPIResponse_string_;

export type GetFactoryError = unknown;

export type GetWethData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetWethResponse = LynexRouterAPIResponse_string_;

export type GetWethError = unknown;

export type GetAmountOutData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		amountIn: string;
		chainId: string;
		tokenIn: string;
		tokenOut: string;
	};
};

export type GetAmountOutResponse =
	LynexRouterAPIResponse__amountOut_string__stable_boolean__;

export type GetAmountOutError = unknown;

export type GetAmountsOutData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		amountIn: string;
		chainId: string;
		routes: string;
	};
};

export type GetAmountsOutResponse = LynexRouterAPIResponse_string_Array_;

export type GetAmountsOutError = unknown;

export type AddLiquidityData = {
	body: LynexRouterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type AddLiquidityResponse =
	LynexRouterAPIResponse_LynexRouterExecuteFunctionResult_;

export type AddLiquidityError = unknown;

export type AddLiquidityEthData = {
	body: LynexRouterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type AddLiquidityEthResponse =
	LynexRouterAPIResponse_LynexRouterExecuteFunctionResult_;

export type AddLiquidityEthError = unknown;

export type SwapExactTokensForTokensData = {
	body: LynexRouterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SwapExactTokensForTokensResponse =
	LynexRouterAPIResponse_LynexRouterExecuteFunctionResult_;

export type SwapExactTokensForTokensError = unknown;

export type SwapExactEthForTokensData = {
	body: LynexRouterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SwapExactEthForTokensResponse =
	LynexRouterAPIResponse_LynexRouterExecuteFunctionResult_;

export type SwapExactEthForTokensError = unknown;

export type SwapExactTokensForEthData = {
	body: LynexRouterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SwapExactTokensForEthResponse =
	LynexRouterAPIResponse_LynexRouterExecuteFunctionResult_;

export type SwapExactTokensForEthError = unknown;

export type GetTotalWeightData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetTotalWeightResponse = LynexVoterAPIResponse_string_;

export type GetTotalWeightError = unknown;

export type GetWeightsData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		pool: string;
	};
};

export type GetWeightsResponse = LynexVoterAPIResponse_string_;

export type GetWeightsError = unknown;

export type IsGaugeData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		gauge: string;
	};
};

export type IsGaugeResponse = LynexVoterAPIResponse_boolean_;

export type IsGaugeError = unknown;

export type IsWhitelistedData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		token: string;
	};
};

export type IsWhitelistedResponse = LynexVoterAPIResponse_boolean_;

export type IsWhitelistedError = unknown;

export type GetLastVotedData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		voter: string;
	};
};

export type GetLastVotedResponse = LynexVoterAPIResponse_string_;

export type GetLastVotedError = unknown;

export type GetPoolVoteLengthData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		voter: string;
	};
};

export type GetPoolVoteLengthResponse = LynexVoterAPIResponse_string_;

export type GetPoolVoteLengthError = unknown;

export type VoteData = {
	body: LynexVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type VoteResponse =
	LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_;

export type VoteError = unknown;

export type ResetData = {
	body: LynexVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ResetResponse =
	LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_;

export type ResetError = unknown;

export type PokeData = {
	body: LynexVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type PokeResponse =
	LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_;

export type PokeError = unknown;

export type CreateGaugeData = {
	body: LynexVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type CreateGaugeResponse =
	LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_;

export type CreateGaugeError = unknown;

export type KillGaugeData = {
	body: LynexVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type KillGaugeResponse =
	LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_;

export type KillGaugeError = unknown;

export type ReviveGaugeData = {
	body: LynexVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ReviveGaugeResponse =
	LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_;

export type ReviveGaugeError = unknown;

export type NotifyRewardAmountData = {
	body: LynexVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type NotifyRewardAmountResponse =
	LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_;

export type NotifyRewardAmountError = unknown;

export type DistributeData = {
	body: LynexVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type DistributeResponse =
	LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_;

export type DistributeError = unknown;

export type ClaimBribesData = {
	body: LynexVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ClaimBribesResponse =
	LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_;

export type ClaimBribesError = unknown;

export type ClaimFeesData = {
	body: LynexVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ClaimFeesResponse =
	LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_;

export type ClaimFeesError = unknown;

export type ClaimRewardsData = {
	body: LynexVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ClaimRewardsResponse =
	LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_;

export type ClaimRewardsError = unknown;

export type WhitelistData = {
	body: LynexVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type WhitelistResponse =
	LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_;

export type WhitelistError = unknown;

export type VoteWithOptimalDistributionData = {
	body: LynexVoterInputBody & {
		maxPools?: number;
		totalVotes: number;
	};
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type VoteWithOptimalDistributionResponse =
	LynexVoterAPIResponse_LynexVoterExecuteFunctionResult_;

export type VoteWithOptimalDistributionError = unknown;

export type CreateJobData = {
	body: MultiCallInputBody;
	headers: {
		Authorization: string;
	};
};

export type CreateJobResponse = MultiCallAPIResponse_string_;

export type CreateJobError = unknown;

export type ExecuteJobData = {
	headers: {
		Authorization: string;
	};
	path: {
		jobId: string;
	};
};

export type ExecuteJobResponse = MultiCallAPIResponse;

export type ExecuteJobError = unknown;

export type GetJobResultData = {
	headers: {
		Authorization: string;
	};
	path: {
		jobId: string;
	};
};

export type GetJobResultResponse = MultiCallAPIResponse_any_;

export type GetJobResultError = unknown;

export type ScheduleJobData = {
	body: ScheduleJobBody;
	headers: {
		Authorization: string;
	};
};

export type ScheduleJobResponse = MultiCallAPIResponse;

export type ScheduleJobError = unknown;

export type UnscheduleJobData = {
	headers: {
		Authorization: string;
	};
	path: {
		jobId: string;
	};
};

export type UnscheduleJobResponse = MultiCallAPIResponse;

export type UnscheduleJobError = unknown;

export type GetScheduledJobsData = {
	headers: {
		Authorization: string;
	};
};

export type GetScheduledJobsResponse = MultiCallAPIResponse_any_Array_;

export type GetScheduledJobsError = unknown;

export type ListJobsData = {
	headers: {
		Authorization: string;
	};
};

export type ListJobsResponse = MultiCallAPIResponse_Jobs_Array_;

export type ListJobsError = unknown;

export type GetJobData = {
	headers: {
		Authorization: string;
	};
	path: {
		jobId: string;
	};
};

export type GetJobResponse = MultiCallAPIResponse_Jobs_;

export type GetJobError = unknown;

export type DeleteJobData = {
	headers: {
		Authorization: string;
	};
	path: {
		jobId: string;
	};
};

export type DeleteJobResponse = MultiCallAPIResponse;

export type DeleteJobError = unknown;

export type CreateFlowData = {
	body: CreateFlowBody;
	headers: {
		Authorization: string;
	};
};

export type CreateFlowResponse = MultiCallAPIResponse_string_;

export type CreateFlowError = unknown;

export type ListFlowsData = {
	headers: {
		Authorization: string;
	};
};

export type ListFlowsResponse = MultiCallAPIResponse_Flow_Array_;

export type ListFlowsError = unknown;

export type GetFlowData = {
	headers: {
		Authorization: string;
	};
	path: {
		flowId: string;
	};
};

export type GetFlowResponse = MultiCallAPIResponse_Flow_;

export type GetFlowError = unknown;

export type UpdateFlowData = {
	body: UpdateFlowBody;
	headers: {
		Authorization: string;
	};
	path: {
		flowId: string;
	};
};

export type UpdateFlowResponse = MultiCallAPIResponse;

export type UpdateFlowError = unknown;

export type DeleteFlowData = {
	headers: {
		Authorization: string;
	};
	path: {
		flowId: string;
	};
};

export type DeleteFlowResponse = MultiCallAPIResponse;

export type DeleteFlowError = unknown;

export type CreateUserDefinedFunctionData = {
	body: {
		functionBody: string;
		name: string;
	};
	headers: {
		Authorization: string;
	};
};

export type CreateUserDefinedFunctionResponse = MultiCallAPIResponse;

export type CreateUserDefinedFunctionError = unknown;

export type ListUserDefinedFunctionsData = {
	headers: {
		Authorization: string;
	};
};

export type ListUserDefinedFunctionsResponse = MultiCallAPIResponse_any_Array_;

export type ListUserDefinedFunctionsError = unknown;

export type DeleteUserDefinedFunctionData = {
	headers: {
		Authorization: string;
	};
	path: {
		functionId: string;
	};
};

export type DeleteUserDefinedFunctionResponse = MultiCallAPIResponse;

export type DeleteUserDefinedFunctionError = unknown;

export type GetNotificationsData = {
	headers: {
		Authorization: string;
	};
};

export type GetNotificationsResponse = MultiCallAPIResponse_any_Array_;

export type GetNotificationsError = unknown;

export type MarkNotificationAsReadData = {
	headers: {
		Authorization: string;
	};
	path: {
		notificationId: string;
	};
};

export type MarkNotificationAsReadResponse = MultiCallAPIResponse;

export type MarkNotificationAsReadError = unknown;

export type OdosSwapTokensData = {
	/**
	 * - The input body containing the swap details.
	 */
	body: OdosSwapInputBody;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to perform the swap for.
		 */
		accountName: string;
	};
};

export type OdosSwapTokensResponse = OdosAPIResponse_OdosExecuteFunctionResult_;

export type OdosSwapTokensError = unknown;

export type OdosGetQuoteData = {
	/**
	 * - The input body containing the details for the quote request.
	 */
	body: OdosSwapInputBody;
	headers: {
		/**
		 * - The authorization token for the request.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account for which the quote is being retrieved.
		 */
		accountName: string;
	};
};

export type OdosGetQuoteResponse = OdosAPIResponse_OdosExecuteFunctionResult_;

export type OdosGetQuoteError = unknown;

export type GetZapQuoteData = {
	body: OdosSwapInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type GetZapQuoteResponse = OdosAPIResponse_OdosExecuteFunctionResult_;

export type GetZapQuoteError = unknown;

export type ZapData = {
	body: OdosSwapInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type ZapResponse = OdosAPIResponse_OdosExecuteFunctionResult_;

export type ZapError = unknown;

export type OdosAssembleTransactionData = {
	/**
	 * - The request body containing the transaction details.
	 */
	body: AssembleRequest;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type OdosAssembleTransactionResponse =
	OdosAPIResponse_OdosExecuteFunctionResult_;

export type OdosAssembleTransactionError = unknown;

export type OdosGetSupportedChainsData = {
	headers: {
		/**
		 * - The authorization token provided in the request header.
		 */
		Authorization: string;
	};
};

export type OdosGetSupportedChainsResponse =
	OdosAPIResponse_OdosExecuteFunctionResult_;

export type OdosGetSupportedChainsError = unknown;

export type OdosGetContractInfoData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The chain ID for which the contract information is requested.
		 */
		chainId: number;
		/**
		 * - The version of the API to use, expected to be 'v2'.
		 */
		version: "v2";
	};
};

export type OdosGetContractInfoResponse =
	OdosAPIResponse_OdosExecuteFunctionResult_;

export type OdosGetContractInfoError = unknown;

export type OdosGetRouterAddressData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The ID of the blockchain network.
		 */
		chainId: number;
		/**
		 * - The version of the API to use, default is 'v2'.
		 */
		version: "v2";
	};
};

export type OdosGetRouterAddressResponse =
	OdosAPIResponse_OdosExecuteFunctionResult_;

export type OdosGetRouterAddressError = unknown;

export type OdosGetExecutorAddressData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The chain ID for which the executor address is requested.
		 */
		chainId: number;
		/**
		 * - The API version, expected to be 'v2'.
		 */
		version: "v2";
	};
};

export type OdosGetExecutorAddressResponse =
	OdosAPIResponse_OdosExecuteFunctionResult_;

export type OdosGetExecutorAddressError = unknown;

export type OdosGetLiquiditySourcesData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The ID of the blockchain to query for liquidity sources.
		 */
		chainId: number;
	};
};

export type OdosGetLiquiditySourcesResponse =
	OdosAPIResponse_OdosExecuteFunctionResult_;

export type OdosGetLiquiditySourcesError = unknown;

export type OdosGetSupportedTokensData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The ID of the blockchain network to query.
		 */
		chainId: number;
	};
};

export type OdosGetSupportedTokensResponse =
	OdosAPIResponse_OdosExecuteFunctionResult_;

export type OdosGetSupportedTokensError = unknown;

export type OdosGetCurrentBlockData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	query: {
		/**
		 * - The ID of the blockchain to query.
		 */
		chainId: number;
	};
};

export type OdosGetCurrentBlockResponse =
	OdosAPIResponse_OdosExecuteFunctionResult_;

export type OdosGetCurrentBlockError = unknown;

export type OnRamperGetSupportedCurrenciesData = {
	headers: {
		Authorization: string;
	};
	query: {
		type: string;
	};
};

export type OnRamperGetSupportedCurrenciesResponse =
	SupportedCurrenciesResponse;

export type OnRamperGetSupportedCurrenciesError = unknown;

export type OnRamperGetSupportedPaymentTypesData = {
	headers: {
		Authorization: string;
	};
	query: {
		country: string;
		fiat: string;
		type: string;
	};
};

export type OnRamperGetSupportedPaymentTypesResponse =
	SupportedPaymentTypesCurrencyResponse;

export type OnRamperGetSupportedPaymentTypesError = unknown;

export type OnRamperGetSupportedPaymentTypesFiatData = {
	headers: {
		Authorization: string;
	};
	query: {
		country: string;
		fiat: string;
	};
};

export type OnRamperGetSupportedPaymentTypesFiatResponse =
	SupportedPaymentTypesCurrencyResponse;

export type OnRamperGetSupportedPaymentTypesFiatError = unknown;

export type OnRamperGetSupportedDefaultsAllData = {
	headers: {
		Authorization: string;
	};
	query: {
		country: string;
		type: string;
	};
};

export type OnRamperGetSupportedDefaultsAllResponse = SupportedDefaultResponse;

export type OnRamperGetSupportedDefaultsAllError = unknown;

export type OnRamperGetSupportedAssetsData = {
	headers: {
		Authorization: string;
	};
	query: {
		country: string;
		source: string;
	};
};

export type OnRamperGetSupportedAssetsResponse = SupportedAssetResponse;

export type OnRamperGetSupportedAssetsError = unknown;

export type OnRamperGetSupportedOnRampsAllData = {
	headers: {
		Authorization: string;
	};
};

export type OnRamperGetSupportedOnRampsAllResponse =
	GetSupportedOnRampsResponse;

export type OnRamperGetSupportedOnRampsAllError = unknown;

export type OnRamperGetQuotesBuyData = {
	headers: {
		Authorization: string;
	};
	query: {
		amount: number;
		clientName?: string;
		country?: string;
		crypto: string;
		fiat: string;
		paymentMethod?: string;
		uuid?: string;
	};
};

export type OnRamperGetQuotesBuyResponse = Quotes;

export type OnRamperGetQuotesBuyError = unknown;

export type OnRamperGetQuotesSellData = {
	headers: {
		Authorization: string;
	};
	query: {
		amount: number;
		clientName?: string;
		country?: string;
		crypto: string;
		fiat: string;
		paymentMethod?: string;
		uuid?: string;
	};
};

export type OnRamperGetQuotesSellResponse = SellQuotes;

export type OnRamperGetQuotesSellError = unknown;

export type OnRamperCheckoutData = {
	body: TransactionInput;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type OnRamperCheckoutResponse = unknown;

export type OnRamperCheckoutError = unknown;

export type CreateOfferData = {
	body: OpenSeaNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type CreateOfferResponse = OpenSeaAPIResponse;

export type CreateOfferError = unknown;

export type CreateCollectionOfferData = {
	body: OpenSeaCollectionInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type CreateCollectionOfferResponse = OpenSeaAPIResponse;

export type CreateCollectionOfferError = unknown;

export type GetCollectionData = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
		slug: string;
	};
	query?: {
		chainId?: string;
	};
};

export type GetCollectionResponse = OpenSeaAPIResponse;

export type GetCollectionError = unknown;

export type GetNftData = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
		address: string;
		tokenId: string;
	};
	query?: {
		chainId?: string;
	};
};

export type GetNftResponse = OpenSeaAPIResponse;

export type GetNftError = unknown;

export type WrapEthData = {
	body: {
		chainId: string;
		amountInEth: string;
	};
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type WrapEthResponse = OpenSeaAPIResponse;

export type WrapEthError = unknown;

export type UnwrapWethData = {
	body: {
		chainId: string;
		amountInEth: string;
	};
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type UnwrapWethResponse = OpenSeaAPIResponse;

export type UnwrapWethError = unknown;

export type GetMessageResponse = PingResponse;

export type GetMessageError = unknown;

export type CreateOrderData = {
	body: CreateOrderBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type CreateOrderResponse2 = PolymarketAPIResponse_CreateOrderResponse_;

export type CreateOrderError = unknown;

export type CreateMarketBuyOrderData = {
	body: CreateMarketBuyOrderBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type CreateMarketBuyOrderResponse2 =
	PolymarketAPIResponse_CreateMarketBuyOrderResponse_;

export type CreateMarketBuyOrderError = unknown;

export type PostOrderData = {
	body: PostOrderBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type PostOrderResponse2 = PolymarketAPIResponse_PostOrderResponse_;

export type PostOrderError = unknown;

export type CancelOrderData = {
	body: CancelOrderBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type CancelOrderResponse2 = PolymarketAPIResponse_CancelOrderResponse_;

export type CancelOrderError = unknown;

export type CancelOrdersData = {
	body: CancelOrdersBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type CancelOrdersResponse2 = PolymarketAPIResponse_CancelOrdersResponse_;

export type CancelOrdersError = unknown;

export type CancelMarketOrdersData = {
	body: CancelMarketOrdersBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type CancelMarketOrdersResponse2 =
	PolymarketAPIResponse_CancelMarketOrdersResponse_;

export type CancelMarketOrdersError = unknown;

export type UpdateBalanceAllowanceData = {
	body: UpdateBalanceAllowanceBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type UpdateBalanceAllowanceResponse2 =
	PolymarketAPIResponse_UpdateBalanceAllowanceResponse_;

export type UpdateBalanceAllowanceError = unknown;

export type DropNotificationsData = {
	body: DropNotificationsBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type DropNotificationsResponse2 =
	PolymarketAPIResponse_DropNotificationsResponse_;

export type DropNotificationsError = unknown;

export type GetMarketsData = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
	query: {
		chainId: string;
		nextCursor?: string;
	};
};

export type GetMarketsResponse = PolymarketAPIResponse_PaginationPayload_;

export type GetMarketsError = unknown;

export type ApproveForPolymarketData = {
	body: ApproveForPolymarketBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type ApproveForPolymarketResponse = PolymarketAPIResponse_any_;

export type ApproveForPolymarketError = unknown;

export type GetMarketData = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
		conditionID: string;
	};
	query: {
		chainId: string;
	};
};

export type GetMarketResponse = PolymarketAPIResponse_any_;

export type GetMarketError = unknown;

export type GetOrderBookData = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
	query: {
		chainId: string;
		tokenID: string;
	};
};

export type GetOrderBookResponse = PolymarketAPIResponse_OrderBookSummary_;

export type GetOrderBookError = unknown;

export type GetOpenOrdersData = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
	query: {
		assetId?: string;
		chainId: string;
		marketHash?: string;
		nextCursor?: string;
		outcomeId?: string;
	};
};

export type GetOpenOrdersResponse = PolymarketAPIResponse_OpenOrdersResponse_;

export type GetOpenOrdersError = unknown;

export type GetOrderData = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
		orderID: string;
	};
	query: {
		chainId: string;
	};
};

export type GetOrderResponse = PolymarketAPIResponse_OpenOrder_;

export type GetOrderError = unknown;

export type GetTradesData = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
	query: {
		after?: string;
		asset_id?: string;
		before?: string;
		chainId: string;
		id?: string;
		maker_address?: string;
		market?: string;
		nextCursor?: string;
	};
};

export type GetTradesResponse = PolymarketAPIResponse_Trade_Array_;

export type GetTradesError = unknown;

export type GetNotifications1Data = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
	query: {
		chainId: string;
	};
};

export type GetNotifications1Response =
	PolymarketAPIResponse_Notification_Array_;

export type GetNotifications1Error = unknown;

export type GetBalanceAllowanceData = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
	query: {
		asset_type: string;
		chainId: string;
		token_id?: string;
	};
};

export type GetBalanceAllowanceResponse =
	PolymarketAPIResponse_BalanceAllowanceResponse_;

export type GetBalanceAllowanceError = unknown;

export type GetPricesHistoryData = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
	query: {
		chainId: string;
		endTs?: number;
		fidelity?: number;
		interval?: string;
		market?: string;
		startTs?: number;
	};
};

export type GetPricesHistoryResponse = PolymarketAPIResponse_MarketPrice_Array_;

export type GetPricesHistoryError = unknown;

export type GetMarketTradeEventsData = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
		conditionID: string;
	};
	query: {
		chainId: string;
	};
};

export type GetMarketTradeEventsResponse =
	PolymarketAPIResponse_MarketTradeEvent_Array_;

export type GetMarketTradeEventsError = unknown;

export type GetPools1Data = {
	headers: {
		Authorization: string;
	};
};

export type GetPools1Response = RamsesAPIResponse;

export type GetPools1Error = unknown;

export type GetPoolByAddress1Data = {
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type GetPoolByAddress1Response = RamsesAPIResponse;

export type GetPoolByAddress1Error = unknown;

export type GetPoolsByType1Data = {
	headers: {
		Authorization: string;
	};
	path: {
		type: string;
	};
};

export type GetPoolsByType1Response = RamsesAPIResponse;

export type GetPoolsByType1Error = unknown;

export type GetTopAprPools1Data = {
	headers: {
		Authorization: string;
	};
	query?: {
		limit?: number;
	};
};

export type GetTopAprPools1Response = RamsesAPIResponse;

export type GetTopAprPools1Error = unknown;

export type GetTokensData = {
	headers: {
		Authorization: string;
	};
};

export type GetTokensResponse = RamsesAPIResponse;

export type GetTokensError = unknown;

export type GetInfoData = {
	headers: {
		Authorization: string;
	};
};

export type GetInfoResponse = RamsesAPIResponse;

export type GetInfoError = unknown;

export type GetTotalValueLocked1Data = {
	headers: {
		Authorization: string;
	};
};

export type GetTotalValueLocked1Response = RamsesAPIResponse;

export type GetTotalValueLocked1Error = unknown;

export type CalculateOptimalVoteDistribution1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		maxPools?: number;
		totalVotes: number;
	};
};

export type CalculateOptimalVoteDistribution1Response = RamsesAPIResponse;

export type CalculateOptimalVoteDistribution1Error = unknown;

export type GetBalanceOf1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		owner: string;
	};
};

export type GetBalanceOf1Response = RamsesNFTAPIResponse_string_;

export type GetBalanceOf1Error = unknown;

export type GetOwnerOf1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type GetOwnerOf1Response = RamsesNFTAPIResponse_string_;

export type GetOwnerOf1Error = unknown;

export type Approve1Data = {
	body: RamsesNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Approve1Response =
	RamsesNFTAPIResponse_RamsesNFTExecuteFunctionResult_;

export type Approve1Error = unknown;

export type CreateLock1Data = {
	body: RamsesNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type CreateLock1Response =
	RamsesNFTAPIResponse_RamsesNFTExecuteFunctionResult_;

export type CreateLock1Error = unknown;

export type IncreaseAmountData = {
	body: RamsesNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type IncreaseAmountResponse =
	RamsesNFTAPIResponse_RamsesNFTExecuteFunctionResult_;

export type IncreaseAmountError = unknown;

export type IncreaseUnlockTime1Data = {
	body: RamsesNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type IncreaseUnlockTime1Response =
	RamsesNFTAPIResponse_RamsesNFTExecuteFunctionResult_;

export type IncreaseUnlockTime1Error = unknown;

export type WithdrawData = {
	body: RamsesNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type WithdrawResponse =
	RamsesNFTAPIResponse_RamsesNFTExecuteFunctionResult_;

export type WithdrawError = unknown;

export type GetTokenUri1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type GetTokenUri1Response = RamsesNFTAPIResponse_string_;

export type GetTokenUri1Error = unknown;

export type GetTotalSupply1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetTotalSupply1Response = RamsesNFTAPIResponse_string_;

export type GetTotalSupply1Error = unknown;

export type Delegate1Data = {
	body: RamsesNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Delegate1Response =
	RamsesNFTAPIResponse_RamsesNFTExecuteFunctionResult_;

export type Delegate1Error = unknown;

export type TransferFrom1Data = {
	body: RamsesNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type TransferFrom1Response =
	RamsesNFTAPIResponse_RamsesNFTExecuteFunctionResult_;

export type TransferFrom1Error = unknown;

export type Merge1Data = {
	body: RamsesNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Merge1Response =
	RamsesNFTAPIResponse_RamsesNFTExecuteFunctionResult_;

export type Merge1Error = unknown;

export type Split1Data = {
	body: RamsesNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Split1Response =
	RamsesNFTAPIResponse_RamsesNFTExecuteFunctionResult_;

export type Split1Error = unknown;

export type GetBalanceOfNft1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type GetBalanceOfNft1Response = RamsesNFTAPIResponse_string_;

export type GetBalanceOfNft1Error = unknown;

export type GetLockedData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type GetLockedResponse = RamsesNFTAPIResponse_LockedData_;

export type GetLockedError = unknown;

export type GetVotes1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		account: string;
		address: string;
		chainId: string;
	};
};

export type GetVotes1Response = RamsesNFTAPIResponse_string_;

export type GetVotes1Error = unknown;

export type GetPastVotes1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		account: string;
		address: string;
		blockNumber: string;
		chainId: string;
	};
};

export type GetPastVotes1Response = RamsesNFTAPIResponse_string_;

export type GetPastVotes1Error = unknown;

export type GetDelegates1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		account: string;
		address: string;
		chainId: string;
	};
};

export type GetDelegates1Response = RamsesNFTAPIResponse_string_;

export type GetDelegates1Error = unknown;

export type AbstainData = {
	body: RamsesNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type AbstainResponse =
	RamsesNFTAPIResponse_RamsesNFTExecuteFunctionResult_;

export type AbstainError = unknown;

export type AttachData = {
	body: RamsesNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type AttachResponse =
	RamsesNFTAPIResponse_RamsesNFTExecuteFunctionResult_;

export type AttachError = unknown;

export type DetachData = {
	body: RamsesNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type DetachResponse =
	RamsesNFTAPIResponse_RamsesNFTExecuteFunctionResult_;

export type DetachError = unknown;

export type UnsafeSwapExactTokensForTokensData = {
	body: RamsesRouterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type UnsafeSwapExactTokensForTokensResponse =
	RamsesRouterAPIResponse_RamsesRouterExecuteFunctionResult_;

export type UnsafeSwapExactTokensForTokensError = unknown;

export type AddLiquidity1Data = {
	body: RamsesRouterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type AddLiquidity1Response =
	RamsesRouterAPIResponse_RamsesRouterExecuteFunctionResult_;

export type AddLiquidity1Error = unknown;

export type AddLiquidityEth1Data = {
	body: RamsesRouterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type AddLiquidityEth1Response =
	RamsesRouterAPIResponse_RamsesRouterExecuteFunctionResult_;

export type AddLiquidityEth1Error = unknown;

export type RemoveLiquidityData = {
	body: RamsesRouterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type RemoveLiquidityResponse =
	RamsesRouterAPIResponse_RamsesRouterExecuteFunctionResult_;

export type RemoveLiquidityError = unknown;

export type RemoveLiquidityEthData = {
	body: RamsesRouterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type RemoveLiquidityEthResponse =
	RamsesRouterAPIResponse_RamsesRouterExecuteFunctionResult_;

export type RemoveLiquidityEthError = unknown;

export type SwapExactTokensForTokens1Data = {
	body: RamsesRouterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SwapExactTokensForTokens1Response =
	RamsesRouterAPIResponse_RamsesRouterExecuteFunctionResult_;

export type SwapExactTokensForTokens1Error = unknown;

export type SwapExactEthForTokens1Data = {
	body: RamsesRouterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SwapExactEthForTokens1Response =
	RamsesRouterAPIResponse_RamsesRouterExecuteFunctionResult_;

export type SwapExactEthForTokens1Error = unknown;

export type SwapExactTokensForEth1Data = {
	body: RamsesRouterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SwapExactTokensForEth1Response =
	RamsesRouterAPIResponse_RamsesRouterExecuteFunctionResult_;

export type SwapExactTokensForEth1Error = unknown;

export type GetFactory1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetFactory1Response = RamsesRouterAPIResponse_string_;

export type GetFactory1Error = unknown;

export type GetAmountOut1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		amountIn: string;
		chainId: string;
		tokenIn: string;
		tokenOut: string;
	};
};

export type GetAmountOut1Response =
	RamsesRouterAPIResponse__amountOut_string__stable_boolean__;

export type GetAmountOut1Error = unknown;

export type GetAmountsOut1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		amountIn: string;
		chainId: string;
		routes: string;
	};
};

export type GetAmountsOut1Response = RamsesRouterAPIResponse_string_Array_;

export type GetAmountsOut1Error = unknown;

export type GetReservesData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		stable: boolean;
		tokenA: string;
		tokenB: string;
	};
};

export type GetReservesResponse =
	RamsesRouterAPIResponse__reserve0_string__reserve1_string__;

export type GetReservesError = unknown;

export type IsPairData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		pair: string;
	};
};

export type IsPairResponse = RamsesRouterAPIResponse_boolean_;

export type IsPairError = unknown;

export type PairForData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		stable: boolean;
		tokenA: string;
		tokenB: string;
	};
};

export type PairForResponse = RamsesRouterAPIResponse_string_;

export type PairForError = unknown;

export type QuoteAddLiquidityData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		amountADesired: string;
		amountBDesired: string;
		chainId: string;
		stable: boolean;
		tokenA: string;
		tokenB: string;
	};
};

export type QuoteAddLiquidityResponse =
	RamsesRouterAPIResponse__amountA_string__amountB_string__liquidity_string____;

export type QuoteAddLiquidityError = unknown;

export type QuoteRemoveLiquidityData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		liquidity: string;
		stable: boolean;
		tokenA: string;
		tokenB: string;
	};
};

export type QuoteRemoveLiquidityResponse =
	RamsesRouterAPIResponse__amountA_string__amountB_string__;

export type QuoteRemoveLiquidityError = unknown;

export type SortTokensData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenA: string;
		tokenB: string;
	};
};

export type SortTokensResponse = RamsesRouterAPIResponse_SortedTokens_;

export type SortTokensError = unknown;

export type GetWeth1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetWeth1Response = RamsesRouterAPIResponse_string_;

export type GetWeth1Error = unknown;

export type GetTotalWeight1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetTotalWeight1Response = RamsesVoterAPIResponse_string_;

export type GetTotalWeight1Error = unknown;

export type GetWeights1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		pool: string;
	};
};

export type GetWeights1Response = RamsesVoterAPIResponse_string_;

export type GetWeights1Error = unknown;

export type IsGauge1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		gauge: string;
	};
};

export type IsGauge1Response = RamsesVoterAPIResponse_boolean_;

export type IsGauge1Error = unknown;

export type IsWhitelisted1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		token: string;
	};
};

export type IsWhitelisted1Response = RamsesVoterAPIResponse_boolean_;

export type IsWhitelisted1Error = unknown;

export type GetLastVoted1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type GetLastVoted1Response = RamsesVoterAPIResponse_string_;

export type GetLastVoted1Error = unknown;

export type Vote1Data = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Vote1Response =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type Vote1Error = unknown;

export type Reset1Data = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Reset1Response =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type Reset1Error = unknown;

export type Poke1Data = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Poke1Response =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type Poke1Error = unknown;

export type AttachTokenToGaugeData = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type AttachTokenToGaugeResponse =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type AttachTokenToGaugeError = unknown;

export type DetachTokenFromGaugeData = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type DetachTokenFromGaugeResponse =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type DetachTokenFromGaugeError = unknown;

export type CreateGauge1Data = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type CreateGauge1Response =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type CreateGauge1Error = unknown;

export type KillGauge1Data = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type KillGauge1Response =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type KillGauge1Error = unknown;

export type ReviveGauge1Data = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ReviveGauge1Response =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type ReviveGauge1Error = unknown;

export type NotifyRewardAmount1Data = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type NotifyRewardAmount1Response =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type NotifyRewardAmount1Error = unknown;

export type Distribute1Data = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Distribute1Response =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type Distribute1Error = unknown;

export type ClaimBribes1Data = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ClaimBribes1Response =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type ClaimBribes1Error = unknown;

export type ClaimFees1Data = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ClaimFees1Response =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type ClaimFees1Error = unknown;

export type ClaimRewards1Data = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ClaimRewards1Response =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type ClaimRewards1Error = unknown;

export type Whitelist1Data = {
	body: RamsesVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Whitelist1Response =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type Whitelist1Error = unknown;

export type VoteWithOptimalDistribution1Data = {
	body: RamsesVoterInputBody & {
		maxPools?: number;
		totalVotes: number;
	};
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type VoteWithOptimalDistribution1Response =
	RamsesVoterAPIResponse_RamsesVoterExecuteFunctionResult_;

export type VoteWithOptimalDistribution1Error = unknown;

export type ListRippleAccountsData = {
	headers: {
		Authorization: string;
	};
};

export type ListRippleAccountsResponse = AccountAPIResponse;

export type ListRippleAccountsError = unknown;

export type CreateRippleAccountData = {
	body: RippleInput;
	headers: {
		Authorization: string;
	};
};

export type CreateRippleAccountResponse = AccountAPIResponse;

export type CreateRippleAccountError = unknown;

export type GetRippleAccountData = {
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type GetRippleAccountResponse = AccountAPIResponse;

export type GetRippleAccountError = unknown;

export type SignRippleTransactionData = {
	body: RippleTransactionInput;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type SignRippleTransactionResponse = RippleAPIResponse;

export type SignRippleTransactionError = unknown;

export type ExportRippleAccountData = {
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type ExportRippleAccountResponse = AccountAPIResponse;

export type ExportRippleAccountError = unknown;

export type DeleteRippleAccountData = {
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type DeleteRippleAccountResponse = AccountAPIResponse;

export type DeleteRippleAccountError = unknown;

export type ListSolanaAccountsData = {
	headers: {
		Authorization: string;
	};
};

export type ListSolanaAccountsResponse = AccountAPIResponse;

export type ListSolanaAccountsError = unknown;

export type CreateSolanaAccountData = {
	body: SolanaInput;
	headers: {
		Authorization: string;
	};
};

export type CreateSolanaAccountResponse = AccountAPIResponse;

export type CreateSolanaAccountError = unknown;

export type GetSolanaAccountData = {
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type GetSolanaAccountResponse = AccountAPIResponse;

export type GetSolanaAccountError = unknown;

export type SignSolanaTransactionData = {
	body: SolanaSignTransactionInput;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type SignSolanaTransactionResponse = SolanaAPIResponse;

export type SignSolanaTransactionError = unknown;

export type MultiSignSolanaTransactionData = {
	body: SolanaSignTransactionInput;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type MultiSignSolanaTransactionResponse = SolanaAPIResponse;

export type MultiSignSolanaTransactionError = unknown;

export type TransferSolanaTransactionData = {
	body: SolanaTransactionInput;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type TransferSolanaTransactionResponse = SolanaAPIResponse;

export type TransferSolanaTransactionError = unknown;

export type TransferTokensSignSolanaTransactionData = {
	body: SolanaTransactionInput;
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type TransferTokensSignSolanaTransactionResponse = SolanaAPIResponse;

export type TransferTokensSignSolanaTransactionError = unknown;

export type ExportSolanaAccountData = {
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type ExportSolanaAccountResponse = AccountAPIResponse;

export type ExportSolanaAccountError = unknown;

export type DeleteSolanaAccountData = {
	headers: {
		Authorization: string;
	};
	path: {
		accountName: string;
	};
};

export type DeleteSolanaAccountResponse = AccountAPIResponse;

export type DeleteSolanaAccountError = unknown;

export type GetFusionsData = {
	headers: {
		Authorization: string;
	};
};

export type GetFusionsResponse = ThenaAPIResponse;

export type GetFusionsError = unknown;

export type GetFusionByAddressData = {
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type GetFusionByAddressResponse = ThenaAPIResponse;

export type GetFusionByAddressError = unknown;

export type GetFusionsByTypeData = {
	headers: {
		Authorization: string;
	};
	path: {
		type: string;
	};
};

export type GetFusionsByTypeResponse = ThenaAPIResponse;

export type GetFusionsByTypeError = unknown;

export type GetTopAprFusionsData = {
	headers: {
		Authorization: string;
	};
	query?: {
		limit?: number;
	};
};

export type GetTopAprFusionsResponse = ThenaAPIResponse;

export type GetTopAprFusionsError = unknown;

export type GetTotalValueLocked2Data = {
	headers: {
		Authorization: string;
	};
};

export type GetTotalValueLocked2Response = ThenaAPIResponse;

export type GetTotalValueLocked2Error = unknown;

export type GetTopTokensData = {
	headers: {
		Authorization: string;
	};
	query?: {
		limit?: number;
	};
};

export type GetTopTokensResponse = ThenaAPIResponse;

export type GetTopTokensError = unknown;

export type GetTopPairsData = {
	headers: {
		Authorization: string;
	};
	query?: {
		limit?: number;
	};
};

export type GetTopPairsResponse = ThenaAPIResponse;

export type GetTopPairsError = unknown;

export type CalculateOptimalVoteDistribution2Data = {
	headers: {
		Authorization: string;
	};
	query: {
		maxFusions?: number;
		totalVotes: number;
	};
};

export type CalculateOptimalVoteDistribution2Response = ThenaAPIResponse;

export type CalculateOptimalVoteDistribution2Error = unknown;

export type GetQuoteData = {
	headers: {
		Authorization: string;
	};
	query: {
		affiliateAddress?: string;
		affiliateBasisPoints?: number;
		allowSmartContractRecipient?: boolean;
		buyAsset: string;
		chainId: string;
		limit?: number;
		preferredProvider?: string;
		providers?: Array<string>;
		recipientAddress: string;
		sellAmount: number;
		sellAsset: string;
		senderAddress: string;
		slippage?: number;
	};
};

export type GetQuoteResponse = ThorSwapAPIResponse_Quote_;

export type GetQuoteError = unknown;

export type SwapData = {
	body: {
		chainId: string;
		accountName: string;
		provider?: string;
		recipientAddress: string;
		senderAddress: string;
		toAsset: string;
		fromAsset: string;
		amount: number;
	};
	headers: {
		Authorization: string;
	};
};

export type SwapResponse = ThorSwapAPIResponse_string_;

export type SwapError = unknown;

export type GetGasPriceData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetGasPriceResponse = ThorSwapAPIResponse_GasPrice_;

export type GetGasPriceError = unknown;

export type GetSupportedChainsData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetSupportedChainsResponse = ThorSwapAPIResponse_string_Array_;

export type GetSupportedChainsError = unknown;

export type GetSupportedProvidersData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetSupportedProvidersResponse = ThorSwapAPIResponse_string_Array_;

export type GetSupportedProvidersError = unknown;

export type TronListTronAccountsData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type TronListTronAccountsResponse = AccountAPIResponse;

export type TronListTronAccountsError = unknown;

export type TronCreateTronAccountData = {
	/**
	 * - The input data required to create a Tron account.
	 */
	body: TronInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
};

export type TronCreateTronAccountResponse = AccountAPIResponse;

export type TronCreateTronAccountError = unknown;

export type TronGetTronAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to retrieve information for.
		 */
		accountName: string;
	};
};

export type TronGetTronAccountResponse = AccountAPIResponse;

export type TronGetTronAccountError = unknown;

export type TronSignTronTransactionData = {
	/**
	 * - The transaction input data.
	 */
	body: TronTransactionInput;
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to sign the transaction for.
		 */
		accountName: string;
	};
};

export type TronSignTronTransactionResponse = TronAPIResponse;

export type TronSignTronTransactionError = unknown;

export type TronExportTronAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be exported.
		 */
		accountName: string;
	};
};

export type TronExportTronAccountResponse = AccountAPIResponse;

export type TronExportTronAccountError = unknown;

export type TronDeleteTronAccountData = {
	headers: {
		/**
		 * - The authorization token from the request header.
		 */
		Authorization: string;
	};
	path: {
		/**
		 * - The name of the account to be deleted.
		 */
		accountName: string;
	};
};

export type TronDeleteTronAccountResponse = AccountAPIResponse;

export type TronDeleteTronAccountError = unknown;

export type GetWeth2Data = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetWeth2Response =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type GetWeth2Error = unknown;

export type AddLiquidity2Data = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type AddLiquidity2Response =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type AddLiquidity2Error = unknown;

export type AddLiquidityEth2Data = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type AddLiquidityEth2Response =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type AddLiquidityEth2Error = unknown;

export type GetAmountInData = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type GetAmountInResponse =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type GetAmountInError = unknown;

export type GetAmountOut2Data = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type GetAmountOut2Response =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type GetAmountOut2Error = unknown;

export type GetAmountsInData = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type GetAmountsInResponse =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type GetAmountsInError = unknown;

export type GetAmountsOut2Data = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type GetAmountsOut2Response =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type GetAmountsOut2Error = unknown;

export type QuoteData = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type QuoteResponse =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type QuoteError = unknown;

export type RemoveLiquidity1Data = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type RemoveLiquidity1Response =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type RemoveLiquidity1Error = unknown;

export type RemoveLiquidityEth1Data = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type RemoveLiquidityEth1Response =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type RemoveLiquidityEth1Error = unknown;

export type RemoveLiquidityEthSupportingFeeOnTransferTokensData = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type RemoveLiquidityEthSupportingFeeOnTransferTokensResponse =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type RemoveLiquidityEthSupportingFeeOnTransferTokensError = unknown;

export type RemoveLiquidityEthWithPermitData = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type RemoveLiquidityEthWithPermitResponse =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type RemoveLiquidityEthWithPermitError = unknown;

export type RemoveLiquidityEthWithPermitSupportingFeeOnTransferTokensData = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type RemoveLiquidityEthWithPermitSupportingFeeOnTransferTokensResponse =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type RemoveLiquidityEthWithPermitSupportingFeeOnTransferTokensError =
	unknown;

export type RemoveLiquidityWithPermitData = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type RemoveLiquidityWithPermitResponse =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type RemoveLiquidityWithPermitError = unknown;

export type SwapEthForExactTokensData = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type SwapEthForExactTokensResponse =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type SwapEthForExactTokensError = unknown;

export type SwapExactEthForTokens2Data = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type SwapExactEthForTokens2Response =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type SwapExactEthForTokens2Error = unknown;

export type SwapExactEthForTokensSupportingFeeOnTransferTokensData = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type SwapExactEthForTokensSupportingFeeOnTransferTokensResponse =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type SwapExactEthForTokensSupportingFeeOnTransferTokensError = unknown;

export type SwapExactTokensForEth2Data = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type SwapExactTokensForEth2Response =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type SwapExactTokensForEth2Error = unknown;

export type SwapExactTokensForEthSupportingFeeOnTransferTokensData = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type SwapExactTokensForEthSupportingFeeOnTransferTokensResponse =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type SwapExactTokensForEthSupportingFeeOnTransferTokensError = unknown;

export type SwapExactTokensForTokens2Data = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type SwapExactTokensForTokens2Response =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type SwapExactTokensForTokens2Error = unknown;

export type SwapExactTokensForTokensSupportingFeeOnTransferTokensData = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type SwapExactTokensForTokensSupportingFeeOnTransferTokensResponse =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type SwapExactTokensForTokensSupportingFeeOnTransferTokensError =
	unknown;

export type SwapTokensForExactEthData = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type SwapTokensForExactEthResponse =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type SwapTokensForExactEthError = unknown;

export type SwapTokensForExactTokensData = {
	body: UniswapV2InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
};

export type SwapTokensForExactTokensResponse =
	UniswapV2APIResponse_UniswapV2ExecuteFunctionResult_;

export type SwapTokensForExactTokensError = unknown;

export type MintData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type MintResponse =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type MintError = unknown;

export type IncreaseLiquidityData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type IncreaseLiquidityResponse =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type IncreaseLiquidityError = unknown;

export type DecreaseLiquidityData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type DecreaseLiquidityResponse =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type DecreaseLiquidityError = unknown;

export type CollectData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type CollectResponse =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type CollectError = unknown;

export type Burn1Data = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Burn1Response =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type Burn1Error = unknown;

export type CreateAndInitializePoolIfNecessaryData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type CreateAndInitializePoolIfNecessaryResponse =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type CreateAndInitializePoolIfNecessaryError = unknown;

export type Approve2Data = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Approve2Response =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type Approve2Error = unknown;

export type SetApprovalForAll1Data = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SetApprovalForAll1Response =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type SetApprovalForAll1Error = unknown;

export type TransferFrom2Data = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type TransferFrom2Response =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type TransferFrom2Error = unknown;

export type PermitData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type PermitResponse =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type PermitError = unknown;

export type MulticallData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type MulticallResponse =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type MulticallError = unknown;

export type SweepTokenData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SweepTokenResponse =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type SweepTokenError = unknown;

export type UnwrapWeth9Data = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type UnwrapWeth9Response =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type UnwrapWeth9Error = unknown;

export type RefundEthData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type RefundEthResponse =
	UniswapV3NFTAPIResponse_UniswapV3ExecuteFunctionResult_;

export type RefundEthError = unknown;

export type PositionsData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: number;
	};
};

export type PositionsResponse = UniswapV3NFTAPIResponse_any_;

export type PositionsError = unknown;

export type TokenOfOwnerByIndexData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		index: number;
		owner: string;
	};
};

export type TokenOfOwnerByIndexResponse = UniswapV3NFTAPIResponse_string_;

export type TokenOfOwnerByIndexError = unknown;

export type BalanceOfData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		owner: string;
	};
};

export type BalanceOfResponse = UniswapV3NFTAPIResponse_string_;

export type BalanceOfError = unknown;

export type DomainSeparatorData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type DomainSeparatorResponse = UniswapV3NFTAPIResponse_string_;

export type DomainSeparatorError = unknown;

export type PermitTypehashData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type PermitTypehashResponse = UniswapV3NFTAPIResponse_string_;

export type PermitTypehashError = unknown;

export type Weth9Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type Weth9Response = UniswapV3NFTAPIResponse_string_;

export type Weth9Error = unknown;

export type FactoryData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type FactoryResponse = UniswapV3NFTAPIResponse_string_;

export type FactoryError = unknown;

export type NameData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type NameResponse = UniswapV3NFTAPIResponse_string_;

export type NameError = unknown;

export type SymbolData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type SymbolResponse = UniswapV3NFTAPIResponse_string_;

export type SymbolError = unknown;

export type TokenUriData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: number;
	};
};

export type TokenUriResponse = UniswapV3NFTAPIResponse_string_;

export type TokenUriError = unknown;

export type BaseUriData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type BaseUriResponse = UniswapV3NFTAPIResponse_string_;

export type BaseUriError = unknown;

export type OwnerOfData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: number;
	};
};

export type OwnerOfResponse = UniswapV3NFTAPIResponse_string_;

export type OwnerOfError = unknown;

export type GetApproved1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: number;
	};
};

export type GetApproved1Response = UniswapV3NFTAPIResponse_string_;

export type GetApproved1Error = unknown;

export type IsApprovedForAll1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		operator: string;
		owner: string;
	};
};

export type IsApprovedForAll1Response = UniswapV3NFTAPIResponse_boolean_;

export type IsApprovedForAll1Error = unknown;

export type TotalSupplyData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type TotalSupplyResponse = UniswapV3NFTAPIResponse_string_;

export type TotalSupplyError = unknown;

export type TokenByIndexData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		index: number;
	};
};

export type TokenByIndexResponse = UniswapV3NFTAPIResponse_string_;

export type TokenByIndexError = unknown;

export type SupportsInterfaceData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		interfaceId: string;
	};
};

export type SupportsInterfaceResponse = UniswapV3NFTAPIResponse_boolean_;

export type SupportsInterfaceError = unknown;

export type ExactInputData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ExactInputResponse =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type ExactInputError = unknown;

export type ExactInputSingleData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ExactInputSingleResponse =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type ExactInputSingleError = unknown;

export type ExactOutputData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ExactOutputResponse =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type ExactOutputError = unknown;

export type ExactOutputSingleData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ExactOutputSingleResponse =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type ExactOutputSingleError = unknown;

export type Multicall1Data = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Multicall1Response =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type Multicall1Error = unknown;

export type RefundEth1Data = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type RefundEth1Response =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type RefundEth1Error = unknown;

export type SelfPermitData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SelfPermitResponse =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type SelfPermitError = unknown;

export type SelfPermitAllowedData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SelfPermitAllowedResponse =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type SelfPermitAllowedError = unknown;

export type SelfPermitAllowedIfNecessaryData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SelfPermitAllowedIfNecessaryResponse =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type SelfPermitAllowedIfNecessaryError = unknown;

export type SelfPermitIfNecessaryData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SelfPermitIfNecessaryResponse =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type SelfPermitIfNecessaryError = unknown;

export type SweepToken1Data = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SweepToken1Response =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type SweepToken1Error = unknown;

export type SweepTokenWithFeeData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SweepTokenWithFeeResponse =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type SweepTokenWithFeeError = unknown;

export type UnwrapWeth91Data = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type UnwrapWeth91Response =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type UnwrapWeth91Error = unknown;

export type UnwrapWeth9WithFeeData = {
	body: UniswapV3InputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type UnwrapWeth9WithFeeResponse =
	UniswapV3APIResponse_UniswapV3ExecuteFunctionResult_;

export type UnwrapWeth9WithFeeError = unknown;

export type Weth91Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type Weth91Response = UniswapV3APIResponse_string_;

export type Weth91Error = unknown;

export type Factory1Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type Factory1Response = UniswapV3APIResponse_string_;

export type Factory1Error = unknown;

export type GetBalanceOf2Data = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetBalanceOf2Response = VeTheNFTAPIResponse_string_;

export type GetBalanceOf2Error = unknown;

export type GetOwnerOf2Data = {
	headers: {
		Authorization: string;
	};
	path: {
		tokenId: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetOwnerOf2Response = VeTheNFTAPIResponse_string_;

export type GetOwnerOf2Error = unknown;

export type GetTokenUri2Data = {
	headers: {
		Authorization: string;
	};
	path: {
		tokenId: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetTokenUri2Response = VeTheNFTAPIResponse_string_;

export type GetTokenUri2Error = unknown;

export type GetApproved2Data = {
	headers: {
		Authorization: string;
	};
	path: {
		tokenId: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetApproved2Response = VeTheNFTAPIResponse_string_;

export type GetApproved2Error = unknown;

export type IsApprovedForAll2Data = {
	headers: {
		Authorization: string;
	};
	path: {
		owner: string;
	};
	query: {
		address: string;
		chainId: string;
		operator: string;
	};
};

export type IsApprovedForAll2Response = VeTheNFTAPIResponse_boolean_;

export type IsApprovedForAll2Error = unknown;

export type GetBalanceOfNft2Data = {
	headers: {
		Authorization: string;
	};
	path: {
		tokenId: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetBalanceOfNft2Response = VeTheNFTAPIResponse_string_;

export type GetBalanceOfNft2Error = unknown;

export type GetTotalSupply2Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetTotalSupply2Response = VeTheNFTAPIResponse_string_;

export type GetTotalSupply2Error = unknown;

export type GetLocked1Data = {
	headers: {
		Authorization: string;
	};
	path: {
		tokenId: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetLocked1Response = VeTheNFTAPIResponse_LockedData_;

export type GetLocked1Error = unknown;

export type GetLockedEndData = {
	headers: {
		Authorization: string;
	};
	path: {
		tokenId: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetLockedEndResponse = VeTheNFTAPIResponse_string_;

export type GetLockedEndError = unknown;

export type CreateLock2Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type CreateLock2Response =
	VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type CreateLock2Error = unknown;

export type CreateLockFor1Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type CreateLockFor1Response =
	VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type CreateLockFor1Error = unknown;

export type IncreaseLockAmount1Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type IncreaseLockAmount1Response =
	VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type IncreaseLockAmount1Error = unknown;

export type IncreaseUnlockTime2Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type IncreaseUnlockTime2Response =
	VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type IncreaseUnlockTime2Error = unknown;

export type Withdraw1Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Withdraw1Response = VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type Withdraw1Error = unknown;

export type Approve3Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Approve3Response = VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type Approve3Error = unknown;

export type SetApprovalForAll2Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SetApprovalForAll2Response =
	VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type SetApprovalForAll2Error = unknown;

export type TransferFrom3Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type TransferFrom3Response =
	VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type TransferFrom3Error = unknown;

export type SafeTransferFrom1Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type SafeTransferFrom1Response =
	VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type SafeTransferFrom1Error = unknown;

export type Merge2Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Merge2Response = VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type Merge2Error = unknown;

export type Split2Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Split2Response = VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type Split2Error = unknown;

export type VotingData = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type VotingResponse = VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type VotingError = unknown;

export type Abstain1Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Abstain1Response = VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type Abstain1Error = unknown;

export type Attach1Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Attach1Response = VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type Attach1Error = unknown;

export type Detach1Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Detach1Response = VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type Detach1Error = unknown;

export type DepositForData = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type DepositForResponse =
	VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type DepositForError = unknown;

export type Checkpoint1Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Checkpoint1Response =
	VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type Checkpoint1Error = unknown;

export type Delegate2Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Delegate2Response = VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type Delegate2Error = unknown;

export type DelegateBySig1Data = {
	body: VeNFTInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type DelegateBySig1Response =
	VeTheNFTAPIResponse_VeNFTExecuteFunctionResult_;

export type DelegateBySig1Error = unknown;

export type GetLastUserSlopeData = {
	headers: {
		Authorization: string;
	};
	path: {
		tokenId: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetLastUserSlopeResponse = VeTheNFTAPIResponse_string_;

export type GetLastUserSlopeError = unknown;

export type GetUserPointHistoryData = {
	headers: {
		Authorization: string;
	};
	path: {
		tokenId: string;
	};
	query: {
		address: string;
		chainId: string;
		loc: string;
	};
};

export type GetUserPointHistoryResponse =
	VeTheNFTAPIResponse_UserPointHistoryData_;

export type GetUserPointHistoryError = unknown;

export type GetUserPointHistoryTsData = {
	headers: {
		Authorization: string;
	};
	path: {
		tokenId: string;
	};
	query: {
		address: string;
		chainId: string;
		idx: string;
	};
};

export type GetUserPointHistoryTsResponse = VeTheNFTAPIResponse_string_;

export type GetUserPointHistoryTsError = unknown;

export type GetBalanceOfAtNftData = {
	headers: {
		Authorization: string;
	};
	path: {
		tokenId: string;
	};
	query: {
		address: string;
		block: string;
		chainId: string;
	};
};

export type GetBalanceOfAtNftResponse = VeTheNFTAPIResponse_string_;

export type GetBalanceOfAtNftError = unknown;

export type GetTotalSupplyAtData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		block: string;
		chainId: string;
	};
};

export type GetTotalSupplyAtResponse = VeTheNFTAPIResponse_string_;

export type GetTotalSupplyAtError = unknown;

export type GetTotalSupplyAtTData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		t: string;
	};
};

export type GetTotalSupplyAtTResponse = VeTheNFTAPIResponse_string_;

export type GetTotalSupplyAtTError = unknown;

export type GetPastVotes2Data = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
	query: {
		address: string;
		chainId: string;
		timestamp: string;
	};
};

export type GetPastVotes2Response = VeTheNFTAPIResponse_string_;

export type GetPastVotes2Error = unknown;

export type GetPastTotalSupplyData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		timestamp: string;
	};
};

export type GetPastTotalSupplyResponse = VeTheNFTAPIResponse_string_;

export type GetPastTotalSupplyError = unknown;

export type GetVotes2Data = {
	headers: {
		Authorization: string;
	};
	path: {
		account: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetVotes2Response = VeTheNFTAPIResponse_string_;

export type GetVotes2Error = unknown;

export type GetDelegates2Data = {
	headers: {
		Authorization: string;
	};
	path: {
		delegator: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetDelegates2Response = VeTheNFTAPIResponse_string_;

export type GetDelegates2Error = unknown;

export type GetTotalWeight2Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
	};
};

export type GetTotalWeight2Response = VeTheNftVoterAPIResponse_string_;

export type GetTotalWeight2Error = unknown;

export type GetWeights2Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		pool: string;
	};
};

export type GetWeights2Response = VeTheNftVoterAPIResponse_string_;

export type GetWeights2Error = unknown;

export type IsGauge2Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		gauge: string;
	};
};

export type IsGauge2Response = VeTheNftVoterAPIResponse_boolean_;

export type IsGauge2Error = unknown;

export type Vote2Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Vote2Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type Vote2Error = unknown;

export type Reset2Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Reset2Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type Reset2Error = unknown;

export type Poke2Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Poke2Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type Poke2Error = unknown;

export type CreateGauge2Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type CreateGauge2Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type CreateGauge2Error = unknown;

export type VoteWithOptimalDistribution2Data = {
	body: VeTheNftVoterInputBody & {
		maxFusions?: number;
		totalVotes: number;
	};
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type VoteWithOptimalDistribution2Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type VoteWithOptimalDistribution2Error = unknown;

export type IsWhitelisted2Data = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenAddress: string;
	};
};

export type IsWhitelisted2Response = VeTheNftVoterAPIResponse_boolean_;

export type IsWhitelisted2Error = unknown;

export type LastVotedData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type LastVotedResponse = VeTheNftVoterAPIResponse_string_;

export type LastVotedError = unknown;

export type PoolVoteLengthData = {
	headers: {
		Authorization: string;
	};
	query: {
		address: string;
		chainId: string;
		tokenId: string;
	};
};

export type PoolVoteLengthResponse = VeTheNftVoterAPIResponse_string_;

export type PoolVoteLengthError = unknown;

export type AttachTokenToGauge1Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type AttachTokenToGauge1Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type AttachTokenToGauge1Error = unknown;

export type DetachTokenFromGauge1Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type DetachTokenFromGauge1Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type DetachTokenFromGauge1Error = unknown;

export type KillGauge2Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type KillGauge2Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type KillGauge2Error = unknown;

export type ReviveGauge2Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ReviveGauge2Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type ReviveGauge2Error = unknown;

export type NotifyRewardAmount2Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type NotifyRewardAmount2Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type NotifyRewardAmount2Error = unknown;

export type Distribute2Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Distribute2Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type Distribute2Error = unknown;

export type ClaimBribes2Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ClaimBribes2Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type ClaimBribes2Error = unknown;

export type ClaimFees2Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ClaimFees2Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type ClaimFees2Error = unknown;

export type ClaimRewards2Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type ClaimRewards2Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type ClaimRewards2Error = unknown;

export type Whitelist2Data = {
	body: VeTheNftVoterInputBody;
	headers: {
		Authorization: string;
	};
	path: {
		address: string;
	};
};

export type Whitelist2Response =
	VeTheNftVoterAPIResponse_VeTheNftVoterExecuteFunctionResult_;

export type Whitelist2Error = unknown;
